{
  alerting: {
    v1alpha1: {
      contactPoint: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xcontactpoints.alerting.grafana.crossplane.io.namespaced',
            },
            name: 'contactpoint-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'alerting.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XContactPoint',
            },
            resources: [
              {
                base: {
                  apiVersion: 'alerting.grafana.crossplane.io/v1alpha1',
                  kind: 'ContactPoint',
                },
                name: 'contactpoint',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.alertmanager',
                    toFieldPath: 'spec.forProvider.alertmanager',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dingding',
                    toFieldPath: 'spec.forProvider.dingding',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.disableProvenance',
                    toFieldPath: 'spec.forProvider.disableProvenance',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.discord',
                    toFieldPath: 'spec.forProvider.discord',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.email',
                    toFieldPath: 'spec.forProvider.email',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.googlechat',
                    toFieldPath: 'spec.forProvider.googlechat',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.kafka',
                    toFieldPath: 'spec.forProvider.kafka',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.line',
                    toFieldPath: 'spec.forProvider.line',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.oncall',
                    toFieldPath: 'spec.forProvider.oncall',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.opsgenie',
                    toFieldPath: 'spec.forProvider.opsgenie',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.pagerduty',
                    toFieldPath: 'spec.forProvider.pagerduty',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.pushover',
                    toFieldPath: 'spec.forProvider.pushover',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.sensugo',
                    toFieldPath: 'spec.forProvider.sensugo',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.slack',
                    toFieldPath: 'spec.forProvider.slack',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.sns',
                    toFieldPath: 'spec.forProvider.sns',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teams',
                    toFieldPath: 'spec.forProvider.teams',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.telegram',
                    toFieldPath: 'spec.forProvider.telegram',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.threema',
                    toFieldPath: 'spec.forProvider.threema',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.victorops',
                    toFieldPath: 'spec.forProvider.victorops',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.webex',
                    toFieldPath: 'spec.forProvider.webex',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.webhook',
                    toFieldPath: 'spec.forProvider.webhook',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.wecom',
                    toFieldPath: 'spec.forProvider.wecom',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.alertmanager',
                    toFieldPath: 'spec.initProvider.alertmanager',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dingding',
                    toFieldPath: 'spec.initProvider.dingding',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.disableProvenance',
                    toFieldPath: 'spec.initProvider.disableProvenance',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.discord',
                    toFieldPath: 'spec.initProvider.discord',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.email',
                    toFieldPath: 'spec.initProvider.email',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.googlechat',
                    toFieldPath: 'spec.initProvider.googlechat',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.kafka',
                    toFieldPath: 'spec.initProvider.kafka',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.line',
                    toFieldPath: 'spec.initProvider.line',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.oncall',
                    toFieldPath: 'spec.initProvider.oncall',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.opsgenie',
                    toFieldPath: 'spec.initProvider.opsgenie',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.pagerduty',
                    toFieldPath: 'spec.initProvider.pagerduty',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.pushover',
                    toFieldPath: 'spec.initProvider.pushover',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.sensugo',
                    toFieldPath: 'spec.initProvider.sensugo',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.slack',
                    toFieldPath: 'spec.initProvider.slack',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.sns',
                    toFieldPath: 'spec.initProvider.sns',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teams',
                    toFieldPath: 'spec.initProvider.teams',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.telegram',
                    toFieldPath: 'spec.initProvider.telegram',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.threema',
                    toFieldPath: 'spec.initProvider.threema',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.victorops',
                    toFieldPath: 'spec.initProvider.victorops',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.webex',
                    toFieldPath: 'spec.initProvider.webex',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.webhook',
                    toFieldPath: 'spec.initProvider.webhook',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.wecom',
                    toFieldPath: 'spec.initProvider.wecom',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xcontactpoints.alerting.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'ContactPoint',
              plural: 'contactpoints',
            },
            defaultCompositionRef: {
              name: 'contactpoint-namespaced',
            },
            group: 'alerting.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XContactPoint',
              plural: 'xcontactpoints',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'ContactPointSpec defines the desired state of ContactPoint',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  alertmanager: {
                                    description: '(Block Set) A contact point that sends notifications to other Alertmanager instances. (see below for nested schema)\nA contact point that sends notifications to other Alertmanager instances.',
                                    items: {
                                      properties: {
                                        basicAuthPasswordSecretRef: {
                                          description: '(String, Sensitive) The password component of the basic auth credentials to use.\nThe password component of the basic auth credentials to use.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        basicAuthUser: {
                                          description: '(String) The username component of the basic auth credentials to use.\nThe username component of the basic auth credentials to use.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe URL of the Alertmanager instance.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  dingding: {
                                    description: '(Block Set) A contact point that sends notifications to DingDing. (see below for nested schema)\nA contact point that sends notifications to DingDing.',
                                    items: {
                                      properties: {
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated content of the message.',
                                          type: 'string',
                                        },
                                        messageType: {
                                          description: "either 'link' or 'actionCard'\nThe format of message to send - either 'link' or 'actionCard'",
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated title of the message.',
                                          type: 'string',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe DingDing webhook URL.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  disableProvenance: {
                                    description: 'Defaults to false. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  discord: {
                                    description: '(Block Set) A contact point that sends notifications as Discord messages (see below for nested schema)\nA contact point that sends notifications as Discord messages',
                                    items: {
                                      properties: {
                                        avatarUrl: {
                                          description: '(String) The URL of a custom avatar image to use. Defaults to “.\nThe URL of a custom avatar image to use. Defaults to “.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated content of the message. Defaults to “.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated content of the title.',
                                          type: 'string',
                                        },
                                        urlSecretRef: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe discord webhook URL.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        useDiscordUsername: {
                                          description: "(Boolean) Whether to use the bot account's plain username instead of \"Grafana.\" Defaults to false.\nWhether to use the bot account's plain username instead of \"Grafana.\" Defaults to `false`.",
                                          type: 'boolean',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  email: {
                                    description: '(Block Set) A contact point that sends notifications to an email address. (see below for nested schema)\nA contact point that sends notifications to an email address.',
                                    items: {
                                      properties: {
                                        addresses: {
                                          description: '(List of String) The addresses to send emails to.\nThe addresses to send emails to.',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated content of the email. Defaults to “.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        singleEmail: {
                                          description: "(Boolean) Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to false.\nWhether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.",
                                          type: 'boolean',
                                        },
                                        subject: {
                                          description: '(String) The templated subject line of the email. Defaults to “.\nThe templated subject line of the email. Defaults to “.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  googlechat: {
                                    description: '(Block Set) A contact point that sends notifications to Google Chat. (see below for nested schema)\nA contact point that sends notifications to Google Chat.',
                                    items: {
                                      properties: {
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated content of the message.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated content of the title.',
                                          type: 'string',
                                        },
                                        urlSecretRef: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe Google Chat webhook URL.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  kafka: {
                                    description: '(Block Set) A contact point that publishes notifications to Apache Kafka topics. (see below for nested schema)\nA contact point that publishes notifications to Apache Kafka topics.',
                                    items: {
                                      properties: {
                                        apiVersion: {
                                          description: '(String) The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to v2.\nThe API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.',
                                          type: 'string',
                                        },
                                        clusterId: {
                                          description: "(String) The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'\nThe Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'",
                                          type: 'string',
                                        },
                                        description: {
                                          description: '(String) The templated description of the Kafka message.\nThe templated description of the Kafka message.',
                                          type: 'string',
                                        },
                                        details: {
                                          description: '(String) The templated details to include with the message.\nThe templated details to include with the message.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        passwordSecretRef: {
                                          description: '(String, Sensitive) The password to use when making a call to the Kafka REST Proxy\nThe password to use when making a call to the Kafka REST Proxy',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        restProxyUrlSecretRef: {
                                          description: '(String, Sensitive) The URL of the Kafka REST proxy to send requests to.\nThe URL of the Kafka REST proxy to send requests to.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        topic: {
                                          description: '(String) The name of the Kafka topic to publish to.\nThe name of the Kafka topic to publish to.',
                                          type: 'string',
                                        },
                                        username: {
                                          description: '(String) The user name to use when making a call to the Kafka REST Proxy\nThe user name to use when making a call to the Kafka REST Proxy',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  line: {
                                    description: '(Block Set) A contact point that sends notifications to LINE.me. (see below for nested schema)\nA contact point that sends notifications to LINE.me.',
                                    items: {
                                      properties: {
                                        description: {
                                          description: '(String) The templated description of the Kafka message.\nThe templated description of the message.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated title of the message.',
                                          type: 'string',
                                        },
                                        tokenSecretRef: {
                                          description: '(String, Sensitive) The bearer token used to authorize the client.\nThe bearer token used to authorize the client.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  name: {
                                    description: '(String) The name of the contact point.\nThe name of the contact point.',
                                    type: 'string',
                                  },
                                  oncall: {
                                    description: 'Call. (see below for nested schema)\nA contact point that sends notifications to Grafana On-Call.',
                                    items: {
                                      properties: {
                                        authorizationCredentialsSecretRef: {
                                          description: 'attaches an auth header with this value. Do not use in conjunction with basic auth parameters.\nAllows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        authorizationScheme: {
                                          description: 'attaches an auth header with this name. Do not use in conjunction with basic auth parameters.\nAllows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.',
                                          type: 'string',
                                        },
                                        basicAuthPasswordSecretRef: {
                                          description: '(String, Sensitive) The password component of the basic auth credentials to use.\nThe username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        basicAuthUser: {
                                          description: '(String) The username component of the basic auth credentials to use.\nThe username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        httpMethod: {
                                          description: '(String) The HTTP method to use in the request. Defaults to POST.\nThe HTTP method to use in the request. Defaults to `POST`.',
                                          type: 'string',
                                        },
                                        maxAlerts: {
                                          description: '(Number) The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.\nThe maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.',
                                          type: 'number',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nCustom message. You can use template variables.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nTemplated title of the message.',
                                          type: 'string',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe URL to send webhook requests to.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  opsgenie: {
                                    description: '(Block Set) A contact point that sends notifications to OpsGenie. (see below for nested schema)\nA contact point that sends notifications to OpsGenie.',
                                    items: {
                                      properties: {
                                        apiKeySecretRef: {
                                          description: '(String, Sensitive) The OpsGenie API key to use.\nThe OpsGenie API key to use.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        autoClose: {
                                          description: 'close alerts in OpsGenie when they resolve in the Alertmanager.\nWhether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.',
                                          type: 'boolean',
                                        },
                                        description: {
                                          description: '(String) The templated description of the Kafka message.\nA templated high-level description to use for the alert.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated content of the message.',
                                          type: 'string',
                                        },
                                        overridePriority: {
                                          description: '(Boolean) Whether to allow the alert priority to be configured via the value of the og_priority annotation on the alert.\nWhether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.',
                                          type: 'boolean',
                                        },
                                        responders: {
                                          description: '(Block List) Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+. (see below for nested schema)\nTeams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.',
                                          items: {
                                            properties: {
                                              id: {
                                                description: '(String) The ID of this resource.\nID of the responder. Must be specified if name and username are empty.',
                                                type: 'string',
                                              },
                                              name: {
                                                description: '(String) The name of the contact point.\nName of the responder. Must be specified if username and id are empty.',
                                                type: 'string',
                                              },
                                              type: {
                                                description: '(String) Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.\nType of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.',
                                                type: 'string',
                                              },
                                              username: {
                                                description: '(String) The user name to use when making a call to the Kafka REST Proxy\nUser name of the responder. Must be specified if name and id are empty.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        sendTagsAs: {
                                          description: '(String) Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are tags, details, both, or empty to use the default behavior of Tags.\nWhether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nAllows customization of the OpsGenie API URL.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  pagerduty: {
                                    description: '(Block Set) A contact point that sends notifications to PagerDuty. (see below for nested schema)\nA contact point that sends notifications to PagerDuty.',
                                    items: {
                                      properties: {
                                        class: {
                                          description: '(String) The class or type of event, for example ping failure.\nThe class or type of event, for example `ping failure`.',
                                          type: 'string',
                                        },
                                        client: {
                                          description: '(String) The name of the monitoring client that is triggering this event.\nThe name of the monitoring client that is triggering this event.',
                                          type: 'string',
                                        },
                                        clientUrl: {
                                          description: '(String) The URL of the monitoring client that is triggering this event.\nThe URL of the monitoring client that is triggering this event.',
                                          type: 'string',
                                        },
                                        component: {
                                          description: '(String) The component being affected by the event.\nThe component being affected by the event.',
                                          type: 'string',
                                        },
                                        details: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          description: '(String) The templated details to include with the message.\nA set of arbitrary key/value pairs that provide further detail about the incident.',
                                          type: 'object',
                                          'x-kubernetes-map-type': 'granular',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        group: {
                                          description: '(String) The group to which the provided component belongs to.\nThe group to which the provided component belongs to.',
                                          type: 'string',
                                        },
                                        integrationKeySecretRef: {
                                          description: '(String, Sensitive) The PagerDuty API key.\nThe PagerDuty API key.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        severity: {
                                          description: '(String) The PagerDuty event severity level. Default is critical.\nThe PagerDuty event severity level. Default is `critical`.',
                                          type: 'string',
                                        },
                                        source: {
                                          description: '(String) The unique location of the affected system.\nThe unique location of the affected system.',
                                          type: 'string',
                                        },
                                        summary: {
                                          description: '(String) The templated summary message of the event.\nThe templated summary message of the event.',
                                          type: 'string',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe URL to send API requests to',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  pushover: {
                                    description: '(Block Set) A contact point that sends notifications to Pushover. (see below for nested schema)\nA contact point that sends notifications to Pushover.',
                                    items: {
                                      properties: {
                                        apiTokenSecretRef: {
                                          description: '(String, Sensitive) The Pushover API token.\nThe Pushover API token.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        device: {
                                          description: 'separated list of devices to which the event is associated.\nComma-separated list of devices to which the event is associated.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        expire: {
                                          description: '(Number) How many seconds for which the notification will continue to be retried by Pushover.\nHow many seconds for which the notification will continue to be retried by Pushover.',
                                          type: 'number',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated notification message content.',
                                          type: 'string',
                                        },
                                        okPriority: {
                                          description: '(Number) The priority level of the resolved event.\nThe priority level of the resolved event.',
                                          type: 'number',
                                        },
                                        okSound: {
                                          description: '(String) The sound associated with the resolved notification.\nThe sound associated with the resolved notification.',
                                          type: 'string',
                                        },
                                        priority: {
                                          description: '(Number) The priority level of the event.\nThe priority level of the event.',
                                          type: 'number',
                                        },
                                        retry: {
                                          description: '(Number) How often, in seconds, the Pushover servers will send the same notification to the user.\nHow often, in seconds, the Pushover servers will send the same notification to the user.',
                                          type: 'number',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        sound: {
                                          description: '(String) The sound associated with the notification.\nThe sound associated with the notification.',
                                          type: 'string',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated title of the message.',
                                          type: 'string',
                                        },
                                        uploadImage: {
                                          description: '(Boolean) Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.\nWhether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.',
                                          type: 'boolean',
                                        },
                                        userKeySecretRef: {
                                          description: '(String, Sensitive) The Pushover user key.\nThe Pushover user key.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  sensugo: {
                                    description: '(Block Set) A contact point that sends notifications to SensuGo. (see below for nested schema)\nA contact point that sends notifications to SensuGo.',
                                    items: {
                                      properties: {
                                        apiKeySecretRef: {
                                          description: '(String, Sensitive) The OpsGenie API key to use.\nThe SensuGo API key.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        check: {
                                          description: '(String) The SensuGo check to which the event should be routed.\nThe SensuGo check to which the event should be routed.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        entity: {
                                          description: '(String) The entity being monitored.\nThe entity being monitored.',
                                          type: 'string',
                                        },
                                        handler: {
                                          description: '(String) A custom handler to execute in addition to the check.\nA custom handler to execute in addition to the check.',
                                          type: 'string',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nTemplated message content describing the alert.',
                                          type: 'string',
                                        },
                                        namespace: {
                                          description: '(String) The namespace in which the check resides.\nThe namespace in which the check resides.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe SensuGo URL to send requests to.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  slack: {
                                    description: '(Block Set) A contact point that sends notifications to Slack. (see below for nested schema)\nA contact point that sends notifications to Slack.',
                                    items: {
                                      properties: {
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        endpointUrl: {
                                          description: '(String) Use this to override the Slack API endpoint URL to send requests to.\nUse this to override the Slack API endpoint URL to send requests to.',
                                          type: 'string',
                                        },
                                        iconEmoji: {
                                          description: '(String) The name of a Slack workspace emoji to use as the bot icon.\nThe name of a Slack workspace emoji to use as the bot icon.',
                                          type: 'string',
                                        },
                                        iconUrl: {
                                          description: '(String) A URL of an image to use as the bot icon.\nA URL of an image to use as the bot icon.',
                                          type: 'string',
                                        },
                                        mentionChannel: {
                                          description: '(String) Describes how to ping the slack channel that messages are being sent to. Options are here for an @here ping, channel for @channel, or empty for no ping.\nDescribes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.',
                                          type: 'string',
                                        },
                                        mentionGroups: {
                                          description: 'separated list of groups to mention in the message.\nComma-separated list of groups to mention in the message.',
                                          type: 'string',
                                        },
                                        mentionUsers: {
                                          description: 'separated list of users to mention in the message.\nComma-separated list of users to mention in the message.',
                                          type: 'string',
                                        },
                                        recipient: {
                                          description: '(String) Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.\nChannel, private group, or IM channel (can be an encoded ID or a name) to send messages to.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        text: {
                                          description: '(String) Templated content of the message.\nTemplated content of the message.',
                                          type: 'string',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nTemplated title of the message.',
                                          type: 'string',
                                        },
                                        tokenSecretRef: {
                                          description: '(String, Sensitive) The bearer token used to authorize the client.\nA Slack API token,for sending messages directly without the webhook method.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        urlSecretRef: {
                                          description: '(String) The URL of the Alertmanager instance.\nA Slack webhook URL,for sending messages via the webhook method.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        username: {
                                          description: '(String) The user name to use when making a call to the Kafka REST Proxy\nUsername for the bot to use.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  sns: {
                                    description: '(Block Set) A contact point that sends notifications to Amazon SNS. Requires Amazon Managed Grafana. (see below for nested schema)\nA contact point that sends notifications to Amazon SNS. Requires Amazon Managed Grafana.',
                                    items: {
                                      properties: {
                                        accessKeySecretRef: {
                                          description: '(String, Sensitive) AWS access key ID used to authenticate with Amazon SNS.\nAWS access key ID used to authenticate with Amazon SNS.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        assumeRoleArn: {
                                          description: '(String) The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.\nThe Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.',
                                          type: 'string',
                                        },
                                        authProvider: {
                                          description: '(String) The authentication provider to use. Valid values are default, arn and keys. Default is default. Defaults to default.\nThe authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.',
                                          type: 'string',
                                        },
                                        body: {
                                          description: '(String)',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        externalId: {
                                          description: '(String) The external ID to use when assuming the role.\nThe external ID to use when assuming the role.',
                                          type: 'string',
                                        },
                                        messageFormat: {
                                          description: '(String) The format of the message to send. Valid values are text, body and json. Default is text. Defaults to text.\nThe format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.',
                                          type: 'string',
                                        },
                                        secretKeySecretRef: {
                                          description: '(String, Sensitive) AWS secret access key used to authenticate with Amazon SNS.\nAWS secret access key used to authenticate with Amazon SNS.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        subject: {
                                          description: '(String) The templated subject line of the email. Defaults to “.',
                                          type: 'string',
                                        },
                                        topic: {
                                          description: '(String) The name of the Kafka topic to publish to.\nThe Amazon SNS topic to send notifications to.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  teams: {
                                    description: '(Block Set) A contact point that sends notifications to Microsoft Teams. (see below for nested schema)\nA contact point that sends notifications to Microsoft Teams.',
                                    items: {
                                      properties: {
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated message content to send.',
                                          type: 'string',
                                        },
                                        sectionTitle: {
                                          description: '(String) The templated subtitle for each message section.\nThe templated subtitle for each message section.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated title of the message.',
                                          type: 'string',
                                        },
                                        urlSecretRef: {
                                          description: '(String) The URL of the Alertmanager instance.\nA Teams webhook URL.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  telegram: {
                                    description: '(Block Set) A contact point that sends notifications to Telegram. (see below for nested schema)\nA contact point that sends notifications to Telegram.',
                                    items: {
                                      properties: {
                                        chatId: {
                                          description: '(String) The chat ID to send messages to.\nThe chat ID to send messages to.',
                                          type: 'string',
                                        },
                                        disableNotifications: {
                                          description: '(Boolean) When set users will receive a notification with no sound.\nWhen set users will receive a notification with no sound.',
                                          type: 'boolean',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        disableWebPagePreview: {
                                          description: '(Boolean) When set it disables link previews for links in the message.\nWhen set it disables link previews for links in the message.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated content of the message.',
                                          type: 'string',
                                        },
                                        messageThreadId: {
                                          description: '(String) The ID of the message thread to send the message to.\nThe ID of the message thread to send the message to.',
                                          type: 'string',
                                        },
                                        parseMode: {
                                          description: '(String) Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.\nMode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.',
                                          type: 'string',
                                        },
                                        protectContent: {
                                          description: '(Boolean) When set it protects the contents of the message from forwarding and saving.\nWhen set it protects the contents of the message from forwarding and saving.',
                                          type: 'boolean',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        tokenSecretRef: {
                                          description: '(String, Sensitive) The bearer token used to authorize the client.\nThe Telegram bot token.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  threema: {
                                    description: '(Block Set) A contact point that sends notifications to Threema. (see below for nested schema)\nA contact point that sends notifications to Threema.',
                                    items: {
                                      properties: {
                                        apiSecretSecretRef: {
                                          description: '(String, Sensitive) The Threema API key.\nThe Threema API key.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        description: {
                                          description: '(String) The templated description of the Kafka message.\nThe templated description of the message.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        gatewayId: {
                                          description: '(String) The Threema gateway ID.\nThe Threema gateway ID.',
                                          type: 'string',
                                        },
                                        recipientId: {
                                          description: '(String) The ID of the recipient of the message.\nThe ID of the recipient of the message.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated title of the message.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  victorops: {
                                    description: '(Block Set) A contact point that sends notifications to VictorOps (now known as Splunk OnCall). (see below for nested schema)\nA contact point that sends notifications to VictorOps (now known as Splunk OnCall).',
                                    items: {
                                      properties: {
                                        description: {
                                          description: '(String) The templated description of the Kafka message.\nTemplated description of the message.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        messageType: {
                                          description: "either 'link' or 'actionCard'\nThe VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.",
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nTemplated title to display.',
                                          type: 'string',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe VictorOps webhook URL.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  webex: {
                                    description: '(Block Set) A contact point that sends notifications to Cisco Webex. (see below for nested schema)\nA contact point that sends notifications to Cisco Webex.',
                                    items: {
                                      properties: {
                                        apiUrl: {
                                          description: '(String) The URL to send webhook requests to.\nThe URL to send webhook requests to.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated title of the message to send.',
                                          type: 'string',
                                        },
                                        roomId: {
                                          description: '(String) ID of the Webex Teams room where to send the messages.\nID of the Webex Teams room where to send the messages.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        tokenSecretRef: {
                                          description: '(String, Sensitive) The bearer token used to authorize the client.\nThe bearer token used to authorize the client.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  webhook: {
                                    description: '(Block Set) A contact point that sends notifications to an arbitrary webhook, using the Prometheus webhook format defined here: https://prometheus.io/docs/alerting/latest/configuration/#webhook_config (see below for nested schema)\nA contact point that sends notifications to an arbitrary webhook, using the Prometheus webhook format defined here: https://prometheus.io/docs/alerting/latest/configuration/#webhook_config',
                                    items: {
                                      properties: {
                                        authorizationCredentialsSecretRef: {
                                          description: 'attaches an auth header with this value. Do not use in conjunction with basic auth parameters.\nAllows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        authorizationScheme: {
                                          description: 'attaches an auth header with this name. Do not use in conjunction with basic auth parameters.\nAllows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.',
                                          type: 'string',
                                        },
                                        basicAuthPasswordSecretRef: {
                                          description: '(String, Sensitive) The password component of the basic auth credentials to use.\nThe username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        basicAuthUser: {
                                          description: '(String) The username component of the basic auth credentials to use.\nThe username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        httpMethod: {
                                          description: '(String) The HTTP method to use in the request. Defaults to POST.\nThe HTTP method to use in the request. Defaults to `POST`.',
                                          type: 'string',
                                        },
                                        maxAlerts: {
                                          description: '(Number) The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.\nThe maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.',
                                          type: 'number',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nCustom message. You can use template variables.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nTemplated title of the message.',
                                          type: 'string',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe URL to send webhook requests to.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  wecom: {
                                    description: '(Block Set) A contact point that sends notifications to WeCom. (see below for nested schema)\nA contact point that sends notifications to WeCom.',
                                    items: {
                                      properties: {
                                        agentId: {
                                          description: '(String) Agent ID added to the request payload when using APIAPP.\nAgent ID added to the request payload when using APIAPP.',
                                          type: 'string',
                                        },
                                        corpId: {
                                          description: '(String) Corp ID used to get token when using APIAPP.\nCorp ID used to get token when using APIAPP.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated content of the message to send.',
                                          type: 'string',
                                        },
                                        msgType: {
                                          description: '(String) The type of them message. Supported: markdown, text. Default: text.\nThe type of them message. Supported: markdown, text. Default: text.',
                                          type: 'string',
                                        },
                                        secretSecretRef: {
                                          description: '(String, Sensitive) The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.\nThe secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        settingsSecretRef: {
                                          description: '(Map of String, Sensitive) Additional custom properties to attach to the notifier. Defaults to map[].\nAdditional custom properties to attach to the notifier. Defaults to `map[]`.',
                                          properties: {
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated title of the message to send.',
                                          type: 'string',
                                        },
                                        toUser: {
                                          description: "(String) The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.\nThe ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.",
                                          type: 'string',
                                        },
                                        urlSecretRef: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe WeCom webhook URL. Required if using GroupRobot.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  alertmanager: {
                                    description: '(Block Set) A contact point that sends notifications to other Alertmanager instances. (see below for nested schema)\nA contact point that sends notifications to other Alertmanager instances.',
                                    items: {
                                      properties: {
                                        basicAuthPasswordSecretRef: {
                                          description: '(String, Sensitive) The password component of the basic auth credentials to use.\nThe password component of the basic auth credentials to use.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        basicAuthUser: {
                                          description: '(String) The username component of the basic auth credentials to use.\nThe username component of the basic auth credentials to use.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe URL of the Alertmanager instance.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  dingding: {
                                    description: '(Block Set) A contact point that sends notifications to DingDing. (see below for nested schema)\nA contact point that sends notifications to DingDing.',
                                    items: {
                                      properties: {
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated content of the message.',
                                          type: 'string',
                                        },
                                        messageType: {
                                          description: "either 'link' or 'actionCard'\nThe format of message to send - either 'link' or 'actionCard'",
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated title of the message.',
                                          type: 'string',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe DingDing webhook URL.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  disableProvenance: {
                                    description: 'Defaults to false. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  discord: {
                                    description: '(Block Set) A contact point that sends notifications as Discord messages (see below for nested schema)\nA contact point that sends notifications as Discord messages',
                                    items: {
                                      properties: {
                                        avatarUrl: {
                                          description: '(String) The URL of a custom avatar image to use. Defaults to “.\nThe URL of a custom avatar image to use. Defaults to “.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated content of the message. Defaults to “.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated content of the title.',
                                          type: 'string',
                                        },
                                        urlSecretRef: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe discord webhook URL.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        useDiscordUsername: {
                                          description: "(Boolean) Whether to use the bot account's plain username instead of \"Grafana.\" Defaults to false.\nWhether to use the bot account's plain username instead of \"Grafana.\" Defaults to `false`.",
                                          type: 'boolean',
                                        },
                                      },
                                      required: [
                                        'urlSecretRef',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  email: {
                                    description: '(Block Set) A contact point that sends notifications to an email address. (see below for nested schema)\nA contact point that sends notifications to an email address.',
                                    items: {
                                      properties: {
                                        addresses: {
                                          description: '(List of String) The addresses to send emails to.\nThe addresses to send emails to.',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated content of the email. Defaults to “.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        singleEmail: {
                                          description: "(Boolean) Whether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to false.\nWhether to send a single email CC'ing all addresses, rather than a separate email to each address. Defaults to `false`.",
                                          type: 'boolean',
                                        },
                                        subject: {
                                          description: '(String) The templated subject line of the email. Defaults to “.\nThe templated subject line of the email. Defaults to “.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  googlechat: {
                                    description: '(Block Set) A contact point that sends notifications to Google Chat. (see below for nested schema)\nA contact point that sends notifications to Google Chat.',
                                    items: {
                                      properties: {
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated content of the message.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated content of the title.',
                                          type: 'string',
                                        },
                                        urlSecretRef: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe Google Chat webhook URL.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'urlSecretRef',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  kafka: {
                                    description: '(Block Set) A contact point that publishes notifications to Apache Kafka topics. (see below for nested schema)\nA contact point that publishes notifications to Apache Kafka topics.',
                                    items: {
                                      properties: {
                                        apiVersion: {
                                          description: '(String) The API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to v2.\nThe API version to use when contacting the Kafka REST Server. Supported: v2 (default) and v3. Defaults to `v2`.',
                                          type: 'string',
                                        },
                                        clusterId: {
                                          description: "(String) The Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'\nThe Id of cluster to use when contacting the Kafka REST Server. Required api_version to be 'v3'",
                                          type: 'string',
                                        },
                                        description: {
                                          description: '(String) The templated description of the Kafka message.\nThe templated description of the Kafka message.',
                                          type: 'string',
                                        },
                                        details: {
                                          description: '(String) The templated details to include with the message.\nThe templated details to include with the message.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        passwordSecretRef: {
                                          description: '(String, Sensitive) The password to use when making a call to the Kafka REST Proxy\nThe password to use when making a call to the Kafka REST Proxy',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        restProxyUrlSecretRef: {
                                          description: '(String, Sensitive) The URL of the Kafka REST proxy to send requests to.\nThe URL of the Kafka REST proxy to send requests to.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        topic: {
                                          description: '(String) The name of the Kafka topic to publish to.\nThe name of the Kafka topic to publish to.',
                                          type: 'string',
                                        },
                                        username: {
                                          description: '(String) The user name to use when making a call to the Kafka REST Proxy\nThe user name to use when making a call to the Kafka REST Proxy',
                                          type: 'string',
                                        },
                                      },
                                      required: [
                                        'restProxyUrlSecretRef',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  line: {
                                    description: '(Block Set) A contact point that sends notifications to LINE.me. (see below for nested schema)\nA contact point that sends notifications to LINE.me.',
                                    items: {
                                      properties: {
                                        description: {
                                          description: '(String) The templated description of the Kafka message.\nThe templated description of the message.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated title of the message.',
                                          type: 'string',
                                        },
                                        tokenSecretRef: {
                                          description: '(String, Sensitive) The bearer token used to authorize the client.\nThe bearer token used to authorize the client.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'tokenSecretRef',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  name: {
                                    description: '(String) The name of the contact point.\nThe name of the contact point.',
                                    type: 'string',
                                  },
                                  oncall: {
                                    description: 'Call. (see below for nested schema)\nA contact point that sends notifications to Grafana On-Call.',
                                    items: {
                                      properties: {
                                        authorizationCredentialsSecretRef: {
                                          description: 'attaches an auth header with this value. Do not use in conjunction with basic auth parameters.\nAllows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        authorizationScheme: {
                                          description: 'attaches an auth header with this name. Do not use in conjunction with basic auth parameters.\nAllows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.',
                                          type: 'string',
                                        },
                                        basicAuthPasswordSecretRef: {
                                          description: '(String, Sensitive) The password component of the basic auth credentials to use.\nThe username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        basicAuthUser: {
                                          description: '(String) The username component of the basic auth credentials to use.\nThe username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        httpMethod: {
                                          description: '(String) The HTTP method to use in the request. Defaults to POST.\nThe HTTP method to use in the request. Defaults to `POST`.',
                                          type: 'string',
                                        },
                                        maxAlerts: {
                                          description: '(Number) The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.\nThe maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.',
                                          type: 'number',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nCustom message. You can use template variables.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nTemplated title of the message.',
                                          type: 'string',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe URL to send webhook requests to.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  opsgenie: {
                                    description: '(Block Set) A contact point that sends notifications to OpsGenie. (see below for nested schema)\nA contact point that sends notifications to OpsGenie.',
                                    items: {
                                      properties: {
                                        apiKeySecretRef: {
                                          description: '(String, Sensitive) The OpsGenie API key to use.\nThe OpsGenie API key to use.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        autoClose: {
                                          description: 'close alerts in OpsGenie when they resolve in the Alertmanager.\nWhether to auto-close alerts in OpsGenie when they resolve in the Alertmanager.',
                                          type: 'boolean',
                                        },
                                        description: {
                                          description: '(String) The templated description of the Kafka message.\nA templated high-level description to use for the alert.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated content of the message.',
                                          type: 'string',
                                        },
                                        overridePriority: {
                                          description: '(Boolean) Whether to allow the alert priority to be configured via the value of the og_priority annotation on the alert.\nWhether to allow the alert priority to be configured via the value of the `og_priority` annotation on the alert.',
                                          type: 'boolean',
                                        },
                                        responders: {
                                          description: '(Block List) Teams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+. (see below for nested schema)\nTeams, users, escalations and schedules that the alert will be routed to send notifications. If the API Key belongs to a team integration, this field will be overwritten with the owner team. This feature is available from Grafana 10.3+.',
                                          items: {
                                            properties: {
                                              id: {
                                                description: '(String) The ID of this resource.\nID of the responder. Must be specified if name and username are empty.',
                                                type: 'string',
                                              },
                                              name: {
                                                description: '(String) The name of the contact point.\nName of the responder. Must be specified if username and id are empty.',
                                                type: 'string',
                                              },
                                              type: {
                                                description: '(String) Type of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.\nType of the responder. Supported: team, teams, user, escalation, schedule or a template that is expanded to one of these values.',
                                                type: 'string',
                                              },
                                              username: {
                                                description: '(String) The user name to use when making a call to the Kafka REST Proxy\nUser name of the responder. Must be specified if name and id are empty.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        sendTagsAs: {
                                          description: '(String) Whether to send annotations to OpsGenie as Tags, Details, or both. Supported values are tags, details, both, or empty to use the default behavior of Tags.\nWhether to send annotations to OpsGenie as Tags, Details, or both. Supported values are `tags`, `details`, `both`, or empty to use the default behavior of Tags.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nAllows customization of the OpsGenie API URL.',
                                          type: 'string',
                                        },
                                      },
                                      required: [
                                        'apiKeySecretRef',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  pagerduty: {
                                    description: '(Block Set) A contact point that sends notifications to PagerDuty. (see below for nested schema)\nA contact point that sends notifications to PagerDuty.',
                                    items: {
                                      properties: {
                                        class: {
                                          description: '(String) The class or type of event, for example ping failure.\nThe class or type of event, for example `ping failure`.',
                                          type: 'string',
                                        },
                                        client: {
                                          description: '(String) The name of the monitoring client that is triggering this event.\nThe name of the monitoring client that is triggering this event.',
                                          type: 'string',
                                        },
                                        clientUrl: {
                                          description: '(String) The URL of the monitoring client that is triggering this event.\nThe URL of the monitoring client that is triggering this event.',
                                          type: 'string',
                                        },
                                        component: {
                                          description: '(String) The component being affected by the event.\nThe component being affected by the event.',
                                          type: 'string',
                                        },
                                        details: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          description: '(String) The templated details to include with the message.\nA set of arbitrary key/value pairs that provide further detail about the incident.',
                                          type: 'object',
                                          'x-kubernetes-map-type': 'granular',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        group: {
                                          description: '(String) The group to which the provided component belongs to.\nThe group to which the provided component belongs to.',
                                          type: 'string',
                                        },
                                        integrationKeySecretRef: {
                                          description: '(String, Sensitive) The PagerDuty API key.\nThe PagerDuty API key.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        severity: {
                                          description: '(String) The PagerDuty event severity level. Default is critical.\nThe PagerDuty event severity level. Default is `critical`.',
                                          type: 'string',
                                        },
                                        source: {
                                          description: '(String) The unique location of the affected system.\nThe unique location of the affected system.',
                                          type: 'string',
                                        },
                                        summary: {
                                          description: '(String) The templated summary message of the event.\nThe templated summary message of the event.',
                                          type: 'string',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe URL to send API requests to',
                                          type: 'string',
                                        },
                                      },
                                      required: [
                                        'integrationKeySecretRef',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  pushover: {
                                    description: '(Block Set) A contact point that sends notifications to Pushover. (see below for nested schema)\nA contact point that sends notifications to Pushover.',
                                    items: {
                                      properties: {
                                        apiTokenSecretRef: {
                                          description: '(String, Sensitive) The Pushover API token.\nThe Pushover API token.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        device: {
                                          description: 'separated list of devices to which the event is associated.\nComma-separated list of devices to which the event is associated.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        expire: {
                                          description: '(Number) How many seconds for which the notification will continue to be retried by Pushover.\nHow many seconds for which the notification will continue to be retried by Pushover.',
                                          type: 'number',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated notification message content.',
                                          type: 'string',
                                        },
                                        okPriority: {
                                          description: '(Number) The priority level of the resolved event.\nThe priority level of the resolved event.',
                                          type: 'number',
                                        },
                                        okSound: {
                                          description: '(String) The sound associated with the resolved notification.\nThe sound associated with the resolved notification.',
                                          type: 'string',
                                        },
                                        priority: {
                                          description: '(Number) The priority level of the event.\nThe priority level of the event.',
                                          type: 'number',
                                        },
                                        retry: {
                                          description: '(Number) How often, in seconds, the Pushover servers will send the same notification to the user.\nHow often, in seconds, the Pushover servers will send the same notification to the user.',
                                          type: 'number',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        sound: {
                                          description: '(String) The sound associated with the notification.\nThe sound associated with the notification.',
                                          type: 'string',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated title of the message.',
                                          type: 'string',
                                        },
                                        uploadImage: {
                                          description: '(Boolean) Whether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.\nWhether to send images in the notification or not. Default is true. Requires Grafana to be configured to send images in notifications.',
                                          type: 'boolean',
                                        },
                                        userKeySecretRef: {
                                          description: '(String, Sensitive) The Pushover user key.\nThe Pushover user key.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'apiTokenSecretRef',
                                        'userKeySecretRef',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  sensugo: {
                                    description: '(Block Set) A contact point that sends notifications to SensuGo. (see below for nested schema)\nA contact point that sends notifications to SensuGo.',
                                    items: {
                                      properties: {
                                        apiKeySecretRef: {
                                          description: '(String, Sensitive) The OpsGenie API key to use.\nThe SensuGo API key.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        check: {
                                          description: '(String) The SensuGo check to which the event should be routed.\nThe SensuGo check to which the event should be routed.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        entity: {
                                          description: '(String) The entity being monitored.\nThe entity being monitored.',
                                          type: 'string',
                                        },
                                        handler: {
                                          description: '(String) A custom handler to execute in addition to the check.\nA custom handler to execute in addition to the check.',
                                          type: 'string',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nTemplated message content describing the alert.',
                                          type: 'string',
                                        },
                                        namespace: {
                                          description: '(String) The namespace in which the check resides.\nThe namespace in which the check resides.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe SensuGo URL to send requests to.',
                                          type: 'string',
                                        },
                                      },
                                      required: [
                                        'apiKeySecretRef',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  slack: {
                                    description: '(Block Set) A contact point that sends notifications to Slack. (see below for nested schema)\nA contact point that sends notifications to Slack.',
                                    items: {
                                      properties: {
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        endpointUrl: {
                                          description: '(String) Use this to override the Slack API endpoint URL to send requests to.\nUse this to override the Slack API endpoint URL to send requests to.',
                                          type: 'string',
                                        },
                                        iconEmoji: {
                                          description: '(String) The name of a Slack workspace emoji to use as the bot icon.\nThe name of a Slack workspace emoji to use as the bot icon.',
                                          type: 'string',
                                        },
                                        iconUrl: {
                                          description: '(String) A URL of an image to use as the bot icon.\nA URL of an image to use as the bot icon.',
                                          type: 'string',
                                        },
                                        mentionChannel: {
                                          description: '(String) Describes how to ping the slack channel that messages are being sent to. Options are here for an @here ping, channel for @channel, or empty for no ping.\nDescribes how to ping the slack channel that messages are being sent to. Options are `here` for an @here ping, `channel` for @channel, or empty for no ping.',
                                          type: 'string',
                                        },
                                        mentionGroups: {
                                          description: 'separated list of groups to mention in the message.\nComma-separated list of groups to mention in the message.',
                                          type: 'string',
                                        },
                                        mentionUsers: {
                                          description: 'separated list of users to mention in the message.\nComma-separated list of users to mention in the message.',
                                          type: 'string',
                                        },
                                        recipient: {
                                          description: '(String) Channel, private group, or IM channel (can be an encoded ID or a name) to send messages to.\nChannel, private group, or IM channel (can be an encoded ID or a name) to send messages to.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        text: {
                                          description: '(String) Templated content of the message.\nTemplated content of the message.',
                                          type: 'string',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nTemplated title of the message.',
                                          type: 'string',
                                        },
                                        tokenSecretRef: {
                                          description: '(String, Sensitive) The bearer token used to authorize the client.\nA Slack API token,for sending messages directly without the webhook method.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        urlSecretRef: {
                                          description: '(String) The URL of the Alertmanager instance.\nA Slack webhook URL,for sending messages via the webhook method.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        username: {
                                          description: '(String) The user name to use when making a call to the Kafka REST Proxy\nUsername for the bot to use.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  sns: {
                                    description: '(Block Set) A contact point that sends notifications to Amazon SNS. Requires Amazon Managed Grafana. (see below for nested schema)\nA contact point that sends notifications to Amazon SNS. Requires Amazon Managed Grafana.',
                                    items: {
                                      properties: {
                                        accessKeySecretRef: {
                                          description: '(String, Sensitive) AWS access key ID used to authenticate with Amazon SNS.\nAWS access key ID used to authenticate with Amazon SNS.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        assumeRoleArn: {
                                          description: '(String) The Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.\nThe Amazon Resource Name (ARN) of the role to assume to send notifications to Amazon SNS.',
                                          type: 'string',
                                        },
                                        authProvider: {
                                          description: '(String) The authentication provider to use. Valid values are default, arn and keys. Default is default. Defaults to default.\nThe authentication provider to use. Valid values are `default`, `arn` and `keys`. Default is `default`. Defaults to `default`.',
                                          type: 'string',
                                        },
                                        body: {
                                          description: '(String)',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        externalId: {
                                          description: '(String) The external ID to use when assuming the role.\nThe external ID to use when assuming the role.',
                                          type: 'string',
                                        },
                                        messageFormat: {
                                          description: '(String) The format of the message to send. Valid values are text, body and json. Default is text. Defaults to text.\nThe format of the message to send. Valid values are `text`, `body` and `json`. Default is `text`. Defaults to `text`.',
                                          type: 'string',
                                        },
                                        secretKeySecretRef: {
                                          description: '(String, Sensitive) AWS secret access key used to authenticate with Amazon SNS.\nAWS secret access key used to authenticate with Amazon SNS.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        subject: {
                                          description: '(String) The templated subject line of the email. Defaults to “.',
                                          type: 'string',
                                        },
                                        topic: {
                                          description: '(String) The name of the Kafka topic to publish to.\nThe Amazon SNS topic to send notifications to.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  teams: {
                                    description: '(Block Set) A contact point that sends notifications to Microsoft Teams. (see below for nested schema)\nA contact point that sends notifications to Microsoft Teams.',
                                    items: {
                                      properties: {
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated message content to send.',
                                          type: 'string',
                                        },
                                        sectionTitle: {
                                          description: '(String) The templated subtitle for each message section.\nThe templated subtitle for each message section.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated title of the message.',
                                          type: 'string',
                                        },
                                        urlSecretRef: {
                                          description: '(String) The URL of the Alertmanager instance.\nA Teams webhook URL.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'urlSecretRef',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  telegram: {
                                    description: '(Block Set) A contact point that sends notifications to Telegram. (see below for nested schema)\nA contact point that sends notifications to Telegram.',
                                    items: {
                                      properties: {
                                        chatId: {
                                          description: '(String) The chat ID to send messages to.\nThe chat ID to send messages to.',
                                          type: 'string',
                                        },
                                        disableNotifications: {
                                          description: '(Boolean) When set users will receive a notification with no sound.\nWhen set users will receive a notification with no sound.',
                                          type: 'boolean',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        disableWebPagePreview: {
                                          description: '(Boolean) When set it disables link previews for links in the message.\nWhen set it disables link previews for links in the message.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated content of the message.',
                                          type: 'string',
                                        },
                                        messageThreadId: {
                                          description: '(String) The ID of the message thread to send the message to.\nThe ID of the message thread to send the message to.',
                                          type: 'string',
                                        },
                                        parseMode: {
                                          description: '(String) Mode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.\nMode for parsing entities in the message text. Supported: None, Markdown, MarkdownV2, and HTML. HTML is the default.',
                                          type: 'string',
                                        },
                                        protectContent: {
                                          description: '(Boolean) When set it protects the contents of the message from forwarding and saving.\nWhen set it protects the contents of the message from forwarding and saving.',
                                          type: 'boolean',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        tokenSecretRef: {
                                          description: '(String, Sensitive) The bearer token used to authorize the client.\nThe Telegram bot token.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'tokenSecretRef',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  threema: {
                                    description: '(Block Set) A contact point that sends notifications to Threema. (see below for nested schema)\nA contact point that sends notifications to Threema.',
                                    items: {
                                      properties: {
                                        apiSecretSecretRef: {
                                          description: '(String, Sensitive) The Threema API key.\nThe Threema API key.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        description: {
                                          description: '(String) The templated description of the Kafka message.\nThe templated description of the message.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        gatewayId: {
                                          description: '(String) The Threema gateway ID.\nThe Threema gateway ID.',
                                          type: 'string',
                                        },
                                        recipientId: {
                                          description: '(String) The ID of the recipient of the message.\nThe ID of the recipient of the message.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated title of the message.',
                                          type: 'string',
                                        },
                                      },
                                      required: [
                                        'apiSecretSecretRef',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  victorops: {
                                    description: '(Block Set) A contact point that sends notifications to VictorOps (now known as Splunk OnCall). (see below for nested schema)\nA contact point that sends notifications to VictorOps (now known as Splunk OnCall).',
                                    items: {
                                      properties: {
                                        description: {
                                          description: '(String) The templated description of the Kafka message.\nTemplated description of the message.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        messageType: {
                                          description: "either 'link' or 'actionCard'\nThe VictorOps alert state - typically either `CRITICAL` or `RECOVERY`.",
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nTemplated title to display.',
                                          type: 'string',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe VictorOps webhook URL.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  webex: {
                                    description: '(Block Set) A contact point that sends notifications to Cisco Webex. (see below for nested schema)\nA contact point that sends notifications to Cisco Webex.',
                                    items: {
                                      properties: {
                                        apiUrl: {
                                          description: '(String) The URL to send webhook requests to.\nThe URL to send webhook requests to.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated title of the message to send.',
                                          type: 'string',
                                        },
                                        roomId: {
                                          description: '(String) ID of the Webex Teams room where to send the messages.\nID of the Webex Teams room where to send the messages.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        tokenSecretRef: {
                                          description: '(String, Sensitive) The bearer token used to authorize the client.\nThe bearer token used to authorize the client.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  webhook: {
                                    description: '(Block Set) A contact point that sends notifications to an arbitrary webhook, using the Prometheus webhook format defined here: https://prometheus.io/docs/alerting/latest/configuration/#webhook_config (see below for nested schema)\nA contact point that sends notifications to an arbitrary webhook, using the Prometheus webhook format defined here: https://prometheus.io/docs/alerting/latest/configuration/#webhook_config',
                                    items: {
                                      properties: {
                                        authorizationCredentialsSecretRef: {
                                          description: 'attaches an auth header with this value. Do not use in conjunction with basic auth parameters.\nAllows a custom authorization scheme - attaches an auth header with this value. Do not use in conjunction with basic auth parameters.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        authorizationScheme: {
                                          description: 'attaches an auth header with this name. Do not use in conjunction with basic auth parameters.\nAllows a custom authorization scheme - attaches an auth header with this name. Do not use in conjunction with basic auth parameters.',
                                          type: 'string',
                                        },
                                        basicAuthPasswordSecretRef: {
                                          description: '(String, Sensitive) The password component of the basic auth credentials to use.\nThe username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        basicAuthUser: {
                                          description: '(String) The username component of the basic auth credentials to use.\nThe username to use in basic auth headers attached to the request. If omitted, basic auth will not be used.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        httpMethod: {
                                          description: '(String) The HTTP method to use in the request. Defaults to POST.\nThe HTTP method to use in the request. Defaults to `POST`.',
                                          type: 'string',
                                        },
                                        maxAlerts: {
                                          description: '(Number) The maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.\nThe maximum number of alerts to send in a single request. This can be helpful in limiting the size of the request body. The default is 0, which indicates no limit.',
                                          type: 'number',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nCustom message. You can use template variables.',
                                          type: 'string',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nTemplated title of the message.',
                                          type: 'string',
                                        },
                                        url: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe URL to send webhook requests to.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  wecom: {
                                    description: '(Block Set) A contact point that sends notifications to WeCom. (see below for nested schema)\nA contact point that sends notifications to WeCom.',
                                    items: {
                                      properties: {
                                        agentId: {
                                          description: '(String) Agent ID added to the request payload when using APIAPP.\nAgent ID added to the request payload when using APIAPP.',
                                          type: 'string',
                                        },
                                        corpId: {
                                          description: '(String) Corp ID used to get token when using APIAPP.\nCorp ID used to get token when using APIAPP.',
                                          type: 'string',
                                        },
                                        disableResolveMessage: {
                                          description: '(Boolean) Whether to disable sending resolve messages. Defaults to false.\nWhether to disable sending resolve messages. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        message: {
                                          description: '(String) The templated content of the message.\nThe templated content of the message to send.',
                                          type: 'string',
                                        },
                                        msgType: {
                                          description: '(String) The type of them message. Supported: markdown, text. Default: text.\nThe type of them message. Supported: markdown, text. Default: text.',
                                          type: 'string',
                                        },
                                        secretSecretRef: {
                                          description: '(String, Sensitive) The secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.\nThe secret key required to obtain access token when using APIAPP. See https://work.weixin.qq.com/wework_admin/frame#apps to create APIAPP.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        settingsSecretRef: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          type: 'object',
                                        },
                                        title: {
                                          description: '(String) The templated title of the message.\nThe templated title of the message to send.',
                                          type: 'string',
                                        },
                                        toUser: {
                                          description: "(String) The ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.\nThe ID of user that should receive the message. Multiple entries should be separated by '|'. Default: @all.",
                                          type: 'string',
                                        },
                                        urlSecretRef: {
                                          description: '(String) The URL of the Alertmanager instance.\nThe WeCom webhook URL. Required if using GroupRobot.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      messageTemplate: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xmessagetemplates.alerting.grafana.crossplane.io.namespaced',
            },
            name: 'messagetemplate-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'alerting.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XMessageTemplate',
            },
            resources: [
              {
                base: {
                  apiVersion: 'alerting.grafana.crossplane.io/v1alpha1',
                  kind: 'MessageTemplate',
                },
                name: 'messagetemplate',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.disableProvenance',
                    toFieldPath: 'spec.forProvider.disableProvenance',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.template',
                    toFieldPath: 'spec.forProvider.template',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.disableProvenance',
                    toFieldPath: 'spec.initProvider.disableProvenance',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.template',
                    toFieldPath: 'spec.initProvider.template',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xmessagetemplates.alerting.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'MessageTemplate',
              plural: 'messagetemplates',
            },
            defaultCompositionRef: {
              name: 'messagetemplate-namespaced',
            },
            group: 'alerting.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XMessageTemplate',
              plural: 'xmessagetemplates',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'MessageTemplateSpec defines the desired state of MessageTemplate',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  disableProvenance: {
                                    description: 'Defaults to false. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  name: {
                                    description: '(String) The name of the message template.\nThe name of the message template.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  template: {
                                    description: '(String) The content of the message template.\nThe content of the message template.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  disableProvenance: {
                                    description: 'Defaults to false. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  name: {
                                    description: '(String) The name of the message template.\nThe name of the message template.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  template: {
                                    description: '(String) The content of the message template.\nThe content of the message template.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.template is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.template) || (has(self.initProvider) && has(self.initProvider.template))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      muteTiming: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xmutetimings.alerting.grafana.crossplane.io.namespaced',
            },
            name: 'mutetiming-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'alerting.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XMuteTiming',
            },
            resources: [
              {
                base: {
                  apiVersion: 'alerting.grafana.crossplane.io/v1alpha1',
                  kind: 'MuteTiming',
                },
                name: 'mutetiming',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.disableProvenance',
                    toFieldPath: 'spec.forProvider.disableProvenance',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.intervals',
                    toFieldPath: 'spec.forProvider.intervals',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.disableProvenance',
                    toFieldPath: 'spec.initProvider.disableProvenance',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.intervals',
                    toFieldPath: 'spec.initProvider.intervals',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xmutetimings.alerting.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'MuteTiming',
              plural: 'mutetimings',
            },
            defaultCompositionRef: {
              name: 'mutetiming-namespaced',
            },
            group: 'alerting.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XMuteTiming',
              plural: 'xmutetimings',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'MuteTimingSpec defines the desired state of MuteTiming',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  disableProvenance: {
                                    description: 'Defaults to false. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  intervals: {
                                    description: '(Block List) The time intervals at which to mute notifications. Use an empty block to mute all the time. (see below for nested schema)\nThe time intervals at which to mute notifications. Use an empty block to mute all the time.',
                                    items: {
                                      properties: {
                                        daysOfMonth: {
                                          description: '31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".\nAn inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                        },
                                        location: {
                                          description: '(String) Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"\nProvides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"',
                                          type: 'string',
                                        },
                                        months: {
                                          description: '(List of String) An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".\nAn inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                        },
                                        times: {
                                          description: '(Block List) The time ranges, represented in minutes, during which to mute in a given day. (see below for nested schema)\nThe time ranges, represented in minutes, during which to mute in a given day.',
                                          items: {
                                            properties: {
                                              end: {
                                                description: '(String) The time, in hh:mm format, of when the interval should end exclusively.\nThe time, in hh:mm format, of when the interval should end exclusively.',
                                                type: 'string',
                                              },
                                              start: {
                                                description: '(String) The time, in hh:mm format, of when the interval should begin inclusively.\nThe time, in hh:mm format, of when the interval should begin inclusively.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        weekdays: {
                                          description: '(List of String) An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".\nAn inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                        },
                                        years: {
                                          description: '(List of String) A positive inclusive range of years, e.g. "2030" or "2025:2026".\nA positive inclusive range of years, e.g. "2030" or "2025:2026".',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  name: {
                                    description: '(String) The name of the mute timing.\nThe name of the mute timing.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  disableProvenance: {
                                    description: 'Defaults to false. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  intervals: {
                                    description: '(Block List) The time intervals at which to mute notifications. Use an empty block to mute all the time. (see below for nested schema)\nThe time intervals at which to mute notifications. Use an empty block to mute all the time.',
                                    items: {
                                      properties: {
                                        daysOfMonth: {
                                          description: '31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".\nAn inclusive range of days, 1-31, within a month, e.g. "1" or "14:16". Negative values can be used to represent days counting from the end of a month, e.g. "-1".',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                        },
                                        location: {
                                          description: '(String) Provides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"\nProvides the time zone for the time interval. Must be a location in the IANA time zone database, e.g "America/New_York"',
                                          type: 'string',
                                        },
                                        months: {
                                          description: '(List of String) An inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".\nAn inclusive range of months, either numerical or full calendar month, e.g. "1:3", "december", or "may:august".',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                        },
                                        times: {
                                          description: '(Block List) The time ranges, represented in minutes, during which to mute in a given day. (see below for nested schema)\nThe time ranges, represented in minutes, during which to mute in a given day.',
                                          items: {
                                            properties: {
                                              end: {
                                                description: '(String) The time, in hh:mm format, of when the interval should end exclusively.\nThe time, in hh:mm format, of when the interval should end exclusively.',
                                                type: 'string',
                                              },
                                              start: {
                                                description: '(String) The time, in hh:mm format, of when the interval should begin inclusively.\nThe time, in hh:mm format, of when the interval should begin inclusively.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        weekdays: {
                                          description: '(List of String) An inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".\nAn inclusive range of weekdays, e.g. "monday" or "tuesday:thursday".',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                        },
                                        years: {
                                          description: '(List of String) A positive inclusive range of years, e.g. "2030" or "2025:2026".\nA positive inclusive range of years, e.g. "2030" or "2025:2026".',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  name: {
                                    description: '(String) The name of the mute timing.\nThe name of the mute timing.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      notificationPolicy: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xnotificationpolicies.alerting.grafana.crossplane.io.namespaced',
            },
            name: 'notificationpolicy-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'alerting.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XNotificationPolicy',
            },
            resources: [
              {
                base: {
                  apiVersion: 'alerting.grafana.crossplane.io/v1alpha1',
                  kind: 'NotificationPolicy',
                },
                name: 'notificationpolicy',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.contactPoint',
                    toFieldPath: 'spec.forProvider.contactPoint',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.contactPointRef.name',
                    toFieldPath: 'spec.forProvider.contactPointRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.contactPointRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.contactPointRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.contactPointRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.contactPointRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.contactPointSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.contactPointSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.contactPointSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.contactPointSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.contactPointSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.contactPointSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.contactPointSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.contactPointSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.disableProvenance',
                    toFieldPath: 'spec.forProvider.disableProvenance',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.groupBy',
                    toFieldPath: 'spec.forProvider.groupBy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.groupInterval',
                    toFieldPath: 'spec.forProvider.groupInterval',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.groupWait',
                    toFieldPath: 'spec.forProvider.groupWait',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.policy',
                    toFieldPath: 'spec.forProvider.policy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.repeatInterval',
                    toFieldPath: 'spec.forProvider.repeatInterval',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.contactPoint',
                    toFieldPath: 'spec.initProvider.contactPoint',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.contactPointRef.name',
                    toFieldPath: 'spec.initProvider.contactPointRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.contactPointRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.contactPointRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.contactPointRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.contactPointRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.contactPointSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.contactPointSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.contactPointSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.contactPointSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.contactPointSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.contactPointSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.contactPointSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.contactPointSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.disableProvenance',
                    toFieldPath: 'spec.initProvider.disableProvenance',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.groupBy',
                    toFieldPath: 'spec.initProvider.groupBy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.groupInterval',
                    toFieldPath: 'spec.initProvider.groupInterval',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.groupWait',
                    toFieldPath: 'spec.initProvider.groupWait',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.policy',
                    toFieldPath: 'spec.initProvider.policy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.repeatInterval',
                    toFieldPath: 'spec.initProvider.repeatInterval',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xnotificationpolicies.alerting.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'NotificationPolicy',
              plural: 'notificationpolicies',
            },
            defaultCompositionRef: {
              name: 'notificationpolicy-namespaced',
            },
            group: 'alerting.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XNotificationPolicy',
              plural: 'xnotificationpolicies',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'NotificationPolicySpec defines the desired state of NotificationPolicy',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  contactPoint: {
                                    description: '(String) The default contact point to route all unmatched notifications to.\nThe default contact point to route all unmatched notifications to.',
                                    type: 'string',
                                  },
                                  contactPointRef: {
                                    description: 'Reference to a ContactPoint in alerting to populate contactPoint.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  contactPointSelector: {
                                    description: 'Selector for a ContactPoint in alerting to populate contactPoint.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  disableProvenance: {
                                    description: 'Defaults to false. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  groupBy: {
                                    description: '(List of String) A list of alert labels to group alerts into notifications by. Use the special label ... to group alerts by all labels, effectively disabling grouping.\nA list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                  },
                                  groupInterval: {
                                    description: '(String) Minimum time interval between two notifications for the same group. Default is 5 minutes.\nMinimum time interval between two notifications for the same group. Default is 5 minutes.',
                                    type: 'string',
                                  },
                                  groupWait: {
                                    description: '(String) Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.\nTime to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  policy: {
                                    description: '(Block List) Routing rules for specific label sets. (see below for nested schema)\nRouting rules for specific label sets.',
                                    items: {
                                      properties: {
                                        contactPoint: {
                                          description: '(String) The default contact point to route all unmatched notifications to.\nThe contact point to route notifications that match this rule to.',
                                          type: 'string',
                                        },
                                        contactPointRef: {
                                          description: 'Reference to a ContactPoint in alerting to populate contactPoint.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        contactPointSelector: {
                                          description: 'Selector for a ContactPoint in alerting to populate contactPoint.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        continue: {
                                          description: "(Boolean) Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.\nWhether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.",
                                          type: 'boolean',
                                        },
                                        groupBy: {
                                          description: '(List of String) A list of alert labels to group alerts into notifications by. Use the special label ... to group alerts by all labels, effectively disabling grouping.\nA list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                        },
                                        groupInterval: {
                                          description: '(String) Minimum time interval between two notifications for the same group. Default is 5 minutes.\nMinimum time interval between two notifications for the same group. Default is 5 minutes.',
                                          type: 'string',
                                        },
                                        groupWait: {
                                          description: '(String) Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.\nTime to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.',
                                          type: 'string',
                                        },
                                        matcher: {
                                          description: '(Block Set) Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances. (see below for nested schema)\nDescribes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.',
                                          items: {
                                            properties: {
                                              label: {
                                                description: '(String) The name of the label to match against.\nThe name of the label to match against.',
                                                type: 'string',
                                              },
                                              match: {
                                                description: '(String) The operator to apply when matching values of the given label. Allowed operators are = for equality, != for negated equality, =~ for regex equality, and !~ for negated regex equality.\nThe operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.',
                                                type: 'string',
                                              },
                                              value: {
                                                description: '(String) The label value to match against.\nThe label value to match against.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        muteTimingRef: {
                                          description: 'References to MuteTiming in alerting to populate muteTimings.',
                                          items: {
                                            description: 'A Reference to a named object.',
                                            properties: {
                                              name: {
                                                description: 'Name of the referenced object.',
                                                type: 'string',
                                              },
                                              policy: {
                                                description: 'Policies for referencing.',
                                                properties: {
                                                  resolution: {
                                                    default: 'Required',
                                                    description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                    enum: [
                                                      'Required',
                                                      'Optional',
                                                    ],
                                                    type: 'string',
                                                  },
                                                  resolve: {
                                                    description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                    enum: [
                                                      'Always',
                                                      'IfNotPresent',
                                                    ],
                                                    type: 'string',
                                                  },
                                                },
                                                type: 'object',
                                              },
                                            },
                                            required: [
                                              'name',
                                            ],
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        muteTimingSelector: {
                                          description: 'Selector for a list of MuteTiming in alerting to populate muteTimings.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        muteTimings: {
                                          description: '(List of String) A list of mute timing names to apply to alerts that match this policy.\nA list of mute timing names to apply to alerts that match this policy.',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                        },
                                        policy: {
                                          description: '(Block List) Routing rules for specific label sets. (see below for nested schema)\nRouting rules for specific label sets.',
                                          items: {
                                            properties: {
                                              contactPoint: {
                                                description: '(String) The default contact point to route all unmatched notifications to.\nThe contact point to route notifications that match this rule to.',
                                                type: 'string',
                                              },
                                              contactPointRef: {
                                                description: 'Reference to a ContactPoint in alerting to populate contactPoint.',
                                                properties: {
                                                  name: {
                                                    description: 'Name of the referenced object.',
                                                    type: 'string',
                                                  },
                                                  policy: {
                                                    description: 'Policies for referencing.',
                                                    properties: {
                                                      resolution: {
                                                        default: 'Required',
                                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                        enum: [
                                                          'Required',
                                                          'Optional',
                                                        ],
                                                        type: 'string',
                                                      },
                                                      resolve: {
                                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                        enum: [
                                                          'Always',
                                                          'IfNotPresent',
                                                        ],
                                                        type: 'string',
                                                      },
                                                    },
                                                    type: 'object',
                                                  },
                                                },
                                                required: [
                                                  'name',
                                                ],
                                                type: 'object',
                                              },
                                              contactPointSelector: {
                                                description: 'Selector for a ContactPoint in alerting to populate contactPoint.',
                                                properties: {
                                                  matchControllerRef: {
                                                    description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                                    type: 'boolean',
                                                  },
                                                  matchLabels: {
                                                    additionalProperties: {
                                                      type: 'string',
                                                    },
                                                    description: 'MatchLabels ensures an object with matching labels is selected.',
                                                    type: 'object',
                                                  },
                                                  policy: {
                                                    description: 'Policies for selection.',
                                                    properties: {
                                                      resolution: {
                                                        default: 'Required',
                                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                        enum: [
                                                          'Required',
                                                          'Optional',
                                                        ],
                                                        type: 'string',
                                                      },
                                                      resolve: {
                                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                        enum: [
                                                          'Always',
                                                          'IfNotPresent',
                                                        ],
                                                        type: 'string',
                                                      },
                                                    },
                                                    type: 'object',
                                                  },
                                                },
                                                type: 'object',
                                              },
                                              continue: {
                                                description: "(Boolean) Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.\nWhether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.",
                                                type: 'boolean',
                                              },
                                              groupBy: {
                                                description: '(List of String) A list of alert labels to group alerts into notifications by. Use the special label ... to group alerts by all labels, effectively disabling grouping.\nA list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                              },
                                              groupInterval: {
                                                description: '(String) Minimum time interval between two notifications for the same group. Default is 5 minutes.\nMinimum time interval between two notifications for the same group. Default is 5 minutes.',
                                                type: 'string',
                                              },
                                              groupWait: {
                                                description: '(String) Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.\nTime to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.',
                                                type: 'string',
                                              },
                                              matcher: {
                                                description: '(Block Set) Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances. (see below for nested schema)\nDescribes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.',
                                                items: {
                                                  properties: {
                                                    label: {
                                                      description: '(String) The name of the label to match against.\nThe name of the label to match against.',
                                                      type: 'string',
                                                    },
                                                    match: {
                                                      description: '(String) The operator to apply when matching values of the given label. Allowed operators are = for equality, != for negated equality, =~ for regex equality, and !~ for negated regex equality.\nThe operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.',
                                                      type: 'string',
                                                    },
                                                    value: {
                                                      description: '(String) The label value to match against.\nThe label value to match against.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              muteTimingRef: {
                                                description: 'References to MuteTiming in alerting to populate muteTimings.',
                                                items: {
                                                  description: 'A Reference to a named object.',
                                                  properties: {
                                                    name: {
                                                      description: 'Name of the referenced object.',
                                                      type: 'string',
                                                    },
                                                    policy: {
                                                      description: 'Policies for referencing.',
                                                      properties: {
                                                        resolution: {
                                                          default: 'Required',
                                                          description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                          enum: [
                                                            'Required',
                                                            'Optional',
                                                          ],
                                                          type: 'string',
                                                        },
                                                        resolve: {
                                                          description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                          enum: [
                                                            'Always',
                                                            'IfNotPresent',
                                                          ],
                                                          type: 'string',
                                                        },
                                                      },
                                                      type: 'object',
                                                    },
                                                  },
                                                  required: [
                                                    'name',
                                                  ],
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              muteTimingSelector: {
                                                description: 'Selector for a list of MuteTiming in alerting to populate muteTimings.',
                                                properties: {
                                                  matchControllerRef: {
                                                    description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                                    type: 'boolean',
                                                  },
                                                  matchLabels: {
                                                    additionalProperties: {
                                                      type: 'string',
                                                    },
                                                    description: 'MatchLabels ensures an object with matching labels is selected.',
                                                    type: 'object',
                                                  },
                                                  policy: {
                                                    description: 'Policies for selection.',
                                                    properties: {
                                                      resolution: {
                                                        default: 'Required',
                                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                        enum: [
                                                          'Required',
                                                          'Optional',
                                                        ],
                                                        type: 'string',
                                                      },
                                                      resolve: {
                                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                        enum: [
                                                          'Always',
                                                          'IfNotPresent',
                                                        ],
                                                        type: 'string',
                                                      },
                                                    },
                                                    type: 'object',
                                                  },
                                                },
                                                type: 'object',
                                              },
                                              muteTimings: {
                                                description: '(List of String) A list of mute timing names to apply to alerts that match this policy.\nA list of mute timing names to apply to alerts that match this policy.',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                              },
                                              policy: {
                                                description: '(Block List) Routing rules for specific label sets. (see below for nested schema)\nRouting rules for specific label sets.',
                                                items: {
                                                  properties: {
                                                    contactPoint: {
                                                      description: '(String) The default contact point to route all unmatched notifications to.\nThe contact point to route notifications that match this rule to.',
                                                      type: 'string',
                                                    },
                                                    contactPointRef: {
                                                      description: 'Reference to a ContactPoint in alerting to populate contactPoint.',
                                                      properties: {
                                                        name: {
                                                          description: 'Name of the referenced object.',
                                                          type: 'string',
                                                        },
                                                        policy: {
                                                          description: 'Policies for referencing.',
                                                          properties: {
                                                            resolution: {
                                                              default: 'Required',
                                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                              enum: [
                                                                'Required',
                                                                'Optional',
                                                              ],
                                                              type: 'string',
                                                            },
                                                            resolve: {
                                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                              enum: [
                                                                'Always',
                                                                'IfNotPresent',
                                                              ],
                                                              type: 'string',
                                                            },
                                                          },
                                                          type: 'object',
                                                        },
                                                      },
                                                      required: [
                                                        'name',
                                                      ],
                                                      type: 'object',
                                                    },
                                                    contactPointSelector: {
                                                      description: 'Selector for a ContactPoint in alerting to populate contactPoint.',
                                                      properties: {
                                                        matchControllerRef: {
                                                          description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                                          type: 'boolean',
                                                        },
                                                        matchLabels: {
                                                          additionalProperties: {
                                                            type: 'string',
                                                          },
                                                          description: 'MatchLabels ensures an object with matching labels is selected.',
                                                          type: 'object',
                                                        },
                                                        policy: {
                                                          description: 'Policies for selection.',
                                                          properties: {
                                                            resolution: {
                                                              default: 'Required',
                                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                              enum: [
                                                                'Required',
                                                                'Optional',
                                                              ],
                                                              type: 'string',
                                                            },
                                                            resolve: {
                                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                              enum: [
                                                                'Always',
                                                                'IfNotPresent',
                                                              ],
                                                              type: 'string',
                                                            },
                                                          },
                                                          type: 'object',
                                                        },
                                                      },
                                                      type: 'object',
                                                    },
                                                    continue: {
                                                      description: "(Boolean) Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.\nWhether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.",
                                                      type: 'boolean',
                                                    },
                                                    groupBy: {
                                                      description: '(List of String) A list of alert labels to group alerts into notifications by. Use the special label ... to group alerts by all labels, effectively disabling grouping.\nA list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                    },
                                                    groupInterval: {
                                                      description: '(String) Minimum time interval between two notifications for the same group. Default is 5 minutes.\nMinimum time interval between two notifications for the same group. Default is 5 minutes.',
                                                      type: 'string',
                                                    },
                                                    groupWait: {
                                                      description: '(String) Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.\nTime to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.',
                                                      type: 'string',
                                                    },
                                                    matcher: {
                                                      description: '(Block Set) Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances. (see below for nested schema)\nDescribes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.',
                                                      items: {
                                                        properties: {
                                                          label: {
                                                            description: '(String) The name of the label to match against.\nThe name of the label to match against.',
                                                            type: 'string',
                                                          },
                                                          match: {
                                                            description: '(String) The operator to apply when matching values of the given label. Allowed operators are = for equality, != for negated equality, =~ for regex equality, and !~ for negated regex equality.\nThe operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.',
                                                            type: 'string',
                                                          },
                                                          value: {
                                                            description: '(String) The label value to match against.\nThe label value to match against.',
                                                            type: 'string',
                                                          },
                                                        },
                                                        type: 'object',
                                                      },
                                                      type: 'array',
                                                    },
                                                    muteTimingRef: {
                                                      description: 'References to MuteTiming in alerting to populate muteTimings.',
                                                      items: {
                                                        description: 'A Reference to a named object.',
                                                        properties: {
                                                          name: {
                                                            description: 'Name of the referenced object.',
                                                            type: 'string',
                                                          },
                                                          policy: {
                                                            description: 'Policies for referencing.',
                                                            properties: {
                                                              resolution: {
                                                                default: 'Required',
                                                                description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                                enum: [
                                                                  'Required',
                                                                  'Optional',
                                                                ],
                                                                type: 'string',
                                                              },
                                                              resolve: {
                                                                description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                                enum: [
                                                                  'Always',
                                                                  'IfNotPresent',
                                                                ],
                                                                type: 'string',
                                                              },
                                                            },
                                                            type: 'object',
                                                          },
                                                        },
                                                        required: [
                                                          'name',
                                                        ],
                                                        type: 'object',
                                                      },
                                                      type: 'array',
                                                    },
                                                    muteTimingSelector: {
                                                      description: 'Selector for a list of MuteTiming in alerting to populate muteTimings.',
                                                      properties: {
                                                        matchControllerRef: {
                                                          description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                                          type: 'boolean',
                                                        },
                                                        matchLabels: {
                                                          additionalProperties: {
                                                            type: 'string',
                                                          },
                                                          description: 'MatchLabels ensures an object with matching labels is selected.',
                                                          type: 'object',
                                                        },
                                                        policy: {
                                                          description: 'Policies for selection.',
                                                          properties: {
                                                            resolution: {
                                                              default: 'Required',
                                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                              enum: [
                                                                'Required',
                                                                'Optional',
                                                              ],
                                                              type: 'string',
                                                            },
                                                            resolve: {
                                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                              enum: [
                                                                'Always',
                                                                'IfNotPresent',
                                                              ],
                                                              type: 'string',
                                                            },
                                                          },
                                                          type: 'object',
                                                        },
                                                      },
                                                      type: 'object',
                                                    },
                                                    muteTimings: {
                                                      description: '(List of String) A list of mute timing names to apply to alerts that match this policy.\nA list of mute timing names to apply to alerts that match this policy.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                    },
                                                    policy: {
                                                      description: '(Block List) Routing rules for specific label sets. (see below for nested schema)\nRouting rules for specific label sets.',
                                                      items: {
                                                        properties: {
                                                          contactPoint: {
                                                            description: '(String) The default contact point to route all unmatched notifications to.\nThe contact point to route notifications that match this rule to.',
                                                            type: 'string',
                                                          },
                                                          contactPointRef: {
                                                            description: 'Reference to a ContactPoint in alerting to populate contactPoint.',
                                                            properties: {
                                                              name: {
                                                                description: 'Name of the referenced object.',
                                                                type: 'string',
                                                              },
                                                              policy: {
                                                                description: 'Policies for referencing.',
                                                                properties: {
                                                                  resolution: {
                                                                    default: 'Required',
                                                                    description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                                    enum: [
                                                                      'Required',
                                                                      'Optional',
                                                                    ],
                                                                    type: 'string',
                                                                  },
                                                                  resolve: {
                                                                    description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                                    enum: [
                                                                      'Always',
                                                                      'IfNotPresent',
                                                                    ],
                                                                    type: 'string',
                                                                  },
                                                                },
                                                                type: 'object',
                                                              },
                                                            },
                                                            required: [
                                                              'name',
                                                            ],
                                                            type: 'object',
                                                          },
                                                          contactPointSelector: {
                                                            description: 'Selector for a ContactPoint in alerting to populate contactPoint.',
                                                            properties: {
                                                              matchControllerRef: {
                                                                description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                                                type: 'boolean',
                                                              },
                                                              matchLabels: {
                                                                additionalProperties: {
                                                                  type: 'string',
                                                                },
                                                                description: 'MatchLabels ensures an object with matching labels is selected.',
                                                                type: 'object',
                                                              },
                                                              policy: {
                                                                description: 'Policies for selection.',
                                                                properties: {
                                                                  resolution: {
                                                                    default: 'Required',
                                                                    description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                                    enum: [
                                                                      'Required',
                                                                      'Optional',
                                                                    ],
                                                                    type: 'string',
                                                                  },
                                                                  resolve: {
                                                                    description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                                    enum: [
                                                                      'Always',
                                                                      'IfNotPresent',
                                                                    ],
                                                                    type: 'string',
                                                                  },
                                                                },
                                                                type: 'object',
                                                              },
                                                            },
                                                            type: 'object',
                                                          },
                                                          continue: {
                                                            description: "(Boolean) Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.\nWhether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.",
                                                            type: 'boolean',
                                                          },
                                                          groupBy: {
                                                            description: '(List of String) A list of alert labels to group alerts into notifications by. Use the special label ... to group alerts by all labels, effectively disabling grouping.\nA list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.',
                                                            items: {
                                                              type: 'string',
                                                            },
                                                            type: 'array',
                                                          },
                                                          groupInterval: {
                                                            description: '(String) Minimum time interval between two notifications for the same group. Default is 5 minutes.\nMinimum time interval between two notifications for the same group. Default is 5 minutes.',
                                                            type: 'string',
                                                          },
                                                          groupWait: {
                                                            description: '(String) Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.\nTime to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.',
                                                            type: 'string',
                                                          },
                                                          matcher: {
                                                            description: '(Block Set) Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances. (see below for nested schema)\nDescribes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.',
                                                            items: {
                                                              properties: {
                                                                label: {
                                                                  description: '(String) The name of the label to match against.\nThe name of the label to match against.',
                                                                  type: 'string',
                                                                },
                                                                match: {
                                                                  description: '(String) The operator to apply when matching values of the given label. Allowed operators are = for equality, != for negated equality, =~ for regex equality, and !~ for negated regex equality.\nThe operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.',
                                                                  type: 'string',
                                                                },
                                                                value: {
                                                                  description: '(String) The label value to match against.\nThe label value to match against.',
                                                                  type: 'string',
                                                                },
                                                              },
                                                              type: 'object',
                                                            },
                                                            type: 'array',
                                                          },
                                                          muteTimingRef: {
                                                            description: 'References to MuteTiming in alerting to populate muteTimings.',
                                                            items: {
                                                              description: 'A Reference to a named object.',
                                                              properties: {
                                                                name: {
                                                                  description: 'Name of the referenced object.',
                                                                  type: 'string',
                                                                },
                                                                policy: {
                                                                  description: 'Policies for referencing.',
                                                                  properties: {
                                                                    resolution: {
                                                                      default: 'Required',
                                                                      description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                                      enum: [
                                                                        'Required',
                                                                        'Optional',
                                                                      ],
                                                                      type: 'string',
                                                                    },
                                                                    resolve: {
                                                                      description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                                      enum: [
                                                                        'Always',
                                                                        'IfNotPresent',
                                                                      ],
                                                                      type: 'string',
                                                                    },
                                                                  },
                                                                  type: 'object',
                                                                },
                                                              },
                                                              required: [
                                                                'name',
                                                              ],
                                                              type: 'object',
                                                            },
                                                            type: 'array',
                                                          },
                                                          muteTimingSelector: {
                                                            description: 'Selector for a list of MuteTiming in alerting to populate muteTimings.',
                                                            properties: {
                                                              matchControllerRef: {
                                                                description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                                                type: 'boolean',
                                                              },
                                                              matchLabels: {
                                                                additionalProperties: {
                                                                  type: 'string',
                                                                },
                                                                description: 'MatchLabels ensures an object with matching labels is selected.',
                                                                type: 'object',
                                                              },
                                                              policy: {
                                                                description: 'Policies for selection.',
                                                                properties: {
                                                                  resolution: {
                                                                    default: 'Required',
                                                                    description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                                    enum: [
                                                                      'Required',
                                                                      'Optional',
                                                                    ],
                                                                    type: 'string',
                                                                  },
                                                                  resolve: {
                                                                    description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                                    enum: [
                                                                      'Always',
                                                                      'IfNotPresent',
                                                                    ],
                                                                    type: 'string',
                                                                  },
                                                                },
                                                                type: 'object',
                                                              },
                                                            },
                                                            type: 'object',
                                                          },
                                                          muteTimings: {
                                                            description: '(List of String) A list of mute timing names to apply to alerts that match this policy.\nA list of mute timing names to apply to alerts that match this policy.',
                                                            items: {
                                                              type: 'string',
                                                            },
                                                            type: 'array',
                                                          },
                                                          repeatInterval: {
                                                            description: 'sending a notification if an alert is still firing. Default is 4 hours.\nMinimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.',
                                                            type: 'string',
                                                          },
                                                        },
                                                        type: 'object',
                                                      },
                                                      type: 'array',
                                                    },
                                                    repeatInterval: {
                                                      description: 'sending a notification if an alert is still firing. Default is 4 hours.\nMinimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              repeatInterval: {
                                                description: 'sending a notification if an alert is still firing. Default is 4 hours.\nMinimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        repeatInterval: {
                                          description: 'sending a notification if an alert is still firing. Default is 4 hours.\nMinimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  repeatInterval: {
                                    description: 'sending a notification if an alert is still firing. Default is 4 hours.\nMinimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  contactPoint: {
                                    description: '(String) The default contact point to route all unmatched notifications to.\nThe default contact point to route all unmatched notifications to.',
                                    type: 'string',
                                  },
                                  contactPointRef: {
                                    description: 'Reference to a ContactPoint in alerting to populate contactPoint.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  contactPointSelector: {
                                    description: 'Selector for a ContactPoint in alerting to populate contactPoint.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  disableProvenance: {
                                    description: 'Defaults to false. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  groupBy: {
                                    description: '(List of String) A list of alert labels to group alerts into notifications by. Use the special label ... to group alerts by all labels, effectively disabling grouping.\nA list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                  },
                                  groupInterval: {
                                    description: '(String) Minimum time interval between two notifications for the same group. Default is 5 minutes.\nMinimum time interval between two notifications for the same group. Default is 5 minutes.',
                                    type: 'string',
                                  },
                                  groupWait: {
                                    description: '(String) Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.\nTime to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  policy: {
                                    description: '(Block List) Routing rules for specific label sets. (see below for nested schema)\nRouting rules for specific label sets.',
                                    items: {
                                      properties: {
                                        contactPoint: {
                                          description: '(String) The default contact point to route all unmatched notifications to.\nThe contact point to route notifications that match this rule to.',
                                          type: 'string',
                                        },
                                        contactPointRef: {
                                          description: 'Reference to a ContactPoint in alerting to populate contactPoint.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        contactPointSelector: {
                                          description: 'Selector for a ContactPoint in alerting to populate contactPoint.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        continue: {
                                          description: "(Boolean) Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.\nWhether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.",
                                          type: 'boolean',
                                        },
                                        groupBy: {
                                          description: '(List of String) A list of alert labels to group alerts into notifications by. Use the special label ... to group alerts by all labels, effectively disabling grouping.\nA list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                        },
                                        groupInterval: {
                                          description: '(String) Minimum time interval between two notifications for the same group. Default is 5 minutes.\nMinimum time interval between two notifications for the same group. Default is 5 minutes.',
                                          type: 'string',
                                        },
                                        groupWait: {
                                          description: '(String) Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.\nTime to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.',
                                          type: 'string',
                                        },
                                        matcher: {
                                          description: '(Block Set) Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances. (see below for nested schema)\nDescribes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.',
                                          items: {
                                            properties: {
                                              label: {
                                                description: '(String) The name of the label to match against.\nThe name of the label to match against.',
                                                type: 'string',
                                              },
                                              match: {
                                                description: '(String) The operator to apply when matching values of the given label. Allowed operators are = for equality, != for negated equality, =~ for regex equality, and !~ for negated regex equality.\nThe operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.',
                                                type: 'string',
                                              },
                                              value: {
                                                description: '(String) The label value to match against.\nThe label value to match against.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        muteTimingRef: {
                                          description: 'References to MuteTiming in alerting to populate muteTimings.',
                                          items: {
                                            description: 'A Reference to a named object.',
                                            properties: {
                                              name: {
                                                description: 'Name of the referenced object.',
                                                type: 'string',
                                              },
                                              policy: {
                                                description: 'Policies for referencing.',
                                                properties: {
                                                  resolution: {
                                                    default: 'Required',
                                                    description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                    enum: [
                                                      'Required',
                                                      'Optional',
                                                    ],
                                                    type: 'string',
                                                  },
                                                  resolve: {
                                                    description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                    enum: [
                                                      'Always',
                                                      'IfNotPresent',
                                                    ],
                                                    type: 'string',
                                                  },
                                                },
                                                type: 'object',
                                              },
                                            },
                                            required: [
                                              'name',
                                            ],
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        muteTimingSelector: {
                                          description: 'Selector for a list of MuteTiming in alerting to populate muteTimings.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        muteTimings: {
                                          description: '(List of String) A list of mute timing names to apply to alerts that match this policy.\nA list of mute timing names to apply to alerts that match this policy.',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                        },
                                        policy: {
                                          description: '(Block List) Routing rules for specific label sets. (see below for nested schema)\nRouting rules for specific label sets.',
                                          items: {
                                            properties: {
                                              contactPoint: {
                                                description: '(String) The default contact point to route all unmatched notifications to.\nThe contact point to route notifications that match this rule to.',
                                                type: 'string',
                                              },
                                              contactPointRef: {
                                                description: 'Reference to a ContactPoint in alerting to populate contactPoint.',
                                                properties: {
                                                  name: {
                                                    description: 'Name of the referenced object.',
                                                    type: 'string',
                                                  },
                                                  policy: {
                                                    description: 'Policies for referencing.',
                                                    properties: {
                                                      resolution: {
                                                        default: 'Required',
                                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                        enum: [
                                                          'Required',
                                                          'Optional',
                                                        ],
                                                        type: 'string',
                                                      },
                                                      resolve: {
                                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                        enum: [
                                                          'Always',
                                                          'IfNotPresent',
                                                        ],
                                                        type: 'string',
                                                      },
                                                    },
                                                    type: 'object',
                                                  },
                                                },
                                                required: [
                                                  'name',
                                                ],
                                                type: 'object',
                                              },
                                              contactPointSelector: {
                                                description: 'Selector for a ContactPoint in alerting to populate contactPoint.',
                                                properties: {
                                                  matchControllerRef: {
                                                    description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                                    type: 'boolean',
                                                  },
                                                  matchLabels: {
                                                    additionalProperties: {
                                                      type: 'string',
                                                    },
                                                    description: 'MatchLabels ensures an object with matching labels is selected.',
                                                    type: 'object',
                                                  },
                                                  policy: {
                                                    description: 'Policies for selection.',
                                                    properties: {
                                                      resolution: {
                                                        default: 'Required',
                                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                        enum: [
                                                          'Required',
                                                          'Optional',
                                                        ],
                                                        type: 'string',
                                                      },
                                                      resolve: {
                                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                        enum: [
                                                          'Always',
                                                          'IfNotPresent',
                                                        ],
                                                        type: 'string',
                                                      },
                                                    },
                                                    type: 'object',
                                                  },
                                                },
                                                type: 'object',
                                              },
                                              continue: {
                                                description: "(Boolean) Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.\nWhether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.",
                                                type: 'boolean',
                                              },
                                              groupBy: {
                                                description: '(List of String) A list of alert labels to group alerts into notifications by. Use the special label ... to group alerts by all labels, effectively disabling grouping.\nA list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                              },
                                              groupInterval: {
                                                description: '(String) Minimum time interval between two notifications for the same group. Default is 5 minutes.\nMinimum time interval between two notifications for the same group. Default is 5 minutes.',
                                                type: 'string',
                                              },
                                              groupWait: {
                                                description: '(String) Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.\nTime to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.',
                                                type: 'string',
                                              },
                                              matcher: {
                                                description: '(Block Set) Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances. (see below for nested schema)\nDescribes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.',
                                                items: {
                                                  properties: {
                                                    label: {
                                                      description: '(String) The name of the label to match against.\nThe name of the label to match against.',
                                                      type: 'string',
                                                    },
                                                    match: {
                                                      description: '(String) The operator to apply when matching values of the given label. Allowed operators are = for equality, != for negated equality, =~ for regex equality, and !~ for negated regex equality.\nThe operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.',
                                                      type: 'string',
                                                    },
                                                    value: {
                                                      description: '(String) The label value to match against.\nThe label value to match against.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              muteTimingRef: {
                                                description: 'References to MuteTiming in alerting to populate muteTimings.',
                                                items: {
                                                  description: 'A Reference to a named object.',
                                                  properties: {
                                                    name: {
                                                      description: 'Name of the referenced object.',
                                                      type: 'string',
                                                    },
                                                    policy: {
                                                      description: 'Policies for referencing.',
                                                      properties: {
                                                        resolution: {
                                                          default: 'Required',
                                                          description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                          enum: [
                                                            'Required',
                                                            'Optional',
                                                          ],
                                                          type: 'string',
                                                        },
                                                        resolve: {
                                                          description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                          enum: [
                                                            'Always',
                                                            'IfNotPresent',
                                                          ],
                                                          type: 'string',
                                                        },
                                                      },
                                                      type: 'object',
                                                    },
                                                  },
                                                  required: [
                                                    'name',
                                                  ],
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              muteTimingSelector: {
                                                description: 'Selector for a list of MuteTiming in alerting to populate muteTimings.',
                                                properties: {
                                                  matchControllerRef: {
                                                    description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                                    type: 'boolean',
                                                  },
                                                  matchLabels: {
                                                    additionalProperties: {
                                                      type: 'string',
                                                    },
                                                    description: 'MatchLabels ensures an object with matching labels is selected.',
                                                    type: 'object',
                                                  },
                                                  policy: {
                                                    description: 'Policies for selection.',
                                                    properties: {
                                                      resolution: {
                                                        default: 'Required',
                                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                        enum: [
                                                          'Required',
                                                          'Optional',
                                                        ],
                                                        type: 'string',
                                                      },
                                                      resolve: {
                                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                        enum: [
                                                          'Always',
                                                          'IfNotPresent',
                                                        ],
                                                        type: 'string',
                                                      },
                                                    },
                                                    type: 'object',
                                                  },
                                                },
                                                type: 'object',
                                              },
                                              muteTimings: {
                                                description: '(List of String) A list of mute timing names to apply to alerts that match this policy.\nA list of mute timing names to apply to alerts that match this policy.',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                              },
                                              policy: {
                                                description: '(Block List) Routing rules for specific label sets. (see below for nested schema)\nRouting rules for specific label sets.',
                                                items: {
                                                  properties: {
                                                    contactPoint: {
                                                      description: '(String) The default contact point to route all unmatched notifications to.\nThe contact point to route notifications that match this rule to.',
                                                      type: 'string',
                                                    },
                                                    contactPointRef: {
                                                      description: 'Reference to a ContactPoint in alerting to populate contactPoint.',
                                                      properties: {
                                                        name: {
                                                          description: 'Name of the referenced object.',
                                                          type: 'string',
                                                        },
                                                        policy: {
                                                          description: 'Policies for referencing.',
                                                          properties: {
                                                            resolution: {
                                                              default: 'Required',
                                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                              enum: [
                                                                'Required',
                                                                'Optional',
                                                              ],
                                                              type: 'string',
                                                            },
                                                            resolve: {
                                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                              enum: [
                                                                'Always',
                                                                'IfNotPresent',
                                                              ],
                                                              type: 'string',
                                                            },
                                                          },
                                                          type: 'object',
                                                        },
                                                      },
                                                      required: [
                                                        'name',
                                                      ],
                                                      type: 'object',
                                                    },
                                                    contactPointSelector: {
                                                      description: 'Selector for a ContactPoint in alerting to populate contactPoint.',
                                                      properties: {
                                                        matchControllerRef: {
                                                          description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                                          type: 'boolean',
                                                        },
                                                        matchLabels: {
                                                          additionalProperties: {
                                                            type: 'string',
                                                          },
                                                          description: 'MatchLabels ensures an object with matching labels is selected.',
                                                          type: 'object',
                                                        },
                                                        policy: {
                                                          description: 'Policies for selection.',
                                                          properties: {
                                                            resolution: {
                                                              default: 'Required',
                                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                              enum: [
                                                                'Required',
                                                                'Optional',
                                                              ],
                                                              type: 'string',
                                                            },
                                                            resolve: {
                                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                              enum: [
                                                                'Always',
                                                                'IfNotPresent',
                                                              ],
                                                              type: 'string',
                                                            },
                                                          },
                                                          type: 'object',
                                                        },
                                                      },
                                                      type: 'object',
                                                    },
                                                    continue: {
                                                      description: "(Boolean) Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.\nWhether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.",
                                                      type: 'boolean',
                                                    },
                                                    groupBy: {
                                                      description: '(List of String) A list of alert labels to group alerts into notifications by. Use the special label ... to group alerts by all labels, effectively disabling grouping.\nA list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                    },
                                                    groupInterval: {
                                                      description: '(String) Minimum time interval between two notifications for the same group. Default is 5 minutes.\nMinimum time interval between two notifications for the same group. Default is 5 minutes.',
                                                      type: 'string',
                                                    },
                                                    groupWait: {
                                                      description: '(String) Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.\nTime to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.',
                                                      type: 'string',
                                                    },
                                                    matcher: {
                                                      description: '(Block Set) Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances. (see below for nested schema)\nDescribes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.',
                                                      items: {
                                                        properties: {
                                                          label: {
                                                            description: '(String) The name of the label to match against.\nThe name of the label to match against.',
                                                            type: 'string',
                                                          },
                                                          match: {
                                                            description: '(String) The operator to apply when matching values of the given label. Allowed operators are = for equality, != for negated equality, =~ for regex equality, and !~ for negated regex equality.\nThe operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.',
                                                            type: 'string',
                                                          },
                                                          value: {
                                                            description: '(String) The label value to match against.\nThe label value to match against.',
                                                            type: 'string',
                                                          },
                                                        },
                                                        type: 'object',
                                                      },
                                                      type: 'array',
                                                    },
                                                    muteTimingRef: {
                                                      description: 'References to MuteTiming in alerting to populate muteTimings.',
                                                      items: {
                                                        description: 'A Reference to a named object.',
                                                        properties: {
                                                          name: {
                                                            description: 'Name of the referenced object.',
                                                            type: 'string',
                                                          },
                                                          policy: {
                                                            description: 'Policies for referencing.',
                                                            properties: {
                                                              resolution: {
                                                                default: 'Required',
                                                                description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                                enum: [
                                                                  'Required',
                                                                  'Optional',
                                                                ],
                                                                type: 'string',
                                                              },
                                                              resolve: {
                                                                description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                                enum: [
                                                                  'Always',
                                                                  'IfNotPresent',
                                                                ],
                                                                type: 'string',
                                                              },
                                                            },
                                                            type: 'object',
                                                          },
                                                        },
                                                        required: [
                                                          'name',
                                                        ],
                                                        type: 'object',
                                                      },
                                                      type: 'array',
                                                    },
                                                    muteTimingSelector: {
                                                      description: 'Selector for a list of MuteTiming in alerting to populate muteTimings.',
                                                      properties: {
                                                        matchControllerRef: {
                                                          description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                                          type: 'boolean',
                                                        },
                                                        matchLabels: {
                                                          additionalProperties: {
                                                            type: 'string',
                                                          },
                                                          description: 'MatchLabels ensures an object with matching labels is selected.',
                                                          type: 'object',
                                                        },
                                                        policy: {
                                                          description: 'Policies for selection.',
                                                          properties: {
                                                            resolution: {
                                                              default: 'Required',
                                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                              enum: [
                                                                'Required',
                                                                'Optional',
                                                              ],
                                                              type: 'string',
                                                            },
                                                            resolve: {
                                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                              enum: [
                                                                'Always',
                                                                'IfNotPresent',
                                                              ],
                                                              type: 'string',
                                                            },
                                                          },
                                                          type: 'object',
                                                        },
                                                      },
                                                      type: 'object',
                                                    },
                                                    muteTimings: {
                                                      description: '(List of String) A list of mute timing names to apply to alerts that match this policy.\nA list of mute timing names to apply to alerts that match this policy.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                    },
                                                    policy: {
                                                      description: '(Block List) Routing rules for specific label sets. (see below for nested schema)\nRouting rules for specific label sets.',
                                                      items: {
                                                        properties: {
                                                          contactPoint: {
                                                            description: '(String) The default contact point to route all unmatched notifications to.\nThe contact point to route notifications that match this rule to.',
                                                            type: 'string',
                                                          },
                                                          contactPointRef: {
                                                            description: 'Reference to a ContactPoint in alerting to populate contactPoint.',
                                                            properties: {
                                                              name: {
                                                                description: 'Name of the referenced object.',
                                                                type: 'string',
                                                              },
                                                              policy: {
                                                                description: 'Policies for referencing.',
                                                                properties: {
                                                                  resolution: {
                                                                    default: 'Required',
                                                                    description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                                    enum: [
                                                                      'Required',
                                                                      'Optional',
                                                                    ],
                                                                    type: 'string',
                                                                  },
                                                                  resolve: {
                                                                    description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                                    enum: [
                                                                      'Always',
                                                                      'IfNotPresent',
                                                                    ],
                                                                    type: 'string',
                                                                  },
                                                                },
                                                                type: 'object',
                                                              },
                                                            },
                                                            required: [
                                                              'name',
                                                            ],
                                                            type: 'object',
                                                          },
                                                          contactPointSelector: {
                                                            description: 'Selector for a ContactPoint in alerting to populate contactPoint.',
                                                            properties: {
                                                              matchControllerRef: {
                                                                description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                                                type: 'boolean',
                                                              },
                                                              matchLabels: {
                                                                additionalProperties: {
                                                                  type: 'string',
                                                                },
                                                                description: 'MatchLabels ensures an object with matching labels is selected.',
                                                                type: 'object',
                                                              },
                                                              policy: {
                                                                description: 'Policies for selection.',
                                                                properties: {
                                                                  resolution: {
                                                                    default: 'Required',
                                                                    description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                                    enum: [
                                                                      'Required',
                                                                      'Optional',
                                                                    ],
                                                                    type: 'string',
                                                                  },
                                                                  resolve: {
                                                                    description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                                    enum: [
                                                                      'Always',
                                                                      'IfNotPresent',
                                                                    ],
                                                                    type: 'string',
                                                                  },
                                                                },
                                                                type: 'object',
                                                              },
                                                            },
                                                            type: 'object',
                                                          },
                                                          continue: {
                                                            description: "(Boolean) Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.\nWhether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.",
                                                            type: 'boolean',
                                                          },
                                                          groupBy: {
                                                            description: '(List of String) A list of alert labels to group alerts into notifications by. Use the special label ... to group alerts by all labels, effectively disabling grouping.\nA list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. Required for root policy only. If empty, the parent grouping is used.',
                                                            items: {
                                                              type: 'string',
                                                            },
                                                            type: 'array',
                                                          },
                                                          groupInterval: {
                                                            description: '(String) Minimum time interval between two notifications for the same group. Default is 5 minutes.\nMinimum time interval between two notifications for the same group. Default is 5 minutes.',
                                                            type: 'string',
                                                          },
                                                          groupWait: {
                                                            description: '(String) Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.\nTime to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.',
                                                            type: 'string',
                                                          },
                                                          matcher: {
                                                            description: '(Block Set) Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances. (see below for nested schema)\nDescribes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.',
                                                            items: {
                                                              properties: {
                                                                label: {
                                                                  description: '(String) The name of the label to match against.\nThe name of the label to match against.',
                                                                  type: 'string',
                                                                },
                                                                match: {
                                                                  description: '(String) The operator to apply when matching values of the given label. Allowed operators are = for equality, != for negated equality, =~ for regex equality, and !~ for negated regex equality.\nThe operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.',
                                                                  type: 'string',
                                                                },
                                                                value: {
                                                                  description: '(String) The label value to match against.\nThe label value to match against.',
                                                                  type: 'string',
                                                                },
                                                              },
                                                              type: 'object',
                                                            },
                                                            type: 'array',
                                                          },
                                                          muteTimingRef: {
                                                            description: 'References to MuteTiming in alerting to populate muteTimings.',
                                                            items: {
                                                              description: 'A Reference to a named object.',
                                                              properties: {
                                                                name: {
                                                                  description: 'Name of the referenced object.',
                                                                  type: 'string',
                                                                },
                                                                policy: {
                                                                  description: 'Policies for referencing.',
                                                                  properties: {
                                                                    resolution: {
                                                                      default: 'Required',
                                                                      description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                                      enum: [
                                                                        'Required',
                                                                        'Optional',
                                                                      ],
                                                                      type: 'string',
                                                                    },
                                                                    resolve: {
                                                                      description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                                      enum: [
                                                                        'Always',
                                                                        'IfNotPresent',
                                                                      ],
                                                                      type: 'string',
                                                                    },
                                                                  },
                                                                  type: 'object',
                                                                },
                                                              },
                                                              required: [
                                                                'name',
                                                              ],
                                                              type: 'object',
                                                            },
                                                            type: 'array',
                                                          },
                                                          muteTimingSelector: {
                                                            description: 'Selector for a list of MuteTiming in alerting to populate muteTimings.',
                                                            properties: {
                                                              matchControllerRef: {
                                                                description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                                                type: 'boolean',
                                                              },
                                                              matchLabels: {
                                                                additionalProperties: {
                                                                  type: 'string',
                                                                },
                                                                description: 'MatchLabels ensures an object with matching labels is selected.',
                                                                type: 'object',
                                                              },
                                                              policy: {
                                                                description: 'Policies for selection.',
                                                                properties: {
                                                                  resolution: {
                                                                    default: 'Required',
                                                                    description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                                    enum: [
                                                                      'Required',
                                                                      'Optional',
                                                                    ],
                                                                    type: 'string',
                                                                  },
                                                                  resolve: {
                                                                    description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                                    enum: [
                                                                      'Always',
                                                                      'IfNotPresent',
                                                                    ],
                                                                    type: 'string',
                                                                  },
                                                                },
                                                                type: 'object',
                                                              },
                                                            },
                                                            type: 'object',
                                                          },
                                                          muteTimings: {
                                                            description: '(List of String) A list of mute timing names to apply to alerts that match this policy.\nA list of mute timing names to apply to alerts that match this policy.',
                                                            items: {
                                                              type: 'string',
                                                            },
                                                            type: 'array',
                                                          },
                                                          repeatInterval: {
                                                            description: 'sending a notification if an alert is still firing. Default is 4 hours.\nMinimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.',
                                                            type: 'string',
                                                          },
                                                        },
                                                        type: 'object',
                                                      },
                                                      type: 'array',
                                                    },
                                                    repeatInterval: {
                                                      description: 'sending a notification if an alert is still firing. Default is 4 hours.\nMinimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              repeatInterval: {
                                                description: 'sending a notification if an alert is still firing. Default is 4 hours.\nMinimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        repeatInterval: {
                                          description: 'sending a notification if an alert is still firing. Default is 4 hours.\nMinimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  repeatInterval: {
                                    description: 'sending a notification if an alert is still firing. Default is 4 hours.\nMinimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.groupBy is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.groupBy) || (has(self.initProvider) && has(self.initProvider.groupBy))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      ruleGroup: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xrulegroups.alerting.grafana.crossplane.io.namespaced',
            },
            name: 'rulegroup-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'alerting.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XRuleGroup',
            },
            resources: [
              {
                base: {
                  apiVersion: 'alerting.grafana.crossplane.io/v1alpha1',
                  kind: 'RuleGroup',
                },
                name: 'rulegroup',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.disableProvenance',
                    toFieldPath: 'spec.forProvider.disableProvenance',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.name',
                    toFieldPath: 'spec.forProvider.folderRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.folderRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.folderRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.folderSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.folderSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.folderSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.folderSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderUid',
                    toFieldPath: 'spec.forProvider.folderUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.intervalSeconds',
                    toFieldPath: 'spec.forProvider.intervalSeconds',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.rule',
                    toFieldPath: 'spec.forProvider.rule',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.disableProvenance',
                    toFieldPath: 'spec.initProvider.disableProvenance',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.name',
                    toFieldPath: 'spec.initProvider.folderRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.folderRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.folderRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.folderSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.folderSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.folderSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.folderSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderUid',
                    toFieldPath: 'spec.initProvider.folderUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.intervalSeconds',
                    toFieldPath: 'spec.initProvider.intervalSeconds',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.rule',
                    toFieldPath: 'spec.initProvider.rule',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xrulegroups.alerting.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'RuleGroup',
              plural: 'rulegroups',
            },
            defaultCompositionRef: {
              name: 'rulegroup-namespaced',
            },
            group: 'alerting.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XRuleGroup',
              plural: 'xrulegroups',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'RuleGroupSpec defines the desired state of RuleGroup',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  disableProvenance: {
                                    description: 'Defaults to false. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  folderRef: {
                                    description: 'Reference to a Folder in oss to populate folderUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  folderSelector: {
                                    description: 'Selector for a Folder in oss to populate folderUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  folderUid: {
                                    description: '(String) The UID of the folder that the group belongs to.\nThe UID of the folder that the group belongs to.',
                                    type: 'string',
                                  },
                                  intervalSeconds: {
                                    description: '(Number) The interval, in seconds, at which all rules in the group are evaluated. If a group contains many rules, the rules are evaluated sequentially.\nThe interval, in seconds, at which all rules in the group are evaluated. If a group contains many rules, the rules are evaluated sequentially.',
                                    type: 'number',
                                  },
                                  name: {
                                    description: '(String) The name of the rule group.\nThe name of the rule group.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  rule: {
                                    description: '(Block List, Min: 1) The rules within the group. (see below for nested schema)\nThe rules within the group.',
                                    items: {
                                      properties: {
                                        annotations: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          description: 'value pairs of metadata to attach to the alert rule that may add user-defined context, but cannot be used for matching, grouping, or routing. Defaults to map[].\nKey-value pairs of metadata to attach to the alert rule that may add user-defined context, but cannot be used for matching, grouping, or routing. Defaults to `map[]`.',
                                          type: 'object',
                                          'x-kubernetes-map-type': 'granular',
                                        },
                                        condition: {
                                          description: '(String) The ref_id of the query node in the data field to use as the alert condition.\nThe `ref_id` of the query node in the `data` field to use as the alert condition.',
                                          type: 'string',
                                        },
                                        data: {
                                          description: '(Block List, Min: 1) A sequence of stages that describe the contents of the rule. (see below for nested schema)\nA sequence of stages that describe the contents of the rule.',
                                          items: {
                                            properties: {
                                              datasourceUid: {
                                                description: '100" if this stage is an expression stage.\nThe UID of the datasource being queried, or "-100" if this stage is an expression stage.',
                                                type: 'string',
                                              },
                                              model: {
                                                description: '(String) Custom JSON data to send to the specified datasource when querying.\nCustom JSON data to send to the specified datasource when querying.',
                                                type: 'string',
                                              },
                                              queryType: {
                                                description: '(String) An optional identifier for the type of query being executed. Defaults to “.\nAn optional identifier for the type of query being executed. Defaults to “.',
                                                type: 'string',
                                              },
                                              refId: {
                                                description: '(String) A unique string to identify this query stage within a rule.\nA unique string to identify this query stage within a rule.',
                                                type: 'string',
                                              },
                                              relativeTimeRange: {
                                                description: '(Block List, Min: 1, Max: 1) The time range, relative to when the query is executed, across which to query. (see below for nested schema)\nThe time range, relative to when the query is executed, across which to query.',
                                                items: {
                                                  properties: {
                                                    from: {
                                                      description: '(Number) The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.\nThe number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.',
                                                      type: 'number',
                                                    },
                                                    to: {
                                                      description: '(Number) The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.\nThe number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.',
                                                      type: 'number',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        execErrState: {
                                          description: "(String) Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting. Defaults to Alerting.\nDescribes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting. Defaults to `Alerting`.",
                                          type: 'string',
                                        },
                                        'for': {
                                          description: '(String) The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to 0.\nThe amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        isPaused: {
                                          description: '(Boolean) Sets whether the alert should be paused or not. Defaults to false.\nSets whether the alert should be paused or not. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        labels: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          description: 'value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to map[].\nKey-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.',
                                          type: 'object',
                                          'x-kubernetes-map-type': 'granular',
                                        },
                                        name: {
                                          description: '(String) The name of the rule group.\nThe name of the alert rule.',
                                          type: 'string',
                                        },
                                        noDataState: {
                                          description: "(String) Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to NoData.\nDescribes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to `NoData`.",
                                          type: 'string',
                                        },
                                        notificationSettings: {
                                          description: "(Block List, Max: 1) Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' enabled. (see below for nested schema)\nNotification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' enabled.",
                                          items: {
                                            properties: {
                                              contactPoint: {
                                                description: '(String) The contact point to route notifications that match this rule to.\nThe contact point to route notifications that match this rule to.',
                                                type: 'string',
                                              },
                                              contactPointRef: {
                                                description: 'Reference to a ContactPoint in alerting to populate contactPoint.',
                                                properties: {
                                                  name: {
                                                    description: 'Name of the referenced object.',
                                                    type: 'string',
                                                  },
                                                  policy: {
                                                    description: 'Policies for referencing.',
                                                    properties: {
                                                      resolution: {
                                                        default: 'Required',
                                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                        enum: [
                                                          'Required',
                                                          'Optional',
                                                        ],
                                                        type: 'string',
                                                      },
                                                      resolve: {
                                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                        enum: [
                                                          'Always',
                                                          'IfNotPresent',
                                                        ],
                                                        type: 'string',
                                                      },
                                                    },
                                                    type: 'object',
                                                  },
                                                },
                                                required: [
                                                  'name',
                                                ],
                                                type: 'object',
                                              },
                                              contactPointSelector: {
                                                description: 'Selector for a ContactPoint in alerting to populate contactPoint.',
                                                properties: {
                                                  matchControllerRef: {
                                                    description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                                    type: 'boolean',
                                                  },
                                                  matchLabels: {
                                                    additionalProperties: {
                                                      type: 'string',
                                                    },
                                                    description: 'MatchLabels ensures an object with matching labels is selected.',
                                                    type: 'object',
                                                  },
                                                  policy: {
                                                    description: 'Policies for selection.',
                                                    properties: {
                                                      resolution: {
                                                        default: 'Required',
                                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                        enum: [
                                                          'Required',
                                                          'Optional',
                                                        ],
                                                        type: 'string',
                                                      },
                                                      resolve: {
                                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                        enum: [
                                                          'Always',
                                                          'IfNotPresent',
                                                        ],
                                                        type: 'string',
                                                      },
                                                    },
                                                    type: 'object',
                                                  },
                                                },
                                                type: 'object',
                                              },
                                              groupBy: {
                                                description: "(List of String) A list of alert labels to group alerts into notifications by. Use the special label ... to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.\nA list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.",
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                              },
                                              groupInterval: {
                                                description: '(String) Minimum time interval between two notifications for the same group. Default is 5 minutes.\nMinimum time interval between two notifications for the same group. Default is 5 minutes.',
                                                type: 'string',
                                              },
                                              groupWait: {
                                                description: '(String) Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.\nTime to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.',
                                                type: 'string',
                                              },
                                              muteTimings: {
                                                description: '(List of String) A list of mute timing names to apply to alerts that match this policy.\nA list of mute timing names to apply to alerts that match this policy.',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                              },
                                              repeatInterval: {
                                                description: 'sending a notification if an alert is still firing. Default is 4 hours.\nMinimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  disableProvenance: {
                                    description: 'Defaults to false. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  folderRef: {
                                    description: 'Reference to a Folder in oss to populate folderUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  folderSelector: {
                                    description: 'Selector for a Folder in oss to populate folderUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  folderUid: {
                                    description: '(String) The UID of the folder that the group belongs to.\nThe UID of the folder that the group belongs to.',
                                    type: 'string',
                                  },
                                  intervalSeconds: {
                                    description: '(Number) The interval, in seconds, at which all rules in the group are evaluated. If a group contains many rules, the rules are evaluated sequentially.\nThe interval, in seconds, at which all rules in the group are evaluated. If a group contains many rules, the rules are evaluated sequentially.',
                                    type: 'number',
                                  },
                                  name: {
                                    description: '(String) The name of the rule group.\nThe name of the rule group.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  rule: {
                                    description: '(Block List, Min: 1) The rules within the group. (see below for nested schema)\nThe rules within the group.',
                                    items: {
                                      properties: {
                                        annotations: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          description: 'value pairs of metadata to attach to the alert rule that may add user-defined context, but cannot be used for matching, grouping, or routing. Defaults to map[].\nKey-value pairs of metadata to attach to the alert rule that may add user-defined context, but cannot be used for matching, grouping, or routing. Defaults to `map[]`.',
                                          type: 'object',
                                          'x-kubernetes-map-type': 'granular',
                                        },
                                        condition: {
                                          description: '(String) The ref_id of the query node in the data field to use as the alert condition.\nThe `ref_id` of the query node in the `data` field to use as the alert condition.',
                                          type: 'string',
                                        },
                                        data: {
                                          description: '(Block List, Min: 1) A sequence of stages that describe the contents of the rule. (see below for nested schema)\nA sequence of stages that describe the contents of the rule.',
                                          items: {
                                            properties: {
                                              datasourceUid: {
                                                description: '100" if this stage is an expression stage.\nThe UID of the datasource being queried, or "-100" if this stage is an expression stage.',
                                                type: 'string',
                                              },
                                              model: {
                                                description: '(String) Custom JSON data to send to the specified datasource when querying.\nCustom JSON data to send to the specified datasource when querying.',
                                                type: 'string',
                                              },
                                              queryType: {
                                                description: '(String) An optional identifier for the type of query being executed. Defaults to “.\nAn optional identifier for the type of query being executed. Defaults to “.',
                                                type: 'string',
                                              },
                                              refId: {
                                                description: '(String) A unique string to identify this query stage within a rule.\nA unique string to identify this query stage within a rule.',
                                                type: 'string',
                                              },
                                              relativeTimeRange: {
                                                description: '(Block List, Min: 1, Max: 1) The time range, relative to when the query is executed, across which to query. (see below for nested schema)\nThe time range, relative to when the query is executed, across which to query.',
                                                items: {
                                                  properties: {
                                                    from: {
                                                      description: '(Number) The number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.\nThe number of seconds in the past, relative to when the rule is evaluated, at which the time range begins.',
                                                      type: 'number',
                                                    },
                                                    to: {
                                                      description: '(Number) The number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.\nThe number of seconds in the past, relative to when the rule is evaluated, at which the time range ends.',
                                                      type: 'number',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        execErrState: {
                                          description: "(String) Describes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting. Defaults to Alerting.\nDescribes what state to enter when the rule's query is invalid and the rule cannot be executed. Options are OK, Error, KeepLast, and Alerting. Defaults to `Alerting`.",
                                          type: 'string',
                                        },
                                        'for': {
                                          description: '(String) The amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to 0.\nThe amount of time for which the rule must be breached for the rule to be considered to be Firing. Before this time has elapsed, the rule is only considered to be Pending. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        isPaused: {
                                          description: '(Boolean) Sets whether the alert should be paused or not. Defaults to false.\nSets whether the alert should be paused or not. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        labels: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          description: 'value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to map[].\nKey-value pairs to attach to the alert rule that can be used in matching, grouping, and routing. Defaults to `map[]`.',
                                          type: 'object',
                                          'x-kubernetes-map-type': 'granular',
                                        },
                                        name: {
                                          description: '(String) The name of the rule group.\nThe name of the alert rule.',
                                          type: 'string',
                                        },
                                        noDataState: {
                                          description: "(String) Describes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to NoData.\nDescribes what state to enter when the rule's query returns No Data. Options are OK, NoData, KeepLast, and Alerting. Defaults to `NoData`.",
                                          type: 'string',
                                        },
                                        notificationSettings: {
                                          description: "(Block List, Max: 1) Notification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' enabled. (see below for nested schema)\nNotification settings for the rule. If specified, it overrides the notification policies. Available since Grafana 10.4, requires feature flag 'alertingSimplifiedRouting' enabled.",
                                          items: {
                                            properties: {
                                              contactPoint: {
                                                description: '(String) The contact point to route notifications that match this rule to.\nThe contact point to route notifications that match this rule to.',
                                                type: 'string',
                                              },
                                              contactPointRef: {
                                                description: 'Reference to a ContactPoint in alerting to populate contactPoint.',
                                                properties: {
                                                  name: {
                                                    description: 'Name of the referenced object.',
                                                    type: 'string',
                                                  },
                                                  policy: {
                                                    description: 'Policies for referencing.',
                                                    properties: {
                                                      resolution: {
                                                        default: 'Required',
                                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                        enum: [
                                                          'Required',
                                                          'Optional',
                                                        ],
                                                        type: 'string',
                                                      },
                                                      resolve: {
                                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                        enum: [
                                                          'Always',
                                                          'IfNotPresent',
                                                        ],
                                                        type: 'string',
                                                      },
                                                    },
                                                    type: 'object',
                                                  },
                                                },
                                                required: [
                                                  'name',
                                                ],
                                                type: 'object',
                                              },
                                              contactPointSelector: {
                                                description: 'Selector for a ContactPoint in alerting to populate contactPoint.',
                                                properties: {
                                                  matchControllerRef: {
                                                    description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                                    type: 'boolean',
                                                  },
                                                  matchLabels: {
                                                    additionalProperties: {
                                                      type: 'string',
                                                    },
                                                    description: 'MatchLabels ensures an object with matching labels is selected.',
                                                    type: 'object',
                                                  },
                                                  policy: {
                                                    description: 'Policies for selection.',
                                                    properties: {
                                                      resolution: {
                                                        default: 'Required',
                                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                        enum: [
                                                          'Required',
                                                          'Optional',
                                                        ],
                                                        type: 'string',
                                                      },
                                                      resolve: {
                                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                        enum: [
                                                          'Always',
                                                          'IfNotPresent',
                                                        ],
                                                        type: 'string',
                                                      },
                                                    },
                                                    type: 'object',
                                                  },
                                                },
                                                type: 'object',
                                              },
                                              groupBy: {
                                                description: "(List of String) A list of alert labels to group alerts into notifications by. Use the special label ... to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.\nA list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping. If empty, no grouping is used. If specified, requires labels 'alertname' and 'grafana_folder' to be included.",
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                              },
                                              groupInterval: {
                                                description: '(String) Minimum time interval between two notifications for the same group. Default is 5 minutes.\nMinimum time interval between two notifications for the same group. Default is 5 minutes.',
                                                type: 'string',
                                              },
                                              groupWait: {
                                                description: '(String) Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.\nTime to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.',
                                                type: 'string',
                                              },
                                              muteTimings: {
                                                description: '(List of String) A list of mute timing names to apply to alerts that match this policy.\nA list of mute timing names to apply to alerts that match this policy.',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                              },
                                              repeatInterval: {
                                                description: 'sending a notification if an alert is still firing. Default is 4 hours.\nMinimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.intervalSeconds is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.intervalSeconds) || (has(self.initProvider) && has(self.initProvider.intervalSeconds))",
                              },
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.rule is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.rule) || (has(self.initProvider) && has(self.initProvider.rule))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
    },
  },
  cloud: {
    v1alpha1: {
      accessPolicy: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xaccesspolicies.cloud.grafana.crossplane.io.namespaced',
            },
            name: 'accesspolicy-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'cloud.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XAccessPolicy',
            },
            resources: [
              {
                base: {
                  apiVersion: 'cloud.grafana.crossplane.io/v1alpha1',
                  kind: 'AccessPolicy',
                },
                name: 'accesspolicy',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.displayName',
                    toFieldPath: 'spec.forProvider.displayName',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.realm',
                    toFieldPath: 'spec.forProvider.realm',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.region',
                    toFieldPath: 'spec.forProvider.region',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.scopes',
                    toFieldPath: 'spec.forProvider.scopes',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.displayName',
                    toFieldPath: 'spec.initProvider.displayName',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.realm',
                    toFieldPath: 'spec.initProvider.realm',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.region',
                    toFieldPath: 'spec.initProvider.region',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.scopes',
                    toFieldPath: 'spec.initProvider.scopes',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xaccesspolicies.cloud.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'AccessPolicy',
              plural: 'accesspolicies',
            },
            defaultCompositionRef: {
              name: 'accesspolicy-namespaced',
            },
            group: 'cloud.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XAccessPolicy',
              plural: 'xaccesspolicies',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'AccessPolicySpec defines the desired state of AccessPolicy',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  displayName: {
                                    description: '(String) Display name of the access policy. Defaults to the name.\nDisplay name of the access policy. Defaults to the name.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: '(String) Name of the access policy.\nName of the access policy.',
                                    type: 'string',
                                  },
                                  realm: {
                                    description: '(Block Set, Min: 1) (see below for nested schema)',
                                    items: {
                                      properties: {
                                        identifier: {
                                          description: '(String) The identifier of the org or stack. For orgs, this is the slug, for stacks, this is the stack ID.\nThe identifier of the org or stack. For orgs, this is the slug, for stacks, this is the stack ID.',
                                          type: 'string',
                                        },
                                        labelPolicy: {
                                          description: '(Block Set) (see below for nested schema)',
                                          items: {
                                            properties: {
                                              selector: {
                                                description: '(String) The label selector to match in metrics or logs query. Should be in PromQL or LogQL format.\nThe label selector to match in metrics or logs query. Should be in PromQL or LogQL format.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        stackRef: {
                                          description: 'Reference to a Stack in cloud to populate identifier.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        stackSelector: {
                                          description: 'Selector for a Stack in cloud to populate identifier.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        type: {
                                          description: '(String) Whether a policy applies to a Cloud org or a specific stack. Should be one of org or stack.\nWhether a policy applies to a Cloud org or a specific stack. Should be one of `org` or `stack`.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  region: {
                                    description: 'cloud/developer-resources/api-reference/cloud-api/#list-regions.\nRegion where the API is deployed. Generally where the stack is deployed. Use the region list API to get the list of available regions: https://grafana.com/docs/grafana-cloud/developer-resources/api-reference/cloud-api/#list-regions.',
                                    type: 'string',
                                  },
                                  scopes: {
                                    description: 'cloud/account-management/authentication-and-permissions/access-policies/#scopes for possible values.\nScopes of the access policy. See https://grafana.com/docs/grafana-cloud/account-management/authentication-and-permissions/access-policies/#scopes for possible values.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  displayName: {
                                    description: '(String) Display name of the access policy. Defaults to the name.\nDisplay name of the access policy. Defaults to the name.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: '(String) Name of the access policy.\nName of the access policy.',
                                    type: 'string',
                                  },
                                  realm: {
                                    description: '(Block Set, Min: 1) (see below for nested schema)',
                                    items: {
                                      properties: {
                                        identifier: {
                                          description: '(String) The identifier of the org or stack. For orgs, this is the slug, for stacks, this is the stack ID.\nThe identifier of the org or stack. For orgs, this is the slug, for stacks, this is the stack ID.',
                                          type: 'string',
                                        },
                                        labelPolicy: {
                                          description: '(Block Set) (see below for nested schema)',
                                          items: {
                                            properties: {
                                              selector: {
                                                description: '(String) The label selector to match in metrics or logs query. Should be in PromQL or LogQL format.\nThe label selector to match in metrics or logs query. Should be in PromQL or LogQL format.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        stackRef: {
                                          description: 'Reference to a Stack in cloud to populate identifier.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        stackSelector: {
                                          description: 'Selector for a Stack in cloud to populate identifier.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        type: {
                                          description: '(String) Whether a policy applies to a Cloud org or a specific stack. Should be one of org or stack.\nWhether a policy applies to a Cloud org or a specific stack. Should be one of `org` or `stack`.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  region: {
                                    description: 'cloud/developer-resources/api-reference/cloud-api/#list-regions.\nRegion where the API is deployed. Generally where the stack is deployed. Use the region list API to get the list of available regions: https://grafana.com/docs/grafana-cloud/developer-resources/api-reference/cloud-api/#list-regions.',
                                    type: 'string',
                                  },
                                  scopes: {
                                    description: 'cloud/account-management/authentication-and-permissions/access-policies/#scopes for possible values.\nScopes of the access policy. See https://grafana.com/docs/grafana-cloud/account-management/authentication-and-permissions/access-policies/#scopes for possible values.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.realm is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.realm) || (has(self.initProvider) && has(self.initProvider.realm))",
                              },
                              {
                                message: 'spec.forProvider.region is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.region) || (has(self.initProvider) && has(self.initProvider.region))",
                              },
                              {
                                message: 'spec.forProvider.scopes is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.scopes) || (has(self.initProvider) && has(self.initProvider.scopes))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      accessPolicyToken: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xaccesspolicytokens.cloud.grafana.crossplane.io.namespaced',
            },
            name: 'accesspolicytoken-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'cloud.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XAccessPolicyToken',
            },
            resources: [
              {
                base: {
                  apiVersion: 'cloud.grafana.crossplane.io/v1alpha1',
                  kind: 'AccessPolicyToken',
                },
                name: 'accesspolicytoken',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.accessPolicyId',
                    toFieldPath: 'spec.forProvider.accessPolicyId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.accessPolicyRef.name',
                    toFieldPath: 'spec.forProvider.accessPolicyRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.accessPolicyRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.accessPolicyRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.accessPolicyRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.accessPolicyRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.accessPolicySelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.accessPolicySelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.accessPolicySelector.matchLabels',
                    toFieldPath: 'spec.forProvider.accessPolicySelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.accessPolicySelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.accessPolicySelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.accessPolicySelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.accessPolicySelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.displayName',
                    toFieldPath: 'spec.forProvider.displayName',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.expiresAt',
                    toFieldPath: 'spec.forProvider.expiresAt',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.region',
                    toFieldPath: 'spec.forProvider.region',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.accessPolicyId',
                    toFieldPath: 'spec.initProvider.accessPolicyId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.accessPolicyRef.name',
                    toFieldPath: 'spec.initProvider.accessPolicyRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.accessPolicyRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.accessPolicyRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.accessPolicyRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.accessPolicyRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.accessPolicySelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.accessPolicySelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.accessPolicySelector.matchLabels',
                    toFieldPath: 'spec.initProvider.accessPolicySelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.accessPolicySelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.accessPolicySelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.accessPolicySelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.accessPolicySelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.displayName',
                    toFieldPath: 'spec.initProvider.displayName',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.expiresAt',
                    toFieldPath: 'spec.initProvider.expiresAt',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.region',
                    toFieldPath: 'spec.initProvider.region',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xaccesspolicytokens.cloud.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'AccessPolicyToken',
              plural: 'accesspolicytokens',
            },
            defaultCompositionRef: {
              name: 'accesspolicytoken-namespaced',
            },
            group: 'cloud.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XAccessPolicyToken',
              plural: 'xaccesspolicytokens',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'AccessPolicyTokenSpec defines the desired state of AccessPolicyToken',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  accessPolicyId: {
                                    description: '(String) ID of the access policy for which to create a token.\nID of the access policy for which to create a token.',
                                    type: 'string',
                                  },
                                  accessPolicyRef: {
                                    description: 'Reference to a AccessPolicy in cloud to populate accessPolicyId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  accessPolicySelector: {
                                    description: 'Selector for a AccessPolicy in cloud to populate accessPolicyId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  displayName: {
                                    description: '(String) Display name of the access policy token. Defaults to the name.\nDisplay name of the access policy token. Defaults to the name.',
                                    type: 'string',
                                  },
                                  expiresAt: {
                                    description: '(String) Expiration date of the access policy token. Does not expire by default.\nExpiration date of the access policy token. Does not expire by default.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: '(String) Name of the access policy token.\nName of the access policy token.',
                                    type: 'string',
                                  },
                                  region: {
                                    description: 'cloud/developer-resources/api-reference/cloud-api/#list-regions.\nRegion of the access policy. Should be set to the same region as the access policy. Use the region list API to get the list of available regions: https://grafana.com/docs/grafana-cloud/developer-resources/api-reference/cloud-api/#list-regions.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  accessPolicyId: {
                                    description: '(String) ID of the access policy for which to create a token.\nID of the access policy for which to create a token.',
                                    type: 'string',
                                  },
                                  accessPolicyRef: {
                                    description: 'Reference to a AccessPolicy in cloud to populate accessPolicyId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  accessPolicySelector: {
                                    description: 'Selector for a AccessPolicy in cloud to populate accessPolicyId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  displayName: {
                                    description: '(String) Display name of the access policy token. Defaults to the name.\nDisplay name of the access policy token. Defaults to the name.',
                                    type: 'string',
                                  },
                                  expiresAt: {
                                    description: '(String) Expiration date of the access policy token. Does not expire by default.\nExpiration date of the access policy token. Does not expire by default.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: '(String) Name of the access policy token.\nName of the access policy token.',
                                    type: 'string',
                                  },
                                  region: {
                                    description: 'cloud/developer-resources/api-reference/cloud-api/#list-regions.\nRegion of the access policy. Should be set to the same region as the access policy. Use the region list API to get the list of available regions: https://grafana.com/docs/grafana-cloud/developer-resources/api-reference/cloud-api/#list-regions.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.region is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.region) || (has(self.initProvider) && has(self.initProvider.region))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      pluginInstallation: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xplugininstallations.cloud.grafana.crossplane.io.namespaced',
            },
            name: 'plugininstallation-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'cloud.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XPluginInstallation',
            },
            resources: [
              {
                base: {
                  apiVersion: 'cloud.grafana.crossplane.io/v1alpha1',
                  kind: 'PluginInstallation',
                },
                name: 'plugininstallation',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackRef.name',
                    toFieldPath: 'spec.forProvider.cloudStackRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.cloudStackRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.cloudStackRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.slug',
                    toFieldPath: 'spec.forProvider.slug',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.stackSlug',
                    toFieldPath: 'spec.forProvider.stackSlug',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.version',
                    toFieldPath: 'spec.forProvider.version',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackRef.name',
                    toFieldPath: 'spec.initProvider.cloudStackRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.cloudStackRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.cloudStackRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.slug',
                    toFieldPath: 'spec.initProvider.slug',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.stackSlug',
                    toFieldPath: 'spec.initProvider.stackSlug',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.version',
                    toFieldPath: 'spec.initProvider.version',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xplugininstallations.cloud.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'PluginInstallation',
              plural: 'plugininstallations',
            },
            defaultCompositionRef: {
              name: 'plugininstallation-namespaced',
            },
            group: 'cloud.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XPluginInstallation',
              plural: 'xplugininstallations',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'PluginInstallationSpec defines the desired state of PluginInstallation',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  cloudStackRef: {
                                    description: 'Reference to a Stack in cloud to populate stackSlug.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  cloudStackSelector: {
                                    description: 'Selector for a Stack in cloud to populate stackSlug.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  slug: {
                                    description: '(String) Slug of the plugin to be installed.\nSlug of the plugin to be installed.',
                                    type: 'string',
                                  },
                                  stackSlug: {
                                    description: '(String) The stack id to which the plugin should be installed.\nThe stack id to which the plugin should be installed.',
                                    type: 'string',
                                  },
                                  version: {
                                    description: '(String) Version of the plugin to be installed.\nVersion of the plugin to be installed.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  cloudStackRef: {
                                    description: 'Reference to a Stack in cloud to populate stackSlug.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  cloudStackSelector: {
                                    description: 'Selector for a Stack in cloud to populate stackSlug.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  slug: {
                                    description: '(String) Slug of the plugin to be installed.\nSlug of the plugin to be installed.',
                                    type: 'string',
                                  },
                                  stackSlug: {
                                    description: '(String) The stack id to which the plugin should be installed.\nThe stack id to which the plugin should be installed.',
                                    type: 'string',
                                  },
                                  version: {
                                    description: '(String) Version of the plugin to be installed.\nVersion of the plugin to be installed.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.slug is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.slug) || (has(self.initProvider) && has(self.initProvider.slug))",
                              },
                              {
                                message: 'spec.forProvider.version is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.version) || (has(self.initProvider) && has(self.initProvider.version))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      stack: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xstacks.cloud.grafana.crossplane.io.namespaced',
            },
            name: 'stack-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'cloud.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XStack',
            },
            resources: [
              {
                base: {
                  apiVersion: 'cloud.grafana.crossplane.io/v1alpha1',
                  kind: 'Stack',
                },
                name: 'stack',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.description',
                    toFieldPath: 'spec.forProvider.description',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.labels',
                    toFieldPath: 'spec.forProvider.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.regionSlug',
                    toFieldPath: 'spec.forProvider.regionSlug',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.slug',
                    toFieldPath: 'spec.forProvider.slug',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.url',
                    toFieldPath: 'spec.forProvider.url',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.waitForReadiness',
                    toFieldPath: 'spec.forProvider.waitForReadiness',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.waitForReadinessTimeout',
                    toFieldPath: 'spec.forProvider.waitForReadinessTimeout',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.description',
                    toFieldPath: 'spec.initProvider.description',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.labels',
                    toFieldPath: 'spec.initProvider.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.regionSlug',
                    toFieldPath: 'spec.initProvider.regionSlug',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.slug',
                    toFieldPath: 'spec.initProvider.slug',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.url',
                    toFieldPath: 'spec.initProvider.url',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.waitForReadiness',
                    toFieldPath: 'spec.initProvider.waitForReadiness',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.waitForReadinessTimeout',
                    toFieldPath: 'spec.initProvider.waitForReadinessTimeout',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xstacks.cloud.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Stack',
              plural: 'stacks',
            },
            defaultCompositionRef: {
              name: 'stack-namespaced',
            },
            group: 'cloud.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XStack',
              plural: 'xstacks',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'StackSpec defines the desired state of Stack',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  description: {
                                    description: '(String) Description of stack.\nDescription of stack.',
                                    type: 'string',
                                  },
                                  labels: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    description: 'zA-Z0-9/\\-.]+$" and stacks cannot have more than 10 labels.\nA map of labels to assign to the stack. Label keys and values must match the following regexp: "^[a-zA-Z0-9/\\\\-.]+$" and stacks cannot have more than 10 labels.',
                                    type: 'object',
                                    'x-kubernetes-map-type': 'granular',
                                  },
                                  name: {
                                    description: '(String) Name of stack. Conventionally matches the url of the instance (e.g. <stack_slug>.grafana.net).\nName of stack. Conventionally matches the url of the instance (e.g. `<stack_slug>.grafana.net`).',
                                    type: 'string',
                                  },
                                  regionSlug: {
                                    description: 'cloud/developer-resources/api-reference/cloud-api/#list-regions.\nRegion slug to assign to this stack. Changing region will destroy the existing stack and create a new one in the desired region. Use the region list API to get the list of available regions: https://grafana.com/docs/grafana-cloud/developer-resources/api-reference/cloud-api/#list-regions.',
                                    type: 'string',
                                  },
                                  slug: {
                                    description: '(String) Subdomain that the Grafana instance will be available at. Setting slug to <stack_slug> will make the instance available at https://<stack_slug>.grafana.net.\nSubdomain that the Grafana instance will be available at. Setting slug to `<stack_slug>` will make the instance available at `https://<stack_slug>.grafana.net`.',
                                    type: 'string',
                                  },
                                  url: {
                                    description: '(String) Custom URL for the Grafana instance. Must have a CNAME setup to point to .grafana.net before creating the stack\nCustom URL for the Grafana instance. Must have a CNAME setup to point to `.grafana.net` before creating the stack',
                                    type: 'string',
                                  },
                                  waitForReadiness: {
                                    description: '(Boolean) Whether to wait for readiness of the stack after creating it. The check is a HEAD request to the stack URL (Grafana instance). Defaults to true.\nWhether to wait for readiness of the stack after creating it. The check is a HEAD request to the stack URL (Grafana instance). Defaults to `true`.',
                                    type: 'boolean',
                                  },
                                  waitForReadinessTimeout: {
                                    description: '(String) How long to wait for readiness (if enabled). Defaults to 5m0s.\nHow long to wait for readiness (if enabled). Defaults to `5m0s`.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  description: {
                                    description: '(String) Description of stack.\nDescription of stack.',
                                    type: 'string',
                                  },
                                  labels: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    description: 'zA-Z0-9/\\-.]+$" and stacks cannot have more than 10 labels.\nA map of labels to assign to the stack. Label keys and values must match the following regexp: "^[a-zA-Z0-9/\\\\-.]+$" and stacks cannot have more than 10 labels.',
                                    type: 'object',
                                    'x-kubernetes-map-type': 'granular',
                                  },
                                  name: {
                                    description: '(String) Name of stack. Conventionally matches the url of the instance (e.g. <stack_slug>.grafana.net).\nName of stack. Conventionally matches the url of the instance (e.g. `<stack_slug>.grafana.net`).',
                                    type: 'string',
                                  },
                                  regionSlug: {
                                    description: 'cloud/developer-resources/api-reference/cloud-api/#list-regions.\nRegion slug to assign to this stack. Changing region will destroy the existing stack and create a new one in the desired region. Use the region list API to get the list of available regions: https://grafana.com/docs/grafana-cloud/developer-resources/api-reference/cloud-api/#list-regions.',
                                    type: 'string',
                                  },
                                  slug: {
                                    description: '(String) Subdomain that the Grafana instance will be available at. Setting slug to <stack_slug> will make the instance available at https://<stack_slug>.grafana.net.\nSubdomain that the Grafana instance will be available at. Setting slug to `<stack_slug>` will make the instance available at `https://<stack_slug>.grafana.net`.',
                                    type: 'string',
                                  },
                                  url: {
                                    description: '(String) Custom URL for the Grafana instance. Must have a CNAME setup to point to .grafana.net before creating the stack\nCustom URL for the Grafana instance. Must have a CNAME setup to point to `.grafana.net` before creating the stack',
                                    type: 'string',
                                  },
                                  waitForReadiness: {
                                    description: '(Boolean) Whether to wait for readiness of the stack after creating it. The check is a HEAD request to the stack URL (Grafana instance). Defaults to true.\nWhether to wait for readiness of the stack after creating it. The check is a HEAD request to the stack URL (Grafana instance). Defaults to `true`.',
                                    type: 'boolean',
                                  },
                                  waitForReadinessTimeout: {
                                    description: '(String) How long to wait for readiness (if enabled). Defaults to 5m0s.\nHow long to wait for readiness (if enabled). Defaults to `5m0s`.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.slug is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.slug) || (has(self.initProvider) && has(self.initProvider.slug))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      stackServiceAccount: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xstackserviceaccounts.cloud.grafana.crossplane.io.namespaced',
            },
            name: 'stackserviceaccount-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'cloud.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XStackServiceAccount',
            },
            resources: [
              {
                base: {
                  apiVersion: 'cloud.grafana.crossplane.io/v1alpha1',
                  kind: 'StackServiceAccount',
                },
                name: 'stackserviceaccount',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackRef.name',
                    toFieldPath: 'spec.forProvider.cloudStackRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.cloudStackRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.cloudStackRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.isDisabled',
                    toFieldPath: 'spec.forProvider.isDisabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.role',
                    toFieldPath: 'spec.forProvider.role',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.stackSlug',
                    toFieldPath: 'spec.forProvider.stackSlug',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackRef.name',
                    toFieldPath: 'spec.initProvider.cloudStackRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.cloudStackRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.cloudStackRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.isDisabled',
                    toFieldPath: 'spec.initProvider.isDisabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.role',
                    toFieldPath: 'spec.initProvider.role',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.stackSlug',
                    toFieldPath: 'spec.initProvider.stackSlug',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xstackserviceaccounts.cloud.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'StackServiceAccount',
              plural: 'stackserviceaccounts',
            },
            defaultCompositionRef: {
              name: 'stackserviceaccount-namespaced',
            },
            group: 'cloud.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XStackServiceAccount',
              plural: 'xstackserviceaccounts',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'StackServiceAccountSpec defines the desired state of StackServiceAccount',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  cloudStackRef: {
                                    description: 'Reference to a Stack in cloud to populate stackSlug.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  cloudStackSelector: {
                                    description: 'Selector for a Stack in cloud to populate stackSlug.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  isDisabled: {
                                    description: '(Boolean) The disabled status for the service account. Defaults to false.\nThe disabled status for the service account. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  name: {
                                    description: '(String) The name of the service account.\nThe name of the service account.',
                                    type: 'string',
                                  },
                                  role: {
                                    description: '(String) The basic role of the service account in the organization.\nThe basic role of the service account in the organization.',
                                    type: 'string',
                                  },
                                  stackSlug: {
                                    description: '(String)',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  cloudStackRef: {
                                    description: 'Reference to a Stack in cloud to populate stackSlug.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  cloudStackSelector: {
                                    description: 'Selector for a Stack in cloud to populate stackSlug.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  isDisabled: {
                                    description: '(Boolean) The disabled status for the service account. Defaults to false.\nThe disabled status for the service account. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  name: {
                                    description: '(String) The name of the service account.\nThe name of the service account.',
                                    type: 'string',
                                  },
                                  role: {
                                    description: '(String) The basic role of the service account in the organization.\nThe basic role of the service account in the organization.',
                                    type: 'string',
                                  },
                                  stackSlug: {
                                    description: '(String)',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.role is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.role) || (has(self.initProvider) && has(self.initProvider.role))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      stackServiceAccountToken: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xstackserviceaccounttokens.cloud.grafana.crossplane.io.namespaced',
            },
            name: 'stackserviceaccounttoken-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'cloud.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XStackServiceAccountToken',
            },
            resources: [
              {
                base: {
                  apiVersion: 'cloud.grafana.crossplane.io/v1alpha1',
                  kind: 'StackServiceAccountToken',
                },
                name: 'stackserviceaccounttoken',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackRef.name',
                    toFieldPath: 'spec.forProvider.cloudStackRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.cloudStackRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.cloudStackRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.secondsToLive',
                    toFieldPath: 'spec.forProvider.secondsToLive',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountId',
                    toFieldPath: 'spec.forProvider.serviceAccountId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountRef.name',
                    toFieldPath: 'spec.forProvider.serviceAccountRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.serviceAccountRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.serviceAccountRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.stackSlug',
                    toFieldPath: 'spec.forProvider.stackSlug',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackRef.name',
                    toFieldPath: 'spec.initProvider.cloudStackRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.cloudStackRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.cloudStackRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.secondsToLive',
                    toFieldPath: 'spec.initProvider.secondsToLive',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountId',
                    toFieldPath: 'spec.initProvider.serviceAccountId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountRef.name',
                    toFieldPath: 'spec.initProvider.serviceAccountRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.serviceAccountRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.serviceAccountRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.stackSlug',
                    toFieldPath: 'spec.initProvider.stackSlug',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xstackserviceaccounttokens.cloud.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'StackServiceAccountToken',
              plural: 'stackserviceaccounttokens',
            },
            defaultCompositionRef: {
              name: 'stackserviceaccounttoken-namespaced',
            },
            group: 'cloud.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XStackServiceAccountToken',
              plural: 'xstackserviceaccounttokens',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'StackServiceAccountTokenSpec defines the desired state of StackServiceAccountToken',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  cloudStackRef: {
                                    description: 'Reference to a Stack in cloud to populate stackSlug.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  cloudStackSelector: {
                                    description: 'Selector for a Stack in cloud to populate stackSlug.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: '(String)',
                                    type: 'string',
                                  },
                                  secondsToLive: {
                                    description: '(Number)',
                                    type: 'number',
                                  },
                                  serviceAccountId: {
                                    description: '(String)',
                                    type: 'string',
                                  },
                                  serviceAccountRef: {
                                    description: 'Reference to a StackServiceAccount in cloud to populate serviceAccountId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  serviceAccountSelector: {
                                    description: 'Selector for a StackServiceAccount in cloud to populate serviceAccountId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  stackSlug: {
                                    description: '(String)',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  cloudStackRef: {
                                    description: 'Reference to a Stack in cloud to populate stackSlug.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  cloudStackSelector: {
                                    description: 'Selector for a Stack in cloud to populate stackSlug.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: '(String)',
                                    type: 'string',
                                  },
                                  secondsToLive: {
                                    description: '(Number)',
                                    type: 'number',
                                  },
                                  serviceAccountId: {
                                    description: '(String)',
                                    type: 'string',
                                  },
                                  serviceAccountRef: {
                                    description: 'Reference to a StackServiceAccount in cloud to populate serviceAccountId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  serviceAccountSelector: {
                                    description: 'Selector for a StackServiceAccount in cloud to populate serviceAccountId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  stackSlug: {
                                    description: '(String)',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
    },
  },
  enterprise: {
    v1alpha1: {
      dataSourcePermission: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xdatasourcepermissions.enterprise.grafana.crossplane.io.namespaced',
            },
            name: 'datasourcepermission-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'enterprise.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XDataSourcePermission',
            },
            resources: [
              {
                base: {
                  apiVersion: 'enterprise.grafana.crossplane.io/v1alpha1',
                  kind: 'DataSourcePermission',
                },
                name: 'datasourcepermission',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.datasourceUid',
                    toFieldPath: 'spec.forProvider.datasourceUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.permissions',
                    toFieldPath: 'spec.forProvider.permissions',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.datasourceUid',
                    toFieldPath: 'spec.initProvider.datasourceUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.permissions',
                    toFieldPath: 'spec.initProvider.permissions',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xdatasourcepermissions.enterprise.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'DataSourcePermission',
              plural: 'datasourcepermissions',
            },
            defaultCompositionRef: {
              name: 'datasourcepermission-namespaced',
            },
            group: 'enterprise.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XDataSourcePermission',
              plural: 'xdatasourcepermissions',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'DataSourcePermissionSpec defines the desired state of DataSourcePermission',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  datasourceUid: {
                                    description: '(String) UID of the datasource to apply permissions to.\nUID of the datasource to apply permissions to.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  permissions: {
                                    description: '(Block Set) The permission items to add/update. Items that are omitted from the list will be removed. (see below for nested schema)\nThe permission items to add/update. Items that are omitted from the list will be removed.',
                                    items: {
                                      properties: {
                                        builtInRole: {
                                          description: '(String) Name of the basic role to manage permissions for. Options: Viewer, Editor or Admin.\nName of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.',
                                          type: 'string',
                                        },
                                        permission: {
                                          description: '(String) Permission to associate with item. Options: Query, Edit or Admin (Admin can only be used with Grafana v10.3.0+).\nPermission to associate with item. Options: `Query`, `Edit` or `Admin` (`Admin` can only be used with Grafana v10.3.0+).',
                                          type: 'string',
                                        },
                                        teamId: {
                                          description: '(String) ID of the team to manage permissions for. Defaults to 0.\nID of the team to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        teamRef: {
                                          description: 'Reference to a Team in oss to populate teamId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        teamSelector: {
                                          description: 'Selector for a Team in oss to populate teamId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        userId: {
                                          description: '(String) ID of the user or service account to manage permissions for. Defaults to 0.\nID of the user or service account to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        userRef: {
                                          description: 'Reference to a User in oss to populate userId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        userSelector: {
                                          description: 'Selector for a User in oss to populate userId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  datasourceUid: {
                                    description: '(String) UID of the datasource to apply permissions to.\nUID of the datasource to apply permissions to.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  permissions: {
                                    description: '(Block Set) The permission items to add/update. Items that are omitted from the list will be removed. (see below for nested schema)\nThe permission items to add/update. Items that are omitted from the list will be removed.',
                                    items: {
                                      properties: {
                                        builtInRole: {
                                          description: '(String) Name of the basic role to manage permissions for. Options: Viewer, Editor or Admin.\nName of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.',
                                          type: 'string',
                                        },
                                        permission: {
                                          description: '(String) Permission to associate with item. Options: Query, Edit or Admin (Admin can only be used with Grafana v10.3.0+).\nPermission to associate with item. Options: `Query`, `Edit` or `Admin` (`Admin` can only be used with Grafana v10.3.0+).',
                                          type: 'string',
                                        },
                                        teamId: {
                                          description: '(String) ID of the team to manage permissions for. Defaults to 0.\nID of the team to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        teamRef: {
                                          description: 'Reference to a Team in oss to populate teamId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        teamSelector: {
                                          description: 'Selector for a Team in oss to populate teamId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        userId: {
                                          description: '(String) ID of the user or service account to manage permissions for. Defaults to 0.\nID of the user or service account to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        userRef: {
                                          description: 'Reference to a User in oss to populate userId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        userSelector: {
                                          description: 'Selector for a User in oss to populate userId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.datasourceUid is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.datasourceUid) || (has(self.initProvider) && has(self.initProvider.datasourceUid))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      report: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xreports.enterprise.grafana.crossplane.io.namespaced',
            },
            name: 'report-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'enterprise.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XReport',
            },
            resources: [
              {
                base: {
                  apiVersion: 'enterprise.grafana.crossplane.io/v1alpha1',
                  kind: 'Report',
                },
                name: 'report',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboards',
                    toFieldPath: 'spec.forProvider.dashboards',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.formats',
                    toFieldPath: 'spec.forProvider.formats',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.includeDashboardLink',
                    toFieldPath: 'spec.forProvider.includeDashboardLink',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.includeTableCsv',
                    toFieldPath: 'spec.forProvider.includeTableCsv',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.layout',
                    toFieldPath: 'spec.forProvider.layout',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.message',
                    toFieldPath: 'spec.forProvider.message',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orientation',
                    toFieldPath: 'spec.forProvider.orientation',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.recipients',
                    toFieldPath: 'spec.forProvider.recipients',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.replyTo',
                    toFieldPath: 'spec.forProvider.replyTo',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.schedule',
                    toFieldPath: 'spec.forProvider.schedule',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboards',
                    toFieldPath: 'spec.initProvider.dashboards',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.formats',
                    toFieldPath: 'spec.initProvider.formats',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.includeDashboardLink',
                    toFieldPath: 'spec.initProvider.includeDashboardLink',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.includeTableCsv',
                    toFieldPath: 'spec.initProvider.includeTableCsv',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.layout',
                    toFieldPath: 'spec.initProvider.layout',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.message',
                    toFieldPath: 'spec.initProvider.message',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orientation',
                    toFieldPath: 'spec.initProvider.orientation',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.recipients',
                    toFieldPath: 'spec.initProvider.recipients',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.replyTo',
                    toFieldPath: 'spec.initProvider.replyTo',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.schedule',
                    toFieldPath: 'spec.initProvider.schedule',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xreports.enterprise.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Report',
              plural: 'reports',
            },
            defaultCompositionRef: {
              name: 'report-namespaced',
            },
            group: 'enterprise.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XReport',
              plural: 'xreports',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'ReportSpec defines the desired state of Report',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  dashboards: {
                                    description: '(Block List) List of dashboards to render into the report (see below for nested schema)\nList of dashboards to render into the report',
                                    items: {
                                      properties: {
                                        reportVariables: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          description: '(Map of String) Add report variables to the dashboard. Values should be separated by commas.\nAdd report variables to the dashboard. Values should be separated by commas.',
                                          type: 'object',
                                          'x-kubernetes-map-type': 'granular',
                                        },
                                        timeRange: {
                                          description: '(Block List, Max: 1) Time range of the report. (see below for nested schema)\nTime range of the report.',
                                          items: {
                                            properties: {
                                              from: {
                                                description: '(String) Start of the time range.\nStart of the time range.',
                                                type: 'string',
                                              },
                                              to: {
                                                description: '(String) End of the time range.\nEnd of the time range.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        uid: {
                                          description: '(String) Dashboard uid.\nDashboard uid.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  formats: {
                                    description: '(Set of String) Specifies what kind of attachment to generate for the report. Allowed values: pdf, csv, image.\nSpecifies what kind of attachment to generate for the report. Allowed values: `pdf`, `csv`, `image`.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  includeDashboardLink: {
                                    description: '(Boolean) Whether to include a link to the dashboard in the report. Defaults to true.\nWhether to include a link to the dashboard in the report. Defaults to `true`.',
                                    type: 'boolean',
                                  },
                                  includeTableCsv: {
                                    description: '(Boolean) Whether to include a CSV file of table panel data. Defaults to false.\nWhether to include a CSV file of table panel data. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  layout: {
                                    description: '(String) Layout of the report. Allowed values: simple, grid. Defaults to grid.\nLayout of the report. Allowed values: `simple`, `grid`. Defaults to `grid`.',
                                    type: 'string',
                                  },
                                  message: {
                                    description: '(String) Message to be sent in the report.\nMessage to be sent in the report.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: '(String) Name of the report.\nName of the report.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  orientation: {
                                    description: '(String) Orientation of the report. Allowed values: landscape, portrait. Defaults to landscape.\nOrientation of the report. Allowed values: `landscape`, `portrait`. Defaults to `landscape`.',
                                    type: 'string',
                                  },
                                  recipients: {
                                    description: '(List of String) List of recipients of the report.\nList of recipients of the report.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                  },
                                  replyTo: {
                                    description: 'to email address of the report.\nReply-to email address of the report.',
                                    type: 'string',
                                  },
                                  schedule: {
                                    description: '(Block List, Min: 1, Max: 1) Schedule of the report. (see below for nested schema)\nSchedule of the report.',
                                    items: {
                                      properties: {
                                        customInterval: {
                                          description: '(String) Custom interval of the report.\nNote: This field is only available when frequency is set to custom.\nCustom interval of the report.\n**Note:** This field is only available when frequency is set to `custom`.',
                                          type: 'string',
                                        },
                                        endTime: {
                                          description: '01-02T15:04:05 format if you want to set a custom timezone\nEnd time of the report. If empty, the report will be sent indefinitely (according to frequency). Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone',
                                          type: 'string',
                                        },
                                        frequency: {
                                          description: '(String) Frequency of the report. Allowed values: never, once, hourly, daily, weekly, monthly, custom.\nFrequency of the report. Allowed values: `never`, `once`, `hourly`, `daily`, `weekly`, `monthly`, `custom`.',
                                          type: 'string',
                                        },
                                        lastDayOfMonth: {
                                          description: '(Boolean) Send the report on the last day of the month Defaults to false.\nSend the report on the last day of the month Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        startTime: {
                                          description: '01-02T15:04:05 format if you want to set a custom timezone\nStart time of the report. If empty, the start date will be set to the creation time. Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone',
                                          type: 'string',
                                        },
                                        timezone: {
                                          description: '(String) Set the report time zone. Defaults to GMT.\nSet the report time zone. Defaults to `GMT`.',
                                          type: 'string',
                                        },
                                        workdaysOnly: {
                                          description: '(Boolean) Whether to send the report only on work days. Defaults to false.\nWhether to send the report only on work days. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  dashboards: {
                                    description: '(Block List) List of dashboards to render into the report (see below for nested schema)\nList of dashboards to render into the report',
                                    items: {
                                      properties: {
                                        reportVariables: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          description: '(Map of String) Add report variables to the dashboard. Values should be separated by commas.\nAdd report variables to the dashboard. Values should be separated by commas.',
                                          type: 'object',
                                          'x-kubernetes-map-type': 'granular',
                                        },
                                        timeRange: {
                                          description: '(Block List, Max: 1) Time range of the report. (see below for nested schema)\nTime range of the report.',
                                          items: {
                                            properties: {
                                              from: {
                                                description: '(String) Start of the time range.\nStart of the time range.',
                                                type: 'string',
                                              },
                                              to: {
                                                description: '(String) End of the time range.\nEnd of the time range.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        uid: {
                                          description: '(String) Dashboard uid.\nDashboard uid.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  formats: {
                                    description: '(Set of String) Specifies what kind of attachment to generate for the report. Allowed values: pdf, csv, image.\nSpecifies what kind of attachment to generate for the report. Allowed values: `pdf`, `csv`, `image`.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  includeDashboardLink: {
                                    description: '(Boolean) Whether to include a link to the dashboard in the report. Defaults to true.\nWhether to include a link to the dashboard in the report. Defaults to `true`.',
                                    type: 'boolean',
                                  },
                                  includeTableCsv: {
                                    description: '(Boolean) Whether to include a CSV file of table panel data. Defaults to false.\nWhether to include a CSV file of table panel data. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  layout: {
                                    description: '(String) Layout of the report. Allowed values: simple, grid. Defaults to grid.\nLayout of the report. Allowed values: `simple`, `grid`. Defaults to `grid`.',
                                    type: 'string',
                                  },
                                  message: {
                                    description: '(String) Message to be sent in the report.\nMessage to be sent in the report.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: '(String) Name of the report.\nName of the report.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  orientation: {
                                    description: '(String) Orientation of the report. Allowed values: landscape, portrait. Defaults to landscape.\nOrientation of the report. Allowed values: `landscape`, `portrait`. Defaults to `landscape`.',
                                    type: 'string',
                                  },
                                  recipients: {
                                    description: '(List of String) List of recipients of the report.\nList of recipients of the report.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                  },
                                  replyTo: {
                                    description: 'to email address of the report.\nReply-to email address of the report.',
                                    type: 'string',
                                  },
                                  schedule: {
                                    description: '(Block List, Min: 1, Max: 1) Schedule of the report. (see below for nested schema)\nSchedule of the report.',
                                    items: {
                                      properties: {
                                        customInterval: {
                                          description: '(String) Custom interval of the report.\nNote: This field is only available when frequency is set to custom.\nCustom interval of the report.\n**Note:** This field is only available when frequency is set to `custom`.',
                                          type: 'string',
                                        },
                                        endTime: {
                                          description: '01-02T15:04:05 format if you want to set a custom timezone\nEnd time of the report. If empty, the report will be sent indefinitely (according to frequency). Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone',
                                          type: 'string',
                                        },
                                        frequency: {
                                          description: '(String) Frequency of the report. Allowed values: never, once, hourly, daily, weekly, monthly, custom.\nFrequency of the report. Allowed values: `never`, `once`, `hourly`, `daily`, `weekly`, `monthly`, `custom`.',
                                          type: 'string',
                                        },
                                        lastDayOfMonth: {
                                          description: '(Boolean) Send the report on the last day of the month Defaults to false.\nSend the report on the last day of the month Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                        startTime: {
                                          description: '01-02T15:04:05 format if you want to set a custom timezone\nStart time of the report. If empty, the start date will be set to the creation time. Note that times will be saved as UTC in Grafana. Use 2006-01-02T15:04:05 format if you want to set a custom timezone',
                                          type: 'string',
                                        },
                                        timezone: {
                                          description: '(String) Set the report time zone. Defaults to GMT.\nSet the report time zone. Defaults to `GMT`.',
                                          type: 'string',
                                        },
                                        workdaysOnly: {
                                          description: '(Boolean) Whether to send the report only on work days. Defaults to false.\nWhether to send the report only on work days. Defaults to `false`.',
                                          type: 'boolean',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.recipients is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.recipients) || (has(self.initProvider) && has(self.initProvider.recipients))",
                              },
                              {
                                message: 'spec.forProvider.schedule is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.schedule) || (has(self.initProvider) && has(self.initProvider.schedule))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      role: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xroles.enterprise.grafana.crossplane.io.namespaced',
            },
            name: 'role-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'enterprise.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XRole',
            },
            resources: [
              {
                base: {
                  apiVersion: 'enterprise.grafana.crossplane.io/v1alpha1',
                  kind: 'Role',
                },
                name: 'role',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.autoIncrementVersion',
                    toFieldPath: 'spec.forProvider.autoIncrementVersion',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.description',
                    toFieldPath: 'spec.forProvider.description',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.displayName',
                    toFieldPath: 'spec.forProvider.displayName',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.global',
                    toFieldPath: 'spec.forProvider.global',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.group',
                    toFieldPath: 'spec.forProvider.group',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.hidden',
                    toFieldPath: 'spec.forProvider.hidden',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.permissions',
                    toFieldPath: 'spec.forProvider.permissions',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.uid',
                    toFieldPath: 'spec.forProvider.uid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.version',
                    toFieldPath: 'spec.forProvider.version',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.autoIncrementVersion',
                    toFieldPath: 'spec.initProvider.autoIncrementVersion',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.description',
                    toFieldPath: 'spec.initProvider.description',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.displayName',
                    toFieldPath: 'spec.initProvider.displayName',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.global',
                    toFieldPath: 'spec.initProvider.global',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.group',
                    toFieldPath: 'spec.initProvider.group',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.hidden',
                    toFieldPath: 'spec.initProvider.hidden',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.permissions',
                    toFieldPath: 'spec.initProvider.permissions',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.uid',
                    toFieldPath: 'spec.initProvider.uid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.version',
                    toFieldPath: 'spec.initProvider.version',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xroles.enterprise.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Role',
              plural: 'roles',
            },
            defaultCompositionRef: {
              name: 'role-namespaced',
            },
            group: 'enterprise.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XRole',
              plural: 'xroles',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'RoleSpec defines the desired state of Role',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  autoIncrementVersion: {
                                    description: '(Boolean) Whether the role version should be incremented automatically on updates (and set to 1 on creation). This field or version should be set.\nWhether the role version should be incremented automatically on updates (and set to 1 on creation). This field or `version` should be set.',
                                    type: 'boolean',
                                  },
                                  description: {
                                    description: '(String) Description of the role.\nDescription of the role.',
                                    type: 'string',
                                  },
                                  displayName: {
                                    description: '(String) Display name of the role. Available with Grafana 8.5+.\nDisplay name of the role. Available with Grafana 8.5+.',
                                    type: 'string',
                                  },
                                  global: {
                                    description: '(Boolean) Boolean to state whether the role is available across all organizations or not. Defaults to false.\nBoolean to state whether the role is available across all organizations or not. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  group: {
                                    description: '(String) Group of the role. Available with Grafana 8.5+.\nGroup of the role. Available with Grafana 8.5+.',
                                    type: 'string',
                                  },
                                  hidden: {
                                    description: '(Boolean) Boolean to state whether the role should be visible in the Grafana UI or not. Available with Grafana 8.5+. Defaults to false.\nBoolean to state whether the role should be visible in the Grafana UI or not. Available with Grafana 8.5+. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  name: {
                                    description: '(String) Name of the role\nName of the role',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  permissions: {
                                    description: '(Block Set) Specific set of actions granted by the role. (see below for nested schema)\nSpecific set of actions granted by the role.',
                                    items: {
                                      properties: {
                                        action: {
                                          description: '(String) Specific action users granted with the role will be allowed to perform (for example: users:read)\nSpecific action users granted with the role will be allowed to perform (for example: `users:read`)',
                                          type: 'string',
                                        },
                                        scope: {
                                          description: '(String) Scope to restrict the action to a set of resources (for example: users:* or roles:customrole1) Defaults to “.\nScope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`) Defaults to “.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  uid: {
                                    description: '(String) Unique identifier of the role. Used for assignments.\nUnique identifier of the role. Used for assignments.',
                                    type: 'string',
                                  },
                                  version: {
                                    description: '(Number) Version of the role. A role is updated only on version increase. This field or auto_increment_version should be set.\nVersion of the role. A role is updated only on version increase. This field or `auto_increment_version` should be set.',
                                    type: 'number',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  autoIncrementVersion: {
                                    description: '(Boolean) Whether the role version should be incremented automatically on updates (and set to 1 on creation). This field or version should be set.\nWhether the role version should be incremented automatically on updates (and set to 1 on creation). This field or `version` should be set.',
                                    type: 'boolean',
                                  },
                                  description: {
                                    description: '(String) Description of the role.\nDescription of the role.',
                                    type: 'string',
                                  },
                                  displayName: {
                                    description: '(String) Display name of the role. Available with Grafana 8.5+.\nDisplay name of the role. Available with Grafana 8.5+.',
                                    type: 'string',
                                  },
                                  global: {
                                    description: '(Boolean) Boolean to state whether the role is available across all organizations or not. Defaults to false.\nBoolean to state whether the role is available across all organizations or not. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  group: {
                                    description: '(String) Group of the role. Available with Grafana 8.5+.\nGroup of the role. Available with Grafana 8.5+.',
                                    type: 'string',
                                  },
                                  hidden: {
                                    description: '(Boolean) Boolean to state whether the role should be visible in the Grafana UI or not. Available with Grafana 8.5+. Defaults to false.\nBoolean to state whether the role should be visible in the Grafana UI or not. Available with Grafana 8.5+. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  name: {
                                    description: '(String) Name of the role\nName of the role',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  permissions: {
                                    description: '(Block Set) Specific set of actions granted by the role. (see below for nested schema)\nSpecific set of actions granted by the role.',
                                    items: {
                                      properties: {
                                        action: {
                                          description: '(String) Specific action users granted with the role will be allowed to perform (for example: users:read)\nSpecific action users granted with the role will be allowed to perform (for example: `users:read`)',
                                          type: 'string',
                                        },
                                        scope: {
                                          description: '(String) Scope to restrict the action to a set of resources (for example: users:* or roles:customrole1) Defaults to “.\nScope to restrict the action to a set of resources (for example: `users:*` or `roles:customrole1`) Defaults to “.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  uid: {
                                    description: '(String) Unique identifier of the role. Used for assignments.\nUnique identifier of the role. Used for assignments.',
                                    type: 'string',
                                  },
                                  version: {
                                    description: '(Number) Version of the role. A role is updated only on version increase. This field or auto_increment_version should be set.\nVersion of the role. A role is updated only on version increase. This field or `auto_increment_version` should be set.',
                                    type: 'number',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      roleAssignment: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xroleassignments.enterprise.grafana.crossplane.io.namespaced',
            },
            name: 'roleassignment-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'enterprise.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XRoleAssignment',
            },
            resources: [
              {
                base: {
                  apiVersion: 'enterprise.grafana.crossplane.io/v1alpha1',
                  kind: 'RoleAssignment',
                },
                name: 'roleassignment',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.roleRef.name',
                    toFieldPath: 'spec.forProvider.roleRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.roleRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.roleRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.roleRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.roleRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.roleSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.roleSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.roleSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.roleSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.roleSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.roleSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.roleSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.roleSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.roleUid',
                    toFieldPath: 'spec.forProvider.roleUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountRefs',
                    toFieldPath: 'spec.forProvider.serviceAccountRefs',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccounts',
                    toFieldPath: 'spec.forProvider.serviceAccounts',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamRefs',
                    toFieldPath: 'spec.forProvider.teamRefs',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.teamSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.teamSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.teamSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.teamSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teams',
                    toFieldPath: 'spec.forProvider.teams',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.userRefs',
                    toFieldPath: 'spec.forProvider.userRefs',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.userSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.userSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.userSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.userSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.userSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.userSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.userSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.userSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.users',
                    toFieldPath: 'spec.forProvider.users',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.roleRef.name',
                    toFieldPath: 'spec.initProvider.roleRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.roleRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.roleRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.roleRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.roleRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.roleSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.roleSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.roleSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.roleSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.roleSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.roleSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.roleSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.roleSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.roleUid',
                    toFieldPath: 'spec.initProvider.roleUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountRefs',
                    toFieldPath: 'spec.initProvider.serviceAccountRefs',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccounts',
                    toFieldPath: 'spec.initProvider.serviceAccounts',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamRefs',
                    toFieldPath: 'spec.initProvider.teamRefs',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.teamSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.teamSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.teamSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.teamSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teams',
                    toFieldPath: 'spec.initProvider.teams',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.userRefs',
                    toFieldPath: 'spec.initProvider.userRefs',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.userSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.userSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.userSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.userSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.userSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.userSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.userSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.userSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.users',
                    toFieldPath: 'spec.initProvider.users',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xroleassignments.enterprise.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'RoleAssignment',
              plural: 'roleassignments',
            },
            defaultCompositionRef: {
              name: 'roleassignment-namespaced',
            },
            group: 'enterprise.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XRoleAssignment',
              plural: 'xroleassignments',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'RoleAssignmentSpec defines the desired state of RoleAssignment',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  roleRef: {
                                    description: 'Reference to a Role in enterprise to populate roleUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  roleSelector: {
                                    description: 'Selector for a Role in enterprise to populate roleUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  roleUid: {
                                    description: '(String) Grafana RBAC role UID.\nGrafana RBAC role UID.',
                                    type: 'string',
                                  },
                                  serviceAccountRefs: {
                                    description: 'References to ServiceAccount in oss to populate serviceAccounts.',
                                    items: {
                                      description: 'A Reference to a named object.',
                                      properties: {
                                        name: {
                                          description: 'Name of the referenced object.',
                                          type: 'string',
                                        },
                                        policy: {
                                          description: 'Policies for referencing.',
                                          properties: {
                                            resolution: {
                                              default: 'Required',
                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                              enum: [
                                                'Required',
                                                'Optional',
                                              ],
                                              type: 'string',
                                            },
                                            resolve: {
                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                              enum: [
                                                'Always',
                                                'IfNotPresent',
                                              ],
                                              type: 'string',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'name',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  serviceAccountSelector: {
                                    description: 'Selector for a list of ServiceAccount in oss to populate serviceAccounts.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  serviceAccounts: {
                                    description: '(Set of String) IDs of service accounts that the role should be assigned to.\nIDs of service accounts that the role should be assigned to.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  teamRefs: {
                                    description: 'References to Team in oss to populate teams.',
                                    items: {
                                      description: 'A Reference to a named object.',
                                      properties: {
                                        name: {
                                          description: 'Name of the referenced object.',
                                          type: 'string',
                                        },
                                        policy: {
                                          description: 'Policies for referencing.',
                                          properties: {
                                            resolution: {
                                              default: 'Required',
                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                              enum: [
                                                'Required',
                                                'Optional',
                                              ],
                                              type: 'string',
                                            },
                                            resolve: {
                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                              enum: [
                                                'Always',
                                                'IfNotPresent',
                                              ],
                                              type: 'string',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'name',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  teamSelector: {
                                    description: 'Selector for a list of Team in oss to populate teams.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  teams: {
                                    description: '(Set of String) IDs of teams that the role should be assigned to.\nIDs of teams that the role should be assigned to.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  userRefs: {
                                    description: 'References to User in oss to populate users.',
                                    items: {
                                      description: 'A Reference to a named object.',
                                      properties: {
                                        name: {
                                          description: 'Name of the referenced object.',
                                          type: 'string',
                                        },
                                        policy: {
                                          description: 'Policies for referencing.',
                                          properties: {
                                            resolution: {
                                              default: 'Required',
                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                              enum: [
                                                'Required',
                                                'Optional',
                                              ],
                                              type: 'string',
                                            },
                                            resolve: {
                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                              enum: [
                                                'Always',
                                                'IfNotPresent',
                                              ],
                                              type: 'string',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'name',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  userSelector: {
                                    description: 'Selector for a list of User in oss to populate users.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  users: {
                                    description: '(Set of Number) IDs of users that the role should be assigned to.\nIDs of users that the role should be assigned to.',
                                    items: {
                                      type: 'number',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  roleRef: {
                                    description: 'Reference to a Role in enterprise to populate roleUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  roleSelector: {
                                    description: 'Selector for a Role in enterprise to populate roleUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  roleUid: {
                                    description: '(String) Grafana RBAC role UID.\nGrafana RBAC role UID.',
                                    type: 'string',
                                  },
                                  serviceAccountRefs: {
                                    description: 'References to ServiceAccount in oss to populate serviceAccounts.',
                                    items: {
                                      description: 'A Reference to a named object.',
                                      properties: {
                                        name: {
                                          description: 'Name of the referenced object.',
                                          type: 'string',
                                        },
                                        policy: {
                                          description: 'Policies for referencing.',
                                          properties: {
                                            resolution: {
                                              default: 'Required',
                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                              enum: [
                                                'Required',
                                                'Optional',
                                              ],
                                              type: 'string',
                                            },
                                            resolve: {
                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                              enum: [
                                                'Always',
                                                'IfNotPresent',
                                              ],
                                              type: 'string',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'name',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  serviceAccountSelector: {
                                    description: 'Selector for a list of ServiceAccount in oss to populate serviceAccounts.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  serviceAccounts: {
                                    description: '(Set of String) IDs of service accounts that the role should be assigned to.\nIDs of service accounts that the role should be assigned to.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  teamRefs: {
                                    description: 'References to Team in oss to populate teams.',
                                    items: {
                                      description: 'A Reference to a named object.',
                                      properties: {
                                        name: {
                                          description: 'Name of the referenced object.',
                                          type: 'string',
                                        },
                                        policy: {
                                          description: 'Policies for referencing.',
                                          properties: {
                                            resolution: {
                                              default: 'Required',
                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                              enum: [
                                                'Required',
                                                'Optional',
                                              ],
                                              type: 'string',
                                            },
                                            resolve: {
                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                              enum: [
                                                'Always',
                                                'IfNotPresent',
                                              ],
                                              type: 'string',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'name',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  teamSelector: {
                                    description: 'Selector for a list of Team in oss to populate teams.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  teams: {
                                    description: '(Set of String) IDs of teams that the role should be assigned to.\nIDs of teams that the role should be assigned to.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  userRefs: {
                                    description: 'References to User in oss to populate users.',
                                    items: {
                                      description: 'A Reference to a named object.',
                                      properties: {
                                        name: {
                                          description: 'Name of the referenced object.',
                                          type: 'string',
                                        },
                                        policy: {
                                          description: 'Policies for referencing.',
                                          properties: {
                                            resolution: {
                                              default: 'Required',
                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                              enum: [
                                                'Required',
                                                'Optional',
                                              ],
                                              type: 'string',
                                            },
                                            resolve: {
                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                              enum: [
                                                'Always',
                                                'IfNotPresent',
                                              ],
                                              type: 'string',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'name',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  userSelector: {
                                    description: 'Selector for a list of User in oss to populate users.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  users: {
                                    description: '(Set of Number) IDs of users that the role should be assigned to.\nIDs of users that the role should be assigned to.',
                                    items: {
                                      type: 'number',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      teamExternalGroup: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xteamexternalgroups.enterprise.grafana.crossplane.io.namespaced',
            },
            name: 'teamexternalgroup-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'enterprise.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XTeamExternalGroup',
            },
            resources: [
              {
                base: {
                  apiVersion: 'enterprise.grafana.crossplane.io/v1alpha1',
                  kind: 'TeamExternalGroup',
                },
                name: 'teamexternalgroup',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.groups',
                    toFieldPath: 'spec.forProvider.groups',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamId',
                    toFieldPath: 'spec.forProvider.teamId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamRef.name',
                    toFieldPath: 'spec.forProvider.teamRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.teamRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.teamRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.teamSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.teamSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.teamSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.teamSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.groups',
                    toFieldPath: 'spec.initProvider.groups',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamId',
                    toFieldPath: 'spec.initProvider.teamId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamRef.name',
                    toFieldPath: 'spec.initProvider.teamRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.teamRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.teamRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.teamSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.teamSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.teamSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.teamSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xteamexternalgroups.enterprise.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'TeamExternalGroup',
              plural: 'teamexternalgroups',
            },
            defaultCompositionRef: {
              name: 'teamexternalgroup-namespaced',
            },
            group: 'enterprise.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XTeamExternalGroup',
              plural: 'xteamexternalgroups',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'TeamExternalGroupSpec defines the desired state of TeamExternalGroup',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  groups: {
                                    description: '(Set of String) The team external groups list\nThe team external groups list',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  teamId: {
                                    description: '(String) The Team ID\nThe Team ID',
                                    type: 'string',
                                  },
                                  teamRef: {
                                    description: 'Reference to a Team in oss to populate teamId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  teamSelector: {
                                    description: 'Selector for a Team in oss to populate teamId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  groups: {
                                    description: '(Set of String) The team external groups list\nThe team external groups list',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  teamId: {
                                    description: '(String) The Team ID\nThe Team ID',
                                    type: 'string',
                                  },
                                  teamRef: {
                                    description: 'Reference to a Team in oss to populate teamId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  teamSelector: {
                                    description: 'Selector for a Team in oss to populate teamId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.groups is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.groups) || (has(self.initProvider) && has(self.initProvider.groups))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
    },
  },
  ml: {
    v1alpha1: {
      holiday: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xholidays.ml.grafana.crossplane.io.namespaced',
            },
            name: 'holiday-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'ml.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XHoliday',
            },
            resources: [
              {
                base: {
                  apiVersion: 'ml.grafana.crossplane.io/v1alpha1',
                  kind: 'Holiday',
                },
                name: 'holiday',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.customPeriods',
                    toFieldPath: 'spec.forProvider.customPeriods',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.description',
                    toFieldPath: 'spec.forProvider.description',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.icalTimezone',
                    toFieldPath: 'spec.forProvider.icalTimezone',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.icalUrl',
                    toFieldPath: 'spec.forProvider.icalUrl',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.customPeriods',
                    toFieldPath: 'spec.initProvider.customPeriods',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.description',
                    toFieldPath: 'spec.initProvider.description',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.icalTimezone',
                    toFieldPath: 'spec.initProvider.icalTimezone',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.icalUrl',
                    toFieldPath: 'spec.initProvider.icalUrl',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xholidays.ml.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Holiday',
              plural: 'holidays',
            },
            defaultCompositionRef: {
              name: 'holiday-namespaced',
            },
            group: 'ml.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XHoliday',
              plural: 'xholidays',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'HolidaySpec defines the desired state of Holiday',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  customPeriods: {
                                    description: 'A list of custom periods for the holiday.',
                                    items: {
                                      properties: {
                                        endTime: {
                                          type: 'string',
                                        },
                                        name: {
                                          description: 'The name of the custom period.',
                                          type: 'string',
                                        },
                                        startTime: {
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  description: {
                                    description: 'A description of the holiday.',
                                    type: 'string',
                                  },
                                  icalTimezone: {
                                    description: 'The timezone to use for events in the iCal file pointed to by ical_url.',
                                    type: 'string',
                                  },
                                  icalUrl: {
                                    description: 'A URL to an iCal file containing all occurrences of the holiday.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: 'The name of the holiday.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  customPeriods: {
                                    description: 'A list of custom periods for the holiday.',
                                    items: {
                                      properties: {
                                        endTime: {
                                          type: 'string',
                                        },
                                        name: {
                                          description: 'The name of the custom period.',
                                          type: 'string',
                                        },
                                        startTime: {
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  description: {
                                    description: 'A description of the holiday.',
                                    type: 'string',
                                  },
                                  icalTimezone: {
                                    description: 'The timezone to use for events in the iCal file pointed to by ical_url.',
                                    type: 'string',
                                  },
                                  icalUrl: {
                                    description: 'A URL to an iCal file containing all occurrences of the holiday.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: 'The name of the holiday.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      job: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xjobs.ml.grafana.crossplane.io.namespaced',
            },
            name: 'job-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'ml.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XJob',
            },
            resources: [
              {
                base: {
                  apiVersion: 'ml.grafana.crossplane.io/v1alpha1',
                  kind: 'Job',
                },
                name: 'job',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.customLabels',
                    toFieldPath: 'spec.forProvider.customLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dataSourceRef.name',
                    toFieldPath: 'spec.forProvider.dataSourceRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dataSourceRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.dataSourceRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dataSourceRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.dataSourceRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dataSourceSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.dataSourceSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dataSourceSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.dataSourceSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dataSourceSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.dataSourceSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dataSourceSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.dataSourceSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.datasourceType',
                    toFieldPath: 'spec.forProvider.datasourceType',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.datasourceUid',
                    toFieldPath: 'spec.forProvider.datasourceUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.description',
                    toFieldPath: 'spec.forProvider.description',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.holidays',
                    toFieldPath: 'spec.forProvider.holidays',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.hyperParams',
                    toFieldPath: 'spec.forProvider.hyperParams',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.interval',
                    toFieldPath: 'spec.forProvider.interval',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.metric',
                    toFieldPath: 'spec.forProvider.metric',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.queryParams',
                    toFieldPath: 'spec.forProvider.queryParams',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.trainingWindow',
                    toFieldPath: 'spec.forProvider.trainingWindow',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.customLabels',
                    toFieldPath: 'spec.initProvider.customLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dataSourceRef.name',
                    toFieldPath: 'spec.initProvider.dataSourceRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dataSourceRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.dataSourceRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dataSourceRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.dataSourceRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dataSourceSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.dataSourceSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dataSourceSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.dataSourceSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dataSourceSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.dataSourceSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dataSourceSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.dataSourceSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.datasourceType',
                    toFieldPath: 'spec.initProvider.datasourceType',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.datasourceUid',
                    toFieldPath: 'spec.initProvider.datasourceUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.description',
                    toFieldPath: 'spec.initProvider.description',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.holidays',
                    toFieldPath: 'spec.initProvider.holidays',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.hyperParams',
                    toFieldPath: 'spec.initProvider.hyperParams',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.interval',
                    toFieldPath: 'spec.initProvider.interval',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.metric',
                    toFieldPath: 'spec.initProvider.metric',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.queryParams',
                    toFieldPath: 'spec.initProvider.queryParams',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.trainingWindow',
                    toFieldPath: 'spec.initProvider.trainingWindow',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xjobs.ml.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Job',
              plural: 'jobs',
            },
            defaultCompositionRef: {
              name: 'job-namespaced',
            },
            group: 'ml.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XJob',
              plural: 'xjobs',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'JobSpec defines the desired state of Job',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  customLabels: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    description: 'An object representing the custom labels added on the forecast.',
                                    type: 'object',
                                    'x-kubernetes-map-type': 'granular',
                                  },
                                  dataSourceRef: {
                                    description: 'Reference to a DataSource in oss to populate datasourceUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  dataSourceSelector: {
                                    description: 'Selector for a DataSource in oss to populate datasourceUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  datasourceType: {
                                    description: 'The type of datasource being queried. Currently allowed values are prometheus, graphite, loki, postgres, and datadog.',
                                    type: 'string',
                                  },
                                  datasourceUid: {
                                    description: 'The uid of the datasource to query.',
                                    type: 'string',
                                  },
                                  description: {
                                    description: 'A description of the job.',
                                    type: 'string',
                                  },
                                  holidays: {
                                    description: 'A list of holiday IDs or names to take into account when training the model.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                  },
                                  hyperParams: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    description: 'The hyperparameters used to fine tune the algorithm. See https://grafana.com/docs/grafana-cloud/machine-learning/models/ for the full list of available hyperparameters. Defaults to `map[]`.',
                                    type: 'object',
                                    'x-kubernetes-map-type': 'granular',
                                  },
                                  interval: {
                                    description: 'The data interval in seconds to train the data on. Defaults to `300`.',
                                    type: 'number',
                                  },
                                  metric: {
                                    description: 'The metric used to query the job results.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: 'The name of the job.',
                                    type: 'string',
                                  },
                                  queryParams: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    description: 'An object representing the query params to query Grafana with.',
                                    type: 'object',
                                    'x-kubernetes-map-type': 'granular',
                                  },
                                  trainingWindow: {
                                    description: 'The data interval in seconds to train the data on. Defaults to `7776000`.',
                                    type: 'number',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  customLabels: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    description: 'An object representing the custom labels added on the forecast.',
                                    type: 'object',
                                    'x-kubernetes-map-type': 'granular',
                                  },
                                  dataSourceRef: {
                                    description: 'Reference to a DataSource in oss to populate datasourceUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  dataSourceSelector: {
                                    description: 'Selector for a DataSource in oss to populate datasourceUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  datasourceType: {
                                    description: 'The type of datasource being queried. Currently allowed values are prometheus, graphite, loki, postgres, and datadog.',
                                    type: 'string',
                                  },
                                  datasourceUid: {
                                    description: 'The uid of the datasource to query.',
                                    type: 'string',
                                  },
                                  description: {
                                    description: 'A description of the job.',
                                    type: 'string',
                                  },
                                  holidays: {
                                    description: 'A list of holiday IDs or names to take into account when training the model.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                  },
                                  hyperParams: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    description: 'The hyperparameters used to fine tune the algorithm. See https://grafana.com/docs/grafana-cloud/machine-learning/models/ for the full list of available hyperparameters. Defaults to `map[]`.',
                                    type: 'object',
                                    'x-kubernetes-map-type': 'granular',
                                  },
                                  interval: {
                                    description: 'The data interval in seconds to train the data on. Defaults to `300`.',
                                    type: 'number',
                                  },
                                  metric: {
                                    description: 'The metric used to query the job results.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: 'The name of the job.',
                                    type: 'string',
                                  },
                                  queryParams: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    description: 'An object representing the query params to query Grafana with.',
                                    type: 'object',
                                    'x-kubernetes-map-type': 'granular',
                                  },
                                  trainingWindow: {
                                    description: 'The data interval in seconds to train the data on. Defaults to `7776000`.',
                                    type: 'number',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.datasourceType is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.datasourceType) || (has(self.initProvider) && has(self.initProvider.datasourceType))",
                              },
                              {
                                message: 'spec.forProvider.metric is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.metric) || (has(self.initProvider) && has(self.initProvider.metric))",
                              },
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.queryParams is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.queryParams) || (has(self.initProvider) && has(self.initProvider.queryParams))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      outlierDetector: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xoutlierdetectors.ml.grafana.crossplane.io.namespaced',
            },
            name: 'outlierdetector-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'ml.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XOutlierDetector',
            },
            resources: [
              {
                base: {
                  apiVersion: 'ml.grafana.crossplane.io/v1alpha1',
                  kind: 'OutlierDetector',
                },
                name: 'outlierdetector',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.algorithm',
                    toFieldPath: 'spec.forProvider.algorithm',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dataSourceRef.name',
                    toFieldPath: 'spec.forProvider.dataSourceRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dataSourceRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.dataSourceRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dataSourceRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.dataSourceRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dataSourceSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.dataSourceSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dataSourceSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.dataSourceSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dataSourceSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.dataSourceSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dataSourceSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.dataSourceSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.datasourceType',
                    toFieldPath: 'spec.forProvider.datasourceType',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.datasourceUid',
                    toFieldPath: 'spec.forProvider.datasourceUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.description',
                    toFieldPath: 'spec.forProvider.description',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.interval',
                    toFieldPath: 'spec.forProvider.interval',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.metric',
                    toFieldPath: 'spec.forProvider.metric',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.queryParams',
                    toFieldPath: 'spec.forProvider.queryParams',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.algorithm',
                    toFieldPath: 'spec.initProvider.algorithm',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dataSourceRef.name',
                    toFieldPath: 'spec.initProvider.dataSourceRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dataSourceRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.dataSourceRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dataSourceRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.dataSourceRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dataSourceSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.dataSourceSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dataSourceSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.dataSourceSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dataSourceSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.dataSourceSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dataSourceSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.dataSourceSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.datasourceType',
                    toFieldPath: 'spec.initProvider.datasourceType',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.datasourceUid',
                    toFieldPath: 'spec.initProvider.datasourceUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.description',
                    toFieldPath: 'spec.initProvider.description',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.interval',
                    toFieldPath: 'spec.initProvider.interval',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.metric',
                    toFieldPath: 'spec.initProvider.metric',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.queryParams',
                    toFieldPath: 'spec.initProvider.queryParams',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xoutlierdetectors.ml.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'OutlierDetector',
              plural: 'outlierdetectors',
            },
            defaultCompositionRef: {
              name: 'outlierdetector-namespaced',
            },
            group: 'ml.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XOutlierDetector',
              plural: 'xoutlierdetectors',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'OutlierDetectorSpec defines the desired state of OutlierDetector',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  algorithm: {
                                    description: 'The algorithm to use and its configuration. See https://grafana.com/docs/grafana-cloud/machine-learning/outlier-detection/ for details.',
                                    items: {
                                      properties: {
                                        config: {
                                          description: 'For DBSCAN only, specify the configuration map',
                                          items: {
                                            properties: {
                                              epsilon: {
                                                description: 'Specify the epsilon parameter (positive float)',
                                                type: 'number',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        name: {
                                          description: "The name of the algorithm to use ('mad' or 'dbscan').",
                                          type: 'string',
                                        },
                                        sensitivity: {
                                          description: 'Specify the sensitivity of the detector (in range [0,1]).',
                                          type: 'number',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  dataSourceRef: {
                                    description: 'Reference to a DataSource in oss to populate datasourceUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  dataSourceSelector: {
                                    description: 'Selector for a DataSource in oss to populate datasourceUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  datasourceType: {
                                    description: 'The type of datasource being queried. Currently allowed values are prometheus, graphite, loki, postgres, and datadog.',
                                    type: 'string',
                                  },
                                  datasourceUid: {
                                    description: 'The uid of the datasource to query.',
                                    type: 'string',
                                  },
                                  description: {
                                    description: 'A description of the outlier detector.',
                                    type: 'string',
                                  },
                                  interval: {
                                    description: 'The data interval in seconds to monitor. Defaults to `300`.',
                                    type: 'number',
                                  },
                                  metric: {
                                    description: 'The metric used to query the outlier detector results.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: 'The name of the outlier detector.',
                                    type: 'string',
                                  },
                                  queryParams: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    description: 'An object representing the query params to query Grafana with.',
                                    type: 'object',
                                    'x-kubernetes-map-type': 'granular',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  algorithm: {
                                    description: 'The algorithm to use and its configuration. See https://grafana.com/docs/grafana-cloud/machine-learning/outlier-detection/ for details.',
                                    items: {
                                      properties: {
                                        config: {
                                          description: 'For DBSCAN only, specify the configuration map',
                                          items: {
                                            properties: {
                                              epsilon: {
                                                description: 'Specify the epsilon parameter (positive float)',
                                                type: 'number',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        name: {
                                          description: "The name of the algorithm to use ('mad' or 'dbscan').",
                                          type: 'string',
                                        },
                                        sensitivity: {
                                          description: 'Specify the sensitivity of the detector (in range [0,1]).',
                                          type: 'number',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  dataSourceRef: {
                                    description: 'Reference to a DataSource in oss to populate datasourceUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  dataSourceSelector: {
                                    description: 'Selector for a DataSource in oss to populate datasourceUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  datasourceType: {
                                    description: 'The type of datasource being queried. Currently allowed values are prometheus, graphite, loki, postgres, and datadog.',
                                    type: 'string',
                                  },
                                  datasourceUid: {
                                    description: 'The uid of the datasource to query.',
                                    type: 'string',
                                  },
                                  description: {
                                    description: 'A description of the outlier detector.',
                                    type: 'string',
                                  },
                                  interval: {
                                    description: 'The data interval in seconds to monitor. Defaults to `300`.',
                                    type: 'number',
                                  },
                                  metric: {
                                    description: 'The metric used to query the outlier detector results.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: 'The name of the outlier detector.',
                                    type: 'string',
                                  },
                                  queryParams: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    description: 'An object representing the query params to query Grafana with.',
                                    type: 'object',
                                    'x-kubernetes-map-type': 'granular',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.algorithm is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.algorithm) || (has(self.initProvider) && has(self.initProvider.algorithm))",
                              },
                              {
                                message: 'spec.forProvider.datasourceType is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.datasourceType) || (has(self.initProvider) && has(self.initProvider.datasourceType))",
                              },
                              {
                                message: 'spec.forProvider.metric is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.metric) || (has(self.initProvider) && has(self.initProvider.metric))",
                              },
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.queryParams is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.queryParams) || (has(self.initProvider) && has(self.initProvider.queryParams))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
    },
  },
  oncall: {
    v1alpha1: {
      escalation: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xescalations.oncall.grafana.crossplane.io.namespaced',
            },
            name: 'escalation-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oncall.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XEscalation',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oncall.grafana.crossplane.io/v1alpha1',
                  kind: 'Escalation',
                },
                name: 'escalation',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.actionToTrigger',
                    toFieldPath: 'spec.forProvider.actionToTrigger',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.actionToTriggerRef.name',
                    toFieldPath: 'spec.forProvider.actionToTriggerRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.actionToTriggerRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.actionToTriggerRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.actionToTriggerRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.actionToTriggerRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.actionToTriggerSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.actionToTriggerSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.actionToTriggerSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.actionToTriggerSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.actionToTriggerSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.actionToTriggerSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.actionToTriggerSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.actionToTriggerSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.duration',
                    toFieldPath: 'spec.forProvider.duration',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainId',
                    toFieldPath: 'spec.forProvider.escalationChainId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainRef.name',
                    toFieldPath: 'spec.forProvider.escalationChainRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.escalationChainRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.escalationChainRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.escalationChainSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.escalationChainSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.escalationChainSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.escalationChainSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.groupToNotify',
                    toFieldPath: 'spec.forProvider.groupToNotify',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.important',
                    toFieldPath: 'spec.forProvider.important',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.notifyIfTimeFrom',
                    toFieldPath: 'spec.forProvider.notifyIfTimeFrom',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.notifyIfTimeTo',
                    toFieldPath: 'spec.forProvider.notifyIfTimeTo',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.notifyOnCallFromSchedule',
                    toFieldPath: 'spec.forProvider.notifyOnCallFromSchedule',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.notifyOnCallFromScheduleRef.name',
                    toFieldPath: 'spec.forProvider.notifyOnCallFromScheduleRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.notifyOnCallFromScheduleRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.notifyOnCallFromScheduleRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.notifyOnCallFromScheduleRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.notifyOnCallFromScheduleRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.notifyOnCallFromScheduleSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.notifyOnCallFromScheduleSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.notifyOnCallFromScheduleSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.notifyOnCallFromScheduleSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.notifyOnCallFromScheduleSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.notifyOnCallFromScheduleSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.notifyOnCallFromScheduleSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.notifyOnCallFromScheduleSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.notifyToTeamMembers',
                    toFieldPath: 'spec.forProvider.notifyToTeamMembers',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.personsToNotify',
                    toFieldPath: 'spec.forProvider.personsToNotify',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.personsToNotifyNextEachTime',
                    toFieldPath: 'spec.forProvider.personsToNotifyNextEachTime',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.position',
                    toFieldPath: 'spec.forProvider.position',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.type',
                    toFieldPath: 'spec.forProvider.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.actionToTrigger',
                    toFieldPath: 'spec.initProvider.actionToTrigger',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.actionToTriggerRef.name',
                    toFieldPath: 'spec.initProvider.actionToTriggerRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.actionToTriggerRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.actionToTriggerRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.actionToTriggerRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.actionToTriggerRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.actionToTriggerSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.actionToTriggerSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.actionToTriggerSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.actionToTriggerSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.actionToTriggerSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.actionToTriggerSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.actionToTriggerSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.actionToTriggerSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.duration',
                    toFieldPath: 'spec.initProvider.duration',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainId',
                    toFieldPath: 'spec.initProvider.escalationChainId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainRef.name',
                    toFieldPath: 'spec.initProvider.escalationChainRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.escalationChainRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.escalationChainRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.escalationChainSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.escalationChainSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.escalationChainSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.escalationChainSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.groupToNotify',
                    toFieldPath: 'spec.initProvider.groupToNotify',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.important',
                    toFieldPath: 'spec.initProvider.important',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.notifyIfTimeFrom',
                    toFieldPath: 'spec.initProvider.notifyIfTimeFrom',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.notifyIfTimeTo',
                    toFieldPath: 'spec.initProvider.notifyIfTimeTo',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.notifyOnCallFromSchedule',
                    toFieldPath: 'spec.initProvider.notifyOnCallFromSchedule',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.notifyOnCallFromScheduleRef.name',
                    toFieldPath: 'spec.initProvider.notifyOnCallFromScheduleRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.notifyOnCallFromScheduleRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.notifyOnCallFromScheduleRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.notifyOnCallFromScheduleRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.notifyOnCallFromScheduleRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.notifyOnCallFromScheduleSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.notifyOnCallFromScheduleSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.notifyOnCallFromScheduleSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.notifyOnCallFromScheduleSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.notifyOnCallFromScheduleSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.notifyOnCallFromScheduleSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.notifyOnCallFromScheduleSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.notifyOnCallFromScheduleSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.notifyToTeamMembers',
                    toFieldPath: 'spec.initProvider.notifyToTeamMembers',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.personsToNotify',
                    toFieldPath: 'spec.initProvider.personsToNotify',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.personsToNotifyNextEachTime',
                    toFieldPath: 'spec.initProvider.personsToNotifyNextEachTime',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.position',
                    toFieldPath: 'spec.initProvider.position',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.type',
                    toFieldPath: 'spec.initProvider.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xescalations.oncall.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Escalation',
              plural: 'escalations',
            },
            defaultCompositionRef: {
              name: 'escalation-namespaced',
            },
            group: 'oncall.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XEscalation',
              plural: 'xescalations',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'EscalationSpec defines the desired state of Escalation',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  actionToTrigger: {
                                    description: '(String) The ID of an Action for trigger_webhook type step.\nThe ID of an Action for trigger_webhook type step.',
                                    type: 'string',
                                  },
                                  actionToTriggerRef: {
                                    description: 'Reference to a OutgoingWebhook in oncall to populate actionToTrigger.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  actionToTriggerSelector: {
                                    description: 'Selector for a OutgoingWebhook in oncall to populate actionToTrigger.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  duration: {
                                    description: '(Number) The duration of delay for wait type step.\nThe duration of delay for wait type step.',
                                    type: 'number',
                                  },
                                  escalationChainId: {
                                    description: '(String) The ID of the escalation chain.\nThe ID of the escalation chain.',
                                    type: 'string',
                                  },
                                  escalationChainRef: {
                                    description: 'Reference to a EscalationChain in oncall to populate escalationChainId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  escalationChainSelector: {
                                    description: 'Selector for a EscalationChain in oncall to populate escalationChainId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  groupToNotify: {
                                    description: '(String) The ID of a User Group for notify_user_group type step.\nThe ID of a User Group for notify_user_group type step.',
                                    type: 'string',
                                  },
                                  important: {
                                    description: '(Boolean) Will activate "important" personal notification rules. Actual for steps: notify_persons, notify_on_call_from_schedule and notify_user_group,notify_team_members\nWill activate "important" personal notification rules. Actual for steps: notify_persons, notify_on_call_from_schedule and notify_user_group,notify_team_members',
                                    type: 'boolean',
                                  },
                                  notifyIfTimeFrom: {
                                    description: '(String) The beginning of the time interval for notify_if_time_from_to type step in UTC (for example 08:00:00Z).\nThe beginning of the time interval for notify_if_time_from_to type step in UTC (for example 08:00:00Z).',
                                    type: 'string',
                                  },
                                  notifyIfTimeTo: {
                                    description: '(String) The end of the time interval for notify_if_time_from_to type step in UTC (for example 18:00:00Z).\nThe end of the time interval for notify_if_time_from_to type step in UTC (for example 18:00:00Z).',
                                    type: 'string',
                                  },
                                  notifyOnCallFromSchedule: {
                                    description: '(String) ID of a Schedule for notify_on_call_from_schedule type step.\nID of a Schedule for notify_on_call_from_schedule type step.',
                                    type: 'string',
                                  },
                                  notifyOnCallFromScheduleRef: {
                                    description: 'Reference to a Schedule in oncall to populate notifyOnCallFromSchedule.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  notifyOnCallFromScheduleSelector: {
                                    description: 'Selector for a Schedule in oncall to populate notifyOnCallFromSchedule.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  notifyToTeamMembers: {
                                    description: '(String) The ID of a Team for a notify_team_members type step.\nThe ID of a Team for a notify_team_members type step.',
                                    type: 'string',
                                  },
                                  personsToNotify: {
                                    description: "(Set of String) The list of ID's of users for notify_persons type step.\nThe list of ID's of users for notify_persons type step.",
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  personsToNotifyNextEachTime: {
                                    description: "(Set of String) The list of ID's of users for notify_person_next_each_time type step.\nThe list of ID's of users for notify_person_next_each_time type step.",
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  position: {
                                    description: '(Number) The position of the escalation step (starts from 0).\nThe position of the escalation step (starts from 0).',
                                    type: 'number',
                                  },
                                  type: {
                                    description: '(String) The type of escalation policy. Can be wait, notify_persons, notify_person_next_each_time, notify_on_call_from_schedule, trigger_webhook, notify_user_group, resolve, notify_whole_channel, notify_if_time_from_to, repeat_escalation, notify_team_members\nThe type of escalation policy. Can be wait, notify_persons, notify_person_next_each_time, notify_on_call_from_schedule, trigger_webhook, notify_user_group, resolve, notify_whole_channel, notify_if_time_from_to, repeat_escalation, notify_team_members',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  actionToTrigger: {
                                    description: '(String) The ID of an Action for trigger_webhook type step.\nThe ID of an Action for trigger_webhook type step.',
                                    type: 'string',
                                  },
                                  actionToTriggerRef: {
                                    description: 'Reference to a OutgoingWebhook in oncall to populate actionToTrigger.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  actionToTriggerSelector: {
                                    description: 'Selector for a OutgoingWebhook in oncall to populate actionToTrigger.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  duration: {
                                    description: '(Number) The duration of delay for wait type step.\nThe duration of delay for wait type step.',
                                    type: 'number',
                                  },
                                  escalationChainId: {
                                    description: '(String) The ID of the escalation chain.\nThe ID of the escalation chain.',
                                    type: 'string',
                                  },
                                  escalationChainRef: {
                                    description: 'Reference to a EscalationChain in oncall to populate escalationChainId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  escalationChainSelector: {
                                    description: 'Selector for a EscalationChain in oncall to populate escalationChainId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  groupToNotify: {
                                    description: '(String) The ID of a User Group for notify_user_group type step.\nThe ID of a User Group for notify_user_group type step.',
                                    type: 'string',
                                  },
                                  important: {
                                    description: '(Boolean) Will activate "important" personal notification rules. Actual for steps: notify_persons, notify_on_call_from_schedule and notify_user_group,notify_team_members\nWill activate "important" personal notification rules. Actual for steps: notify_persons, notify_on_call_from_schedule and notify_user_group,notify_team_members',
                                    type: 'boolean',
                                  },
                                  notifyIfTimeFrom: {
                                    description: '(String) The beginning of the time interval for notify_if_time_from_to type step in UTC (for example 08:00:00Z).\nThe beginning of the time interval for notify_if_time_from_to type step in UTC (for example 08:00:00Z).',
                                    type: 'string',
                                  },
                                  notifyIfTimeTo: {
                                    description: '(String) The end of the time interval for notify_if_time_from_to type step in UTC (for example 18:00:00Z).\nThe end of the time interval for notify_if_time_from_to type step in UTC (for example 18:00:00Z).',
                                    type: 'string',
                                  },
                                  notifyOnCallFromSchedule: {
                                    description: '(String) ID of a Schedule for notify_on_call_from_schedule type step.\nID of a Schedule for notify_on_call_from_schedule type step.',
                                    type: 'string',
                                  },
                                  notifyOnCallFromScheduleRef: {
                                    description: 'Reference to a Schedule in oncall to populate notifyOnCallFromSchedule.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  notifyOnCallFromScheduleSelector: {
                                    description: 'Selector for a Schedule in oncall to populate notifyOnCallFromSchedule.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  notifyToTeamMembers: {
                                    description: '(String) The ID of a Team for a notify_team_members type step.\nThe ID of a Team for a notify_team_members type step.',
                                    type: 'string',
                                  },
                                  personsToNotify: {
                                    description: "(Set of String) The list of ID's of users for notify_persons type step.\nThe list of ID's of users for notify_persons type step.",
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  personsToNotifyNextEachTime: {
                                    description: "(Set of String) The list of ID's of users for notify_person_next_each_time type step.\nThe list of ID's of users for notify_person_next_each_time type step.",
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  position: {
                                    description: '(Number) The position of the escalation step (starts from 0).\nThe position of the escalation step (starts from 0).',
                                    type: 'number',
                                  },
                                  type: {
                                    description: '(String) The type of escalation policy. Can be wait, notify_persons, notify_person_next_each_time, notify_on_call_from_schedule, trigger_webhook, notify_user_group, resolve, notify_whole_channel, notify_if_time_from_to, repeat_escalation, notify_team_members\nThe type of escalation policy. Can be wait, notify_persons, notify_person_next_each_time, notify_on_call_from_schedule, trigger_webhook, notify_user_group, resolve, notify_whole_channel, notify_if_time_from_to, repeat_escalation, notify_team_members',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.position is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.position) || (has(self.initProvider) && has(self.initProvider.position))",
                              },
                              {
                                message: 'spec.forProvider.type is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.type) || (has(self.initProvider) && has(self.initProvider.type))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      escalationChain: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xescalationchains.oncall.grafana.crossplane.io.namespaced',
            },
            name: 'escalationchain-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oncall.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XEscalationChain',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oncall.grafana.crossplane.io/v1alpha1',
                  kind: 'EscalationChain',
                },
                name: 'escalationchain',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamId',
                    toFieldPath: 'spec.forProvider.teamId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamId',
                    toFieldPath: 'spec.initProvider.teamId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xescalationchains.oncall.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'EscalationChain',
              plural: 'escalationchains',
            },
            defaultCompositionRef: {
              name: 'escalationchain-namespaced',
            },
            group: 'oncall.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XEscalationChain',
              plural: 'xescalationchains',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'EscalationChainSpec defines the desired state of EscalationChain',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  name: {
                                    description: '(String) The name of the escalation chain.\nThe name of the escalation chain.',
                                    type: 'string',
                                  },
                                  teamId: {
                                    description: '(String) The ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the grafana_oncall_team datasource.\nThe ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the `grafana_oncall_team` datasource.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  name: {
                                    description: '(String) The name of the escalation chain.\nThe name of the escalation chain.',
                                    type: 'string',
                                  },
                                  teamId: {
                                    description: '(String) The ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the grafana_oncall_team datasource.\nThe ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the `grafana_oncall_team` datasource.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      integration: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xintegrations.oncall.grafana.crossplane.io.namespaced',
            },
            name: 'integration-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oncall.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XIntegration',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oncall.grafana.crossplane.io/v1alpha1',
                  kind: 'Integration',
                },
                name: 'integration',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.defaultRoute',
                    toFieldPath: 'spec.forProvider.defaultRoute',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamId',
                    toFieldPath: 'spec.forProvider.teamId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.templates',
                    toFieldPath: 'spec.forProvider.templates',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.type',
                    toFieldPath: 'spec.forProvider.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.defaultRoute',
                    toFieldPath: 'spec.initProvider.defaultRoute',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamId',
                    toFieldPath: 'spec.initProvider.teamId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.templates',
                    toFieldPath: 'spec.initProvider.templates',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.type',
                    toFieldPath: 'spec.initProvider.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xintegrations.oncall.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Integration',
              plural: 'integrations',
            },
            defaultCompositionRef: {
              name: 'integration-namespaced',
            },
            group: 'oncall.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XIntegration',
              plural: 'xintegrations',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'IntegrationSpec defines the desired state of Integration',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  defaultRoute: {
                                    description: '(Block List, Min: 1, Max: 1) The Default route for all alerts from the given integration (see below for nested schema)\nThe Default route for all alerts from the given integration',
                                    items: {
                                      properties: {
                                        escalationChainId: {
                                          description: '(String) The ID of the escalation chain.\nThe ID of the escalation chain.',
                                          type: 'string',
                                        },
                                        escalationChainRef: {
                                          description: 'Reference to a EscalationChain in oncall to populate escalationChainId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        escalationChainSelector: {
                                          description: 'Selector for a EscalationChain in oncall to populate escalationChainId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        msteams: {
                                          description: 'specific settings for a route. (see below for nested schema)\nMS teams-specific settings for a route.',
                                          items: {
                                            properties: {
                                              enabled: {
                                                description: '(Boolean) Enable notification in MS teams. Defaults to true.\nEnable notification in MS teams. Defaults to `true`.',
                                                type: 'boolean',
                                              },
                                              id: {
                                                description: '(String) The ID of this resource.\nMS teams channel id. Alerts will be directed to this channel in Microsoft teams.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        slack: {
                                          description: 'specific settings for a route. (see below for nested schema)\nSlack-specific settings for a route.',
                                          items: {
                                            properties: {
                                              channelId: {
                                                description: '(String) Slack channel id. Alerts will be directed to this channel in Slack.\nSlack channel id. Alerts will be directed to this channel in Slack.',
                                                type: 'string',
                                              },
                                              enabled: {
                                                description: '(Boolean) Enable notification in MS teams. Defaults to true.\nEnable notification in Slack. Defaults to `true`.',
                                                type: 'boolean',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        telegram: {
                                          description: 'specific settings for a route. (see below for nested schema)\nTelegram-specific settings for a route.',
                                          items: {
                                            properties: {
                                              enabled: {
                                                description: '(Boolean) Enable notification in MS teams. Defaults to true.\nEnable notification in Telegram. Defaults to `true`.',
                                                type: 'boolean',
                                              },
                                              id: {
                                                description: '(String) The ID of this resource.\nTelegram channel id. Alerts will be directed to this channel in Telegram.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  name: {
                                    description: '(String) The name of the service integration.\nThe name of the service integration.',
                                    type: 'string',
                                  },
                                  teamId: {
                                    description: '(String) The ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the grafana_oncall_team datasource.\nThe ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the `grafana_oncall_team` datasource.',
                                    type: 'string',
                                  },
                                  templates: {
                                    description: '(Block List, Max: 1) Jinja2 templates for Alert payload. An empty templates block will be ignored. (see below for nested schema)\nJinja2 templates for Alert payload. An empty templates block will be ignored.',
                                    items: {
                                      properties: {
                                        acknowledgeSignal: {
                                          description: '(String) Template for sending a signal to acknowledge the Incident.\nTemplate for sending a signal to acknowledge the Incident.',
                                          type: 'string',
                                        },
                                        email: {
                                          description: '(Block List, Max: 1) Templates for Email. (see below for nested schema)\nTemplates for Email.',
                                          items: {
                                            properties: {
                                              message: {
                                                description: '(String) Template for Alert message.\nTemplate for Alert message.',
                                                type: 'string',
                                              },
                                              title: {
                                                description: '(String) Template for Alert title.\nTemplate for Alert title.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        groupingKey: {
                                          description: '(String) Template for the key by which alerts are grouped.\nTemplate for the key by which alerts are grouped.',
                                          type: 'string',
                                        },
                                        microsoftTeams: {
                                          description: '(Block List, Max: 1) Templates for Microsoft Teams. (see below for nested schema)\nTemplates for Microsoft Teams.',
                                          items: {
                                            properties: {
                                              imageUrl: {
                                                description: '(String) Template for Alert image url.\nTemplate for Alert image url.',
                                                type: 'string',
                                              },
                                              message: {
                                                description: '(String) Template for Alert message.\nTemplate for Alert message.',
                                                type: 'string',
                                              },
                                              title: {
                                                description: '(String) Template for Alert title.\nTemplate for Alert title.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        phoneCall: {
                                          description: '(Block List, Max: 1) Templates for Phone Call. (see below for nested schema)\nTemplates for Phone Call.',
                                          items: {
                                            properties: {
                                              title: {
                                                description: '(String) Template for Alert title.\nTemplate for Alert title.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        resolveSignal: {
                                          description: '(String) Template for sending a signal to resolve the Incident.\nTemplate for sending a signal to resolve the Incident.',
                                          type: 'string',
                                        },
                                        slack: {
                                          description: 'specific settings for a route. (see below for nested schema)\nTemplates for Slack.',
                                          items: {
                                            properties: {
                                              imageUrl: {
                                                description: '(String) Template for Alert image url.\nTemplate for Alert image url.',
                                                type: 'string',
                                              },
                                              message: {
                                                description: '(String) Template for Alert message.\nTemplate for Alert message.',
                                                type: 'string',
                                              },
                                              title: {
                                                description: '(String) Template for Alert title.\nTemplate for Alert title.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        sms: {
                                          description: '(Block List, Max: 1) Templates for SMS. (see below for nested schema)\nTemplates for SMS.',
                                          items: {
                                            properties: {
                                              title: {
                                                description: '(String) Template for Alert title.\nTemplate for Alert title.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        sourceLink: {
                                          description: '(String) Template for a source link.\nTemplate for a source link.',
                                          type: 'string',
                                        },
                                        telegram: {
                                          description: 'specific settings for a route. (see below for nested schema)\nTemplates for Telegram.',
                                          items: {
                                            properties: {
                                              imageUrl: {
                                                description: '(String) Template for Alert image url.\nTemplate for Alert image url.',
                                                type: 'string',
                                              },
                                              message: {
                                                description: '(String) Template for Alert message.\nTemplate for Alert message.',
                                                type: 'string',
                                              },
                                              title: {
                                                description: '(String) Template for Alert title.\nTemplate for Alert title.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        web: {
                                          description: '(Block List, Max: 1) Templates for Web. (see below for nested schema)\nTemplates for Web.',
                                          items: {
                                            properties: {
                                              imageUrl: {
                                                description: '(String) Template for Alert image url.\nTemplate for Alert image url.',
                                                type: 'string',
                                              },
                                              message: {
                                                description: '(String) Template for Alert message.\nTemplate for Alert message.',
                                                type: 'string',
                                              },
                                              title: {
                                                description: '(String) Template for Alert title.\nTemplate for Alert title.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  type: {
                                    description: '(String) The type of integration. Can be grafana, grafana_alerting, webhook, alertmanager, kapacitor, fabric, newrelic, datadog, pagerduty, pingdom, elastalert, amazon_sns, curler, sentry, formatted_webhook, heartbeat, demo, manual, stackdriver, uptimerobot, sentry_platform, zabbix, prtg, slack_channel, inbound_email, direct_paging, jira.\nThe type of integration. Can be grafana, grafana_alerting, webhook, alertmanager, kapacitor, fabric, newrelic, datadog, pagerduty, pingdom, elastalert, amazon_sns, curler, sentry, formatted_webhook, heartbeat, demo, manual, stackdriver, uptimerobot, sentry_platform, zabbix, prtg, slack_channel, inbound_email, direct_paging, jira.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  defaultRoute: {
                                    description: '(Block List, Min: 1, Max: 1) The Default route for all alerts from the given integration (see below for nested schema)\nThe Default route for all alerts from the given integration',
                                    items: {
                                      properties: {
                                        escalationChainId: {
                                          description: '(String) The ID of the escalation chain.\nThe ID of the escalation chain.',
                                          type: 'string',
                                        },
                                        escalationChainRef: {
                                          description: 'Reference to a EscalationChain in oncall to populate escalationChainId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        escalationChainSelector: {
                                          description: 'Selector for a EscalationChain in oncall to populate escalationChainId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        msteams: {
                                          description: 'specific settings for a route. (see below for nested schema)\nMS teams-specific settings for a route.',
                                          items: {
                                            properties: {
                                              enabled: {
                                                description: '(Boolean) Enable notification in MS teams. Defaults to true.\nEnable notification in MS teams. Defaults to `true`.',
                                                type: 'boolean',
                                              },
                                              id: {
                                                description: '(String) The ID of this resource.\nMS teams channel id. Alerts will be directed to this channel in Microsoft teams.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        slack: {
                                          description: 'specific settings for a route. (see below for nested schema)\nSlack-specific settings for a route.',
                                          items: {
                                            properties: {
                                              channelId: {
                                                description: '(String) Slack channel id. Alerts will be directed to this channel in Slack.\nSlack channel id. Alerts will be directed to this channel in Slack.',
                                                type: 'string',
                                              },
                                              enabled: {
                                                description: '(Boolean) Enable notification in MS teams. Defaults to true.\nEnable notification in Slack. Defaults to `true`.',
                                                type: 'boolean',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        telegram: {
                                          description: 'specific settings for a route. (see below for nested schema)\nTelegram-specific settings for a route.',
                                          items: {
                                            properties: {
                                              enabled: {
                                                description: '(Boolean) Enable notification in MS teams. Defaults to true.\nEnable notification in Telegram. Defaults to `true`.',
                                                type: 'boolean',
                                              },
                                              id: {
                                                description: '(String) The ID of this resource.\nTelegram channel id. Alerts will be directed to this channel in Telegram.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  name: {
                                    description: '(String) The name of the service integration.\nThe name of the service integration.',
                                    type: 'string',
                                  },
                                  teamId: {
                                    description: '(String) The ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the grafana_oncall_team datasource.\nThe ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the `grafana_oncall_team` datasource.',
                                    type: 'string',
                                  },
                                  templates: {
                                    description: '(Block List, Max: 1) Jinja2 templates for Alert payload. An empty templates block will be ignored. (see below for nested schema)\nJinja2 templates for Alert payload. An empty templates block will be ignored.',
                                    items: {
                                      properties: {
                                        acknowledgeSignal: {
                                          description: '(String) Template for sending a signal to acknowledge the Incident.\nTemplate for sending a signal to acknowledge the Incident.',
                                          type: 'string',
                                        },
                                        email: {
                                          description: '(Block List, Max: 1) Templates for Email. (see below for nested schema)\nTemplates for Email.',
                                          items: {
                                            properties: {
                                              message: {
                                                description: '(String) Template for Alert message.\nTemplate for Alert message.',
                                                type: 'string',
                                              },
                                              title: {
                                                description: '(String) Template for Alert title.\nTemplate for Alert title.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        groupingKey: {
                                          description: '(String) Template for the key by which alerts are grouped.\nTemplate for the key by which alerts are grouped.',
                                          type: 'string',
                                        },
                                        microsoftTeams: {
                                          description: '(Block List, Max: 1) Templates for Microsoft Teams. (see below for nested schema)\nTemplates for Microsoft Teams.',
                                          items: {
                                            properties: {
                                              imageUrl: {
                                                description: '(String) Template for Alert image url.\nTemplate for Alert image url.',
                                                type: 'string',
                                              },
                                              message: {
                                                description: '(String) Template for Alert message.\nTemplate for Alert message.',
                                                type: 'string',
                                              },
                                              title: {
                                                description: '(String) Template for Alert title.\nTemplate for Alert title.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        phoneCall: {
                                          description: '(Block List, Max: 1) Templates for Phone Call. (see below for nested schema)\nTemplates for Phone Call.',
                                          items: {
                                            properties: {
                                              title: {
                                                description: '(String) Template for Alert title.\nTemplate for Alert title.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        resolveSignal: {
                                          description: '(String) Template for sending a signal to resolve the Incident.\nTemplate for sending a signal to resolve the Incident.',
                                          type: 'string',
                                        },
                                        slack: {
                                          description: 'specific settings for a route. (see below for nested schema)\nTemplates for Slack.',
                                          items: {
                                            properties: {
                                              imageUrl: {
                                                description: '(String) Template for Alert image url.\nTemplate for Alert image url.',
                                                type: 'string',
                                              },
                                              message: {
                                                description: '(String) Template for Alert message.\nTemplate for Alert message.',
                                                type: 'string',
                                              },
                                              title: {
                                                description: '(String) Template for Alert title.\nTemplate for Alert title.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        sms: {
                                          description: '(Block List, Max: 1) Templates for SMS. (see below for nested schema)\nTemplates for SMS.',
                                          items: {
                                            properties: {
                                              title: {
                                                description: '(String) Template for Alert title.\nTemplate for Alert title.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        sourceLink: {
                                          description: '(String) Template for a source link.\nTemplate for a source link.',
                                          type: 'string',
                                        },
                                        telegram: {
                                          description: 'specific settings for a route. (see below for nested schema)\nTemplates for Telegram.',
                                          items: {
                                            properties: {
                                              imageUrl: {
                                                description: '(String) Template for Alert image url.\nTemplate for Alert image url.',
                                                type: 'string',
                                              },
                                              message: {
                                                description: '(String) Template for Alert message.\nTemplate for Alert message.',
                                                type: 'string',
                                              },
                                              title: {
                                                description: '(String) Template for Alert title.\nTemplate for Alert title.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        web: {
                                          description: '(Block List, Max: 1) Templates for Web. (see below for nested schema)\nTemplates for Web.',
                                          items: {
                                            properties: {
                                              imageUrl: {
                                                description: '(String) Template for Alert image url.\nTemplate for Alert image url.',
                                                type: 'string',
                                              },
                                              message: {
                                                description: '(String) Template for Alert message.\nTemplate for Alert message.',
                                                type: 'string',
                                              },
                                              title: {
                                                description: '(String) Template for Alert title.\nTemplate for Alert title.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  type: {
                                    description: '(String) The type of integration. Can be grafana, grafana_alerting, webhook, alertmanager, kapacitor, fabric, newrelic, datadog, pagerduty, pingdom, elastalert, amazon_sns, curler, sentry, formatted_webhook, heartbeat, demo, manual, stackdriver, uptimerobot, sentry_platform, zabbix, prtg, slack_channel, inbound_email, direct_paging, jira.\nThe type of integration. Can be grafana, grafana_alerting, webhook, alertmanager, kapacitor, fabric, newrelic, datadog, pagerduty, pingdom, elastalert, amazon_sns, curler, sentry, formatted_webhook, heartbeat, demo, manual, stackdriver, uptimerobot, sentry_platform, zabbix, prtg, slack_channel, inbound_email, direct_paging, jira.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.defaultRoute is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.defaultRoute) || (has(self.initProvider) && has(self.initProvider.defaultRoute))",
                              },
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.type is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.type) || (has(self.initProvider) && has(self.initProvider.type))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      onCallShift: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xoncallshifts.oncall.grafana.crossplane.io.namespaced',
            },
            name: 'oncallshift-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oncall.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XOnCallShift',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oncall.grafana.crossplane.io/v1alpha1',
                  kind: 'OnCallShift',
                },
                name: 'oncallshift',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.byDay',
                    toFieldPath: 'spec.forProvider.byDay',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.byMonth',
                    toFieldPath: 'spec.forProvider.byMonth',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.byMonthday',
                    toFieldPath: 'spec.forProvider.byMonthday',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.duration',
                    toFieldPath: 'spec.forProvider.duration',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.frequency',
                    toFieldPath: 'spec.forProvider.frequency',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.interval',
                    toFieldPath: 'spec.forProvider.interval',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.level',
                    toFieldPath: 'spec.forProvider.level',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.rollingUsers',
                    toFieldPath: 'spec.forProvider.rollingUsers',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.start',
                    toFieldPath: 'spec.forProvider.start',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.startRotationFromUserIndex',
                    toFieldPath: 'spec.forProvider.startRotationFromUserIndex',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamId',
                    toFieldPath: 'spec.forProvider.teamId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.timeZone',
                    toFieldPath: 'spec.forProvider.timeZone',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.type',
                    toFieldPath: 'spec.forProvider.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.users',
                    toFieldPath: 'spec.forProvider.users',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.weekStart',
                    toFieldPath: 'spec.forProvider.weekStart',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.byDay',
                    toFieldPath: 'spec.initProvider.byDay',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.byMonth',
                    toFieldPath: 'spec.initProvider.byMonth',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.byMonthday',
                    toFieldPath: 'spec.initProvider.byMonthday',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.duration',
                    toFieldPath: 'spec.initProvider.duration',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.frequency',
                    toFieldPath: 'spec.initProvider.frequency',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.interval',
                    toFieldPath: 'spec.initProvider.interval',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.level',
                    toFieldPath: 'spec.initProvider.level',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.rollingUsers',
                    toFieldPath: 'spec.initProvider.rollingUsers',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.start',
                    toFieldPath: 'spec.initProvider.start',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.startRotationFromUserIndex',
                    toFieldPath: 'spec.initProvider.startRotationFromUserIndex',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamId',
                    toFieldPath: 'spec.initProvider.teamId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.timeZone',
                    toFieldPath: 'spec.initProvider.timeZone',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.type',
                    toFieldPath: 'spec.initProvider.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.users',
                    toFieldPath: 'spec.initProvider.users',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.weekStart',
                    toFieldPath: 'spec.initProvider.weekStart',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xoncallshifts.oncall.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'OnCallShift',
              plural: 'oncallshifts',
            },
            defaultCompositionRef: {
              name: 'oncallshift-namespaced',
            },
            group: 'oncall.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XOnCallShift',
              plural: 'xoncallshifts',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'OnCallShiftSpec defines the desired state of OnCallShift',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  byDay: {
                                    description: '(Set of String) This parameter takes a list of days in iCal format. Can be MO, TU, WE, TH, FR, SA, SU\nThis parameter takes a list of days in iCal format. Can be MO, TU, WE, TH, FR, SA, SU',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  byMonth: {
                                    description: '(Set of Number) This parameter takes a list of months. Valid values are 1 to 12\nThis parameter takes a list of months. Valid values are 1 to 12',
                                    items: {
                                      type: 'number',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  byMonthday: {
                                    description: '31 to -1\nThis parameter takes a list of days of the month.  Valid values are 1 to 31 or -31 to -1',
                                    items: {
                                      type: 'number',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  duration: {
                                    description: '(Number) The duration of the event.\nThe duration of the event.',
                                    type: 'number',
                                  },
                                  frequency: {
                                    description: '(String) The frequency of the event. Can be hourly, daily, weekly, monthly\nThe frequency of the event. Can be hourly, daily, weekly, monthly',
                                    type: 'string',
                                  },
                                  interval: {
                                    description: '(Number) The positive integer representing at which intervals the recurrence rule repeats.\nThe positive integer representing at which intervals the recurrence rule repeats.',
                                    type: 'number',
                                  },
                                  level: {
                                    description: '(Number) The priority level. The higher the value, the higher the priority.\nThe priority level. The higher the value, the higher the priority.',
                                    type: 'number',
                                  },
                                  name: {
                                    description: "(String) The shift's name.\nThe shift's name.",
                                    type: 'string',
                                  },
                                  rollingUsers: {
                                    description: 'call users (for rolling_users event type)\nThe list of lists with on-call users (for rolling_users event type)',
                                    items: {
                                      items: {
                                        type: 'string',
                                      },
                                      type: 'array',
                                    },
                                    type: 'array',
                                  },
                                  start: {
                                    description: "call shift. This parameter takes a date format as yyyy-MM-dd'T'HH:mm:ss (for example \"2020-09-05T08:00:00\")\nThe start time of the on-call shift. This parameter takes a date format as yyyy-MM-dd'T'HH:mm:ss (for example \"2020-09-05T08:00:00\")",
                                    type: 'string',
                                  },
                                  startRotationFromUserIndex: {
                                    description: 'call rotation starts.\nThe index of the list of users in rolling_users, from which on-call rotation starts.',
                                    type: 'number',
                                  },
                                  teamId: {
                                    description: '(String) The ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the grafana_oncall_team datasource.\nThe ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the `grafana_oncall_team` datasource.',
                                    type: 'string',
                                  },
                                  timeZone: {
                                    description: "(String) The shift's timezone.  Overrides schedule's timezone.\nThe shift's timezone.  Overrides schedule's timezone.",
                                    type: 'string',
                                  },
                                  type: {
                                    description: "(String) The shift's type. Can be rolling_users, recurrent_event, single_event\nThe shift's type. Can be rolling_users, recurrent_event, single_event",
                                    type: 'string',
                                  },
                                  users: {
                                    description: 'call users (for single_event and recurrent_event event type).\nThe list of on-call users (for single_event and recurrent_event event type).',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  weekStart: {
                                    description: '(String) Start day of the week in iCal format. Can be MO, TU, WE, TH, FR, SA, SU\nStart day of the week in iCal format. Can be MO, TU, WE, TH, FR, SA, SU',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  byDay: {
                                    description: '(Set of String) This parameter takes a list of days in iCal format. Can be MO, TU, WE, TH, FR, SA, SU\nThis parameter takes a list of days in iCal format. Can be MO, TU, WE, TH, FR, SA, SU',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  byMonth: {
                                    description: '(Set of Number) This parameter takes a list of months. Valid values are 1 to 12\nThis parameter takes a list of months. Valid values are 1 to 12',
                                    items: {
                                      type: 'number',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  byMonthday: {
                                    description: '31 to -1\nThis parameter takes a list of days of the month.  Valid values are 1 to 31 or -31 to -1',
                                    items: {
                                      type: 'number',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  duration: {
                                    description: '(Number) The duration of the event.\nThe duration of the event.',
                                    type: 'number',
                                  },
                                  frequency: {
                                    description: '(String) The frequency of the event. Can be hourly, daily, weekly, monthly\nThe frequency of the event. Can be hourly, daily, weekly, monthly',
                                    type: 'string',
                                  },
                                  interval: {
                                    description: '(Number) The positive integer representing at which intervals the recurrence rule repeats.\nThe positive integer representing at which intervals the recurrence rule repeats.',
                                    type: 'number',
                                  },
                                  level: {
                                    description: '(Number) The priority level. The higher the value, the higher the priority.\nThe priority level. The higher the value, the higher the priority.',
                                    type: 'number',
                                  },
                                  name: {
                                    description: "(String) The shift's name.\nThe shift's name.",
                                    type: 'string',
                                  },
                                  rollingUsers: {
                                    description: 'call users (for rolling_users event type)\nThe list of lists with on-call users (for rolling_users event type)',
                                    items: {
                                      items: {
                                        type: 'string',
                                      },
                                      type: 'array',
                                    },
                                    type: 'array',
                                  },
                                  start: {
                                    description: "call shift. This parameter takes a date format as yyyy-MM-dd'T'HH:mm:ss (for example \"2020-09-05T08:00:00\")\nThe start time of the on-call shift. This parameter takes a date format as yyyy-MM-dd'T'HH:mm:ss (for example \"2020-09-05T08:00:00\")",
                                    type: 'string',
                                  },
                                  startRotationFromUserIndex: {
                                    description: 'call rotation starts.\nThe index of the list of users in rolling_users, from which on-call rotation starts.',
                                    type: 'number',
                                  },
                                  teamId: {
                                    description: '(String) The ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the grafana_oncall_team datasource.\nThe ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the `grafana_oncall_team` datasource.',
                                    type: 'string',
                                  },
                                  timeZone: {
                                    description: "(String) The shift's timezone.  Overrides schedule's timezone.\nThe shift's timezone.  Overrides schedule's timezone.",
                                    type: 'string',
                                  },
                                  type: {
                                    description: "(String) The shift's type. Can be rolling_users, recurrent_event, single_event\nThe shift's type. Can be rolling_users, recurrent_event, single_event",
                                    type: 'string',
                                  },
                                  users: {
                                    description: 'call users (for single_event and recurrent_event event type).\nThe list of on-call users (for single_event and recurrent_event event type).',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  weekStart: {
                                    description: '(String) Start day of the week in iCal format. Can be MO, TU, WE, TH, FR, SA, SU\nStart day of the week in iCal format. Can be MO, TU, WE, TH, FR, SA, SU',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.duration is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.duration) || (has(self.initProvider) && has(self.initProvider.duration))",
                              },
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.start is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.start) || (has(self.initProvider) && has(self.initProvider.start))",
                              },
                              {
                                message: 'spec.forProvider.type is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.type) || (has(self.initProvider) && has(self.initProvider.type))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      outgoingWebhook: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xoutgoingwebhooks.oncall.grafana.crossplane.io.namespaced',
            },
            name: 'outgoingwebhook-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oncall.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XOutgoingWebhook',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oncall.grafana.crossplane.io/v1alpha1',
                  kind: 'OutgoingWebhook',
                },
                name: 'outgoingwebhook',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.authorizationHeaderSecretRef.key',
                    toFieldPath: 'spec.forProvider.authorizationHeaderSecretRef.key',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.authorizationHeaderSecretRef.name',
                    toFieldPath: 'spec.forProvider.authorizationHeaderSecretRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.authorizationHeaderSecretRef.namespace',
                    toFieldPath: 'spec.forProvider.authorizationHeaderSecretRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.data',
                    toFieldPath: 'spec.forProvider.data',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.forwardWholePayload',
                    toFieldPath: 'spec.forProvider.forwardWholePayload',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.headers',
                    toFieldPath: 'spec.forProvider.headers',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.httpMethod',
                    toFieldPath: 'spec.forProvider.httpMethod',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.integrationFilter',
                    toFieldPath: 'spec.forProvider.integrationFilter',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.isWebhookEnabled',
                    toFieldPath: 'spec.forProvider.isWebhookEnabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.passwordSecretRef.key',
                    toFieldPath: 'spec.forProvider.passwordSecretRef.key',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.passwordSecretRef.name',
                    toFieldPath: 'spec.forProvider.passwordSecretRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.passwordSecretRef.namespace',
                    toFieldPath: 'spec.forProvider.passwordSecretRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamId',
                    toFieldPath: 'spec.forProvider.teamId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.triggerTemplate',
                    toFieldPath: 'spec.forProvider.triggerTemplate',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.triggerType',
                    toFieldPath: 'spec.forProvider.triggerType',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.url',
                    toFieldPath: 'spec.forProvider.url',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.user',
                    toFieldPath: 'spec.forProvider.user',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.authorizationHeaderSecretRef.key',
                    toFieldPath: 'spec.initProvider.authorizationHeaderSecretRef.key',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.authorizationHeaderSecretRef.name',
                    toFieldPath: 'spec.initProvider.authorizationHeaderSecretRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.authorizationHeaderSecretRef.namespace',
                    toFieldPath: 'spec.initProvider.authorizationHeaderSecretRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.data',
                    toFieldPath: 'spec.initProvider.data',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.forwardWholePayload',
                    toFieldPath: 'spec.initProvider.forwardWholePayload',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.headers',
                    toFieldPath: 'spec.initProvider.headers',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.httpMethod',
                    toFieldPath: 'spec.initProvider.httpMethod',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.integrationFilter',
                    toFieldPath: 'spec.initProvider.integrationFilter',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.isWebhookEnabled',
                    toFieldPath: 'spec.initProvider.isWebhookEnabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.passwordSecretRef.key',
                    toFieldPath: 'spec.initProvider.passwordSecretRef.key',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.passwordSecretRef.name',
                    toFieldPath: 'spec.initProvider.passwordSecretRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.passwordSecretRef.namespace',
                    toFieldPath: 'spec.initProvider.passwordSecretRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamId',
                    toFieldPath: 'spec.initProvider.teamId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.triggerTemplate',
                    toFieldPath: 'spec.initProvider.triggerTemplate',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.triggerType',
                    toFieldPath: 'spec.initProvider.triggerType',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.url',
                    toFieldPath: 'spec.initProvider.url',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.user',
                    toFieldPath: 'spec.initProvider.user',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xoutgoingwebhooks.oncall.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'OutgoingWebhook',
              plural: 'outgoingwebhooks',
            },
            defaultCompositionRef: {
              name: 'outgoingwebhook-namespaced',
            },
            group: 'oncall.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XOutgoingWebhook',
              plural: 'xoutgoingwebhooks',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'OutgoingWebhookSpec defines the desired state of OutgoingWebhook',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  authorizationHeaderSecretRef: {
                                    description: '(String, Sensitive) The auth data of the webhook. Used in Authorization header instead of user/password auth.\nThe auth data of the webhook. Used in Authorization header instead of user/password auth.',
                                    properties: {
                                      key: {
                                        description: 'The key to select.',
                                        type: 'string',
                                      },
                                      name: {
                                        description: 'Name of the secret.',
                                        type: 'string',
                                      },
                                      namespace: {
                                        description: 'Namespace of the secret.',
                                        type: 'string',
                                      },
                                    },
                                    required: [
                                      'key',
                                      'name',
                                      'namespace',
                                    ],
                                    type: 'object',
                                  },
                                  data: {
                                    description: '(String) The data of the webhook.\nThe data of the webhook.',
                                    type: 'string',
                                  },
                                  forwardWholePayload: {
                                    description: '(Boolean) Toggle to send the entire webhook payload instead of using the values in the Data field.\nToggle to send the entire webhook payload instead of using the values in the Data field.',
                                    type: 'boolean',
                                  },
                                  headers: {
                                    description: '(String) Headers to add to the outgoing webhook request.\nHeaders to add to the outgoing webhook request.',
                                    type: 'string',
                                  },
                                  httpMethod: {
                                    description: '(String) The HTTP method used in the request made by the outgoing webhook. Defaults to POST.\nThe HTTP method used in the request made by the outgoing webhook. Defaults to `POST`.',
                                    type: 'string',
                                  },
                                  integrationFilter: {
                                    description: '(List of String) Restricts the outgoing webhook to only trigger if the event came from a selected integration. If no integrations are selected the outgoing webhook will trigger for any integration.\nRestricts the outgoing webhook to only trigger if the event came from a selected integration. If no integrations are selected the outgoing webhook will trigger for any integration.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                  },
                                  isWebhookEnabled: {
                                    description: '(Boolean) Controls whether the outgoing webhook will trigger or is ignored. Defaults to true.\nControls whether the outgoing webhook will trigger or is ignored. Defaults to `true`.',
                                    type: 'boolean',
                                  },
                                  name: {
                                    description: '(String) The name of the outgoing webhook.\nThe name of the outgoing webhook.',
                                    type: 'string',
                                  },
                                  passwordSecretRef: {
                                    description: '(String, Sensitive) The auth data of the webhook. Used for Basic authentication\nThe auth data of the webhook. Used for Basic authentication',
                                    properties: {
                                      key: {
                                        description: 'The key to select.',
                                        type: 'string',
                                      },
                                      name: {
                                        description: 'Name of the secret.',
                                        type: 'string',
                                      },
                                      namespace: {
                                        description: 'Namespace of the secret.',
                                        type: 'string',
                                      },
                                    },
                                    required: [
                                      'key',
                                      'name',
                                      'namespace',
                                    ],
                                    type: 'object',
                                  },
                                  teamId: {
                                    description: '(String) The ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the grafana_oncall_team datasource.\nThe ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the `grafana_oncall_team` datasource.',
                                    type: 'string',
                                  },
                                  triggerTemplate: {
                                    description: '(String) A template used to dynamically determine whether the webhook should execute based on the content of the payload.\nA template used to dynamically determine whether the webhook should execute based on the content of the payload.',
                                    type: 'string',
                                  },
                                  triggerType: {
                                    description: '(String) The type of event that will cause this outgoing webhook to execute. The types of triggers are: escalation, alert group created, acknowledge, resolve, silence, unsilence, unresolve, unacknowledge. Defaults to escalation.\nThe type of event that will cause this outgoing webhook to execute. The types of triggers are: `escalation`, `alert group created`, `acknowledge`, `resolve`, `silence`, `unsilence`, `unresolve`, `unacknowledge`. Defaults to `escalation`.',
                                    type: 'string',
                                  },
                                  url: {
                                    description: '(String) The webhook URL.\nThe webhook URL.',
                                    type: 'string',
                                  },
                                  user: {
                                    description: '(String) Username to use when making the outgoing webhook request.\nUsername to use when making the outgoing webhook request.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  authorizationHeaderSecretRef: {
                                    description: '(String, Sensitive) The auth data of the webhook. Used in Authorization header instead of user/password auth.\nThe auth data of the webhook. Used in Authorization header instead of user/password auth.',
                                    properties: {
                                      key: {
                                        description: 'The key to select.',
                                        type: 'string',
                                      },
                                      name: {
                                        description: 'Name of the secret.',
                                        type: 'string',
                                      },
                                      namespace: {
                                        description: 'Namespace of the secret.',
                                        type: 'string',
                                      },
                                    },
                                    required: [
                                      'key',
                                      'name',
                                      'namespace',
                                    ],
                                    type: 'object',
                                  },
                                  data: {
                                    description: '(String) The data of the webhook.\nThe data of the webhook.',
                                    type: 'string',
                                  },
                                  forwardWholePayload: {
                                    description: '(Boolean) Toggle to send the entire webhook payload instead of using the values in the Data field.\nToggle to send the entire webhook payload instead of using the values in the Data field.',
                                    type: 'boolean',
                                  },
                                  headers: {
                                    description: '(String) Headers to add to the outgoing webhook request.\nHeaders to add to the outgoing webhook request.',
                                    type: 'string',
                                  },
                                  httpMethod: {
                                    description: '(String) The HTTP method used in the request made by the outgoing webhook. Defaults to POST.\nThe HTTP method used in the request made by the outgoing webhook. Defaults to `POST`.',
                                    type: 'string',
                                  },
                                  integrationFilter: {
                                    description: '(List of String) Restricts the outgoing webhook to only trigger if the event came from a selected integration. If no integrations are selected the outgoing webhook will trigger for any integration.\nRestricts the outgoing webhook to only trigger if the event came from a selected integration. If no integrations are selected the outgoing webhook will trigger for any integration.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                  },
                                  isWebhookEnabled: {
                                    description: '(Boolean) Controls whether the outgoing webhook will trigger or is ignored. Defaults to true.\nControls whether the outgoing webhook will trigger or is ignored. Defaults to `true`.',
                                    type: 'boolean',
                                  },
                                  name: {
                                    description: '(String) The name of the outgoing webhook.\nThe name of the outgoing webhook.',
                                    type: 'string',
                                  },
                                  passwordSecretRef: {
                                    description: '(String, Sensitive) The auth data of the webhook. Used for Basic authentication\nThe auth data of the webhook. Used for Basic authentication',
                                    properties: {
                                      key: {
                                        description: 'The key to select.',
                                        type: 'string',
                                      },
                                      name: {
                                        description: 'Name of the secret.',
                                        type: 'string',
                                      },
                                      namespace: {
                                        description: 'Namespace of the secret.',
                                        type: 'string',
                                      },
                                    },
                                    required: [
                                      'key',
                                      'name',
                                      'namespace',
                                    ],
                                    type: 'object',
                                  },
                                  teamId: {
                                    description: '(String) The ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the grafana_oncall_team datasource.\nThe ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the `grafana_oncall_team` datasource.',
                                    type: 'string',
                                  },
                                  triggerTemplate: {
                                    description: '(String) A template used to dynamically determine whether the webhook should execute based on the content of the payload.\nA template used to dynamically determine whether the webhook should execute based on the content of the payload.',
                                    type: 'string',
                                  },
                                  triggerType: {
                                    description: '(String) The type of event that will cause this outgoing webhook to execute. The types of triggers are: escalation, alert group created, acknowledge, resolve, silence, unsilence, unresolve, unacknowledge. Defaults to escalation.\nThe type of event that will cause this outgoing webhook to execute. The types of triggers are: `escalation`, `alert group created`, `acknowledge`, `resolve`, `silence`, `unsilence`, `unresolve`, `unacknowledge`. Defaults to `escalation`.',
                                    type: 'string',
                                  },
                                  url: {
                                    description: '(String) The webhook URL.\nThe webhook URL.',
                                    type: 'string',
                                  },
                                  user: {
                                    description: '(String) Username to use when making the outgoing webhook request.\nUsername to use when making the outgoing webhook request.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.url is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.url) || (has(self.initProvider) && has(self.initProvider.url))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      route: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xroutes.oncall.grafana.crossplane.io.namespaced',
            },
            name: 'route-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oncall.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XRoute',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oncall.grafana.crossplane.io/v1alpha1',
                  kind: 'Route',
                },
                name: 'route',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainId',
                    toFieldPath: 'spec.forProvider.escalationChainId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainRef.name',
                    toFieldPath: 'spec.forProvider.escalationChainRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.escalationChainRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.escalationChainRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.escalationChainSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.escalationChainSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.escalationChainSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.escalationChainSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.escalationChainSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.integrationId',
                    toFieldPath: 'spec.forProvider.integrationId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.integrationRef.name',
                    toFieldPath: 'spec.forProvider.integrationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.integrationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.integrationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.integrationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.integrationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.integrationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.integrationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.integrationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.integrationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.integrationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.integrationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.integrationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.integrationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.msteams',
                    toFieldPath: 'spec.forProvider.msteams',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.position',
                    toFieldPath: 'spec.forProvider.position',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.routingRegex',
                    toFieldPath: 'spec.forProvider.routingRegex',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.routingType',
                    toFieldPath: 'spec.forProvider.routingType',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.slack',
                    toFieldPath: 'spec.forProvider.slack',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.telegram',
                    toFieldPath: 'spec.forProvider.telegram',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainId',
                    toFieldPath: 'spec.initProvider.escalationChainId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainRef.name',
                    toFieldPath: 'spec.initProvider.escalationChainRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.escalationChainRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.escalationChainRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.escalationChainSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.escalationChainSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.escalationChainSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.escalationChainSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.escalationChainSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.integrationId',
                    toFieldPath: 'spec.initProvider.integrationId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.integrationRef.name',
                    toFieldPath: 'spec.initProvider.integrationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.integrationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.integrationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.integrationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.integrationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.integrationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.integrationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.integrationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.integrationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.integrationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.integrationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.integrationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.integrationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.msteams',
                    toFieldPath: 'spec.initProvider.msteams',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.position',
                    toFieldPath: 'spec.initProvider.position',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.routingRegex',
                    toFieldPath: 'spec.initProvider.routingRegex',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.routingType',
                    toFieldPath: 'spec.initProvider.routingType',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.slack',
                    toFieldPath: 'spec.initProvider.slack',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.telegram',
                    toFieldPath: 'spec.initProvider.telegram',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xroutes.oncall.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Route',
              plural: 'routes',
            },
            defaultCompositionRef: {
              name: 'route-namespaced',
            },
            group: 'oncall.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XRoute',
              plural: 'xroutes',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'RouteSpec defines the desired state of Route',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  escalationChainId: {
                                    description: '(String) The ID of the escalation chain.\nThe ID of the escalation chain.',
                                    type: 'string',
                                  },
                                  escalationChainRef: {
                                    description: 'Reference to a EscalationChain in oncall to populate escalationChainId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  escalationChainSelector: {
                                    description: 'Selector for a EscalationChain in oncall to populate escalationChainId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  integrationId: {
                                    description: '(String) The ID of the integration.\nThe ID of the integration.',
                                    type: 'string',
                                  },
                                  integrationRef: {
                                    description: 'Reference to a Integration in oncall to populate integrationId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  integrationSelector: {
                                    description: 'Selector for a Integration in oncall to populate integrationId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  msteams: {
                                    description: 'specific settings for a route. (see below for nested schema)\nMS teams-specific settings for a route.',
                                    items: {
                                      properties: {
                                        enabled: {
                                          description: '(Boolean) Enable notification in MS teams. Defaults to true.\nEnable notification in MS teams. Defaults to `true`.',
                                          type: 'boolean',
                                        },
                                        id: {
                                          description: '(String) The ID of this resource.\nMS teams channel id. Alerts will be directed to this channel in Microsoft teams.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  position: {
                                    description: '(Number) The position of the route (starts from 0).\nThe position of the route (starts from 0).',
                                    type: 'number',
                                  },
                                  routingRegex: {
                                    description: '(String) Python Regex query. Route is chosen for an alert if there is a match inside the alert payload.\nPython Regex query. Route is chosen for an alert if there is a match inside the alert payload.',
                                    type: 'string',
                                  },
                                  routingType: {
                                    description: '(String) The type of route. Can be jinja2, regex Defaults to regex.\nThe type of route. Can be jinja2, regex Defaults to `regex`.',
                                    type: 'string',
                                  },
                                  slack: {
                                    description: 'specific settings for a route. (see below for nested schema)\nSlack-specific settings for a route.',
                                    items: {
                                      properties: {
                                        channelId: {
                                          description: '(String) Slack channel id. Alerts will be directed to this channel in Slack.\nSlack channel id. Alerts will be directed to this channel in Slack.',
                                          type: 'string',
                                        },
                                        enabled: {
                                          description: '(Boolean) Enable notification in MS teams. Defaults to true.\nEnable notification in Slack. Defaults to `true`.',
                                          type: 'boolean',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  telegram: {
                                    description: 'specific settings for a route. (see below for nested schema)\nTelegram-specific settings for a route.',
                                    items: {
                                      properties: {
                                        enabled: {
                                          description: '(Boolean) Enable notification in MS teams. Defaults to true.\nEnable notification in Telegram. Defaults to `true`.',
                                          type: 'boolean',
                                        },
                                        id: {
                                          description: '(String) The ID of this resource.\nTelegram channel id. Alerts will be directed to this channel in Telegram.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  escalationChainId: {
                                    description: '(String) The ID of the escalation chain.\nThe ID of the escalation chain.',
                                    type: 'string',
                                  },
                                  escalationChainRef: {
                                    description: 'Reference to a EscalationChain in oncall to populate escalationChainId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  escalationChainSelector: {
                                    description: 'Selector for a EscalationChain in oncall to populate escalationChainId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  integrationId: {
                                    description: '(String) The ID of the integration.\nThe ID of the integration.',
                                    type: 'string',
                                  },
                                  integrationRef: {
                                    description: 'Reference to a Integration in oncall to populate integrationId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  integrationSelector: {
                                    description: 'Selector for a Integration in oncall to populate integrationId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  msteams: {
                                    description: 'specific settings for a route. (see below for nested schema)\nMS teams-specific settings for a route.',
                                    items: {
                                      properties: {
                                        enabled: {
                                          description: '(Boolean) Enable notification in MS teams. Defaults to true.\nEnable notification in MS teams. Defaults to `true`.',
                                          type: 'boolean',
                                        },
                                        id: {
                                          description: '(String) The ID of this resource.\nMS teams channel id. Alerts will be directed to this channel in Microsoft teams.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  position: {
                                    description: '(Number) The position of the route (starts from 0).\nThe position of the route (starts from 0).',
                                    type: 'number',
                                  },
                                  routingRegex: {
                                    description: '(String) Python Regex query. Route is chosen for an alert if there is a match inside the alert payload.\nPython Regex query. Route is chosen for an alert if there is a match inside the alert payload.',
                                    type: 'string',
                                  },
                                  routingType: {
                                    description: '(String) The type of route. Can be jinja2, regex Defaults to regex.\nThe type of route. Can be jinja2, regex Defaults to `regex`.',
                                    type: 'string',
                                  },
                                  slack: {
                                    description: 'specific settings for a route. (see below for nested schema)\nSlack-specific settings for a route.',
                                    items: {
                                      properties: {
                                        channelId: {
                                          description: '(String) Slack channel id. Alerts will be directed to this channel in Slack.\nSlack channel id. Alerts will be directed to this channel in Slack.',
                                          type: 'string',
                                        },
                                        enabled: {
                                          description: '(Boolean) Enable notification in MS teams. Defaults to true.\nEnable notification in Slack. Defaults to `true`.',
                                          type: 'boolean',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  telegram: {
                                    description: 'specific settings for a route. (see below for nested schema)\nTelegram-specific settings for a route.',
                                    items: {
                                      properties: {
                                        enabled: {
                                          description: '(Boolean) Enable notification in MS teams. Defaults to true.\nEnable notification in Telegram. Defaults to `true`.',
                                          type: 'boolean',
                                        },
                                        id: {
                                          description: '(String) The ID of this resource.\nTelegram channel id. Alerts will be directed to this channel in Telegram.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.position is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.position) || (has(self.initProvider) && has(self.initProvider.position))",
                              },
                              {
                                message: 'spec.forProvider.routingRegex is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.routingRegex) || (has(self.initProvider) && has(self.initProvider.routingRegex))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      schedule: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xschedules.oncall.grafana.crossplane.io.namespaced',
            },
            name: 'schedule-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oncall.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XSchedule',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oncall.grafana.crossplane.io/v1alpha1',
                  kind: 'Schedule',
                },
                name: 'schedule',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.enableWebOverrides',
                    toFieldPath: 'spec.forProvider.enableWebOverrides',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.icalUrlOverrides',
                    toFieldPath: 'spec.forProvider.icalUrlOverrides',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.icalUrlPrimary',
                    toFieldPath: 'spec.forProvider.icalUrlPrimary',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.shifts',
                    toFieldPath: 'spec.forProvider.shifts',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.shiftsRef',
                    toFieldPath: 'spec.forProvider.shiftsRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.shiftsSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.shiftsSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.shiftsSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.shiftsSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.shiftsSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.shiftsSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.shiftsSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.shiftsSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.slack',
                    toFieldPath: 'spec.forProvider.slack',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamId',
                    toFieldPath: 'spec.forProvider.teamId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.timeZone',
                    toFieldPath: 'spec.forProvider.timeZone',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.type',
                    toFieldPath: 'spec.forProvider.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.enableWebOverrides',
                    toFieldPath: 'spec.initProvider.enableWebOverrides',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.icalUrlOverrides',
                    toFieldPath: 'spec.initProvider.icalUrlOverrides',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.icalUrlPrimary',
                    toFieldPath: 'spec.initProvider.icalUrlPrimary',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.shifts',
                    toFieldPath: 'spec.initProvider.shifts',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.shiftsRef',
                    toFieldPath: 'spec.initProvider.shiftsRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.shiftsSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.shiftsSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.shiftsSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.shiftsSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.shiftsSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.shiftsSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.shiftsSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.shiftsSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.slack',
                    toFieldPath: 'spec.initProvider.slack',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamId',
                    toFieldPath: 'spec.initProvider.teamId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.timeZone',
                    toFieldPath: 'spec.initProvider.timeZone',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.type',
                    toFieldPath: 'spec.initProvider.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xschedules.oncall.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Schedule',
              plural: 'schedules',
            },
            defaultCompositionRef: {
              name: 'schedule-namespaced',
            },
            group: 'oncall.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XSchedule',
              plural: 'xschedules',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'ScheduleSpec defines the desired state of Schedule',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  enableWebOverrides: {
                                    description: '(Boolean) Enable overrides via web UI (it will ignore ical_url_overrides).\nEnable overrides via web UI (it will ignore ical_url_overrides).',
                                    type: 'boolean',
                                  },
                                  icalUrlOverrides: {
                                    description: '(String) The URL of external iCal calendar which override primary events.\nThe URL of external iCal calendar which override primary events.',
                                    type: 'string',
                                  },
                                  icalUrlPrimary: {
                                    description: '(String) The URL of the external calendar iCal file.\nThe URL of the external calendar iCal file.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: "(String) The schedule's name.\nThe schedule's name.",
                                    type: 'string',
                                  },
                                  shifts: {
                                    description: "call shifts.\nThe list of ID's of on-call shifts.",
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  shiftsRef: {
                                    description: 'References to OnCallShift in oncall to populate shifts.',
                                    items: {
                                      description: 'A Reference to a named object.',
                                      properties: {
                                        name: {
                                          description: 'Name of the referenced object.',
                                          type: 'string',
                                        },
                                        policy: {
                                          description: 'Policies for referencing.',
                                          properties: {
                                            resolution: {
                                              default: 'Required',
                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                              enum: [
                                                'Required',
                                                'Optional',
                                              ],
                                              type: 'string',
                                            },
                                            resolve: {
                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                              enum: [
                                                'Always',
                                                'IfNotPresent',
                                              ],
                                              type: 'string',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'name',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  shiftsSelector: {
                                    description: 'Selector for a list of OnCallShift in oncall to populate shifts.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  slack: {
                                    description: 'specific settings for a schedule. (see below for nested schema)\nThe Slack-specific settings for a schedule.',
                                    items: {
                                      properties: {
                                        channelId: {
                                          description: '(String) Slack channel id. Reminder about schedule shifts will be directed to this channel in Slack.\nSlack channel id. Reminder about schedule shifts will be directed to this channel in Slack.',
                                          type: 'string',
                                        },
                                        userGroupId: {
                                          description: 'call users change.\nSlack user group id. Members of user group will be updated when on-call users change.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  teamId: {
                                    description: '(String) The ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the grafana_oncall_team datasource.\nThe ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the `grafana_oncall_team` datasource.',
                                    type: 'string',
                                  },
                                  timeZone: {
                                    description: "(String) The schedule's time zone.\nThe schedule's time zone.",
                                    type: 'string',
                                  },
                                  type: {
                                    description: "(String) The schedule's type. Valid values are ical, calendar.\nThe schedule's type. Valid values are `ical`, `calendar`.",
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  enableWebOverrides: {
                                    description: '(Boolean) Enable overrides via web UI (it will ignore ical_url_overrides).\nEnable overrides via web UI (it will ignore ical_url_overrides).',
                                    type: 'boolean',
                                  },
                                  icalUrlOverrides: {
                                    description: '(String) The URL of external iCal calendar which override primary events.\nThe URL of external iCal calendar which override primary events.',
                                    type: 'string',
                                  },
                                  icalUrlPrimary: {
                                    description: '(String) The URL of the external calendar iCal file.\nThe URL of the external calendar iCal file.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: "(String) The schedule's name.\nThe schedule's name.",
                                    type: 'string',
                                  },
                                  shifts: {
                                    description: "call shifts.\nThe list of ID's of on-call shifts.",
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  shiftsRef: {
                                    description: 'References to OnCallShift in oncall to populate shifts.',
                                    items: {
                                      description: 'A Reference to a named object.',
                                      properties: {
                                        name: {
                                          description: 'Name of the referenced object.',
                                          type: 'string',
                                        },
                                        policy: {
                                          description: 'Policies for referencing.',
                                          properties: {
                                            resolution: {
                                              default: 'Required',
                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                              enum: [
                                                'Required',
                                                'Optional',
                                              ],
                                              type: 'string',
                                            },
                                            resolve: {
                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                              enum: [
                                                'Always',
                                                'IfNotPresent',
                                              ],
                                              type: 'string',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'name',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  shiftsSelector: {
                                    description: 'Selector for a list of OnCallShift in oncall to populate shifts.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  slack: {
                                    description: 'specific settings for a schedule. (see below for nested schema)\nThe Slack-specific settings for a schedule.',
                                    items: {
                                      properties: {
                                        channelId: {
                                          description: '(String) Slack channel id. Reminder about schedule shifts will be directed to this channel in Slack.\nSlack channel id. Reminder about schedule shifts will be directed to this channel in Slack.',
                                          type: 'string',
                                        },
                                        userGroupId: {
                                          description: 'call users change.\nSlack user group id. Members of user group will be updated when on-call users change.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  teamId: {
                                    description: '(String) The ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the grafana_oncall_team datasource.\nThe ID of the OnCall team. To get one, create a team in Grafana, and navigate to the OnCall plugin (to sync the team with OnCall). You can then get the ID using the `grafana_oncall_team` datasource.',
                                    type: 'string',
                                  },
                                  timeZone: {
                                    description: "(String) The schedule's time zone.\nThe schedule's time zone.",
                                    type: 'string',
                                  },
                                  type: {
                                    description: "(String) The schedule's type. Valid values are ical, calendar.\nThe schedule's type. Valid values are `ical`, `calendar`.",
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.type is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.type) || (has(self.initProvider) && has(self.initProvider.type))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      userNotificationRule: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xusernotificationrules.oncall.grafana.crossplane.io.namespaced',
            },
            name: 'usernotificationrule-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oncall.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XUserNotificationRule',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oncall.grafana.crossplane.io/v1alpha1',
                  kind: 'UserNotificationRule',
                },
                name: 'usernotificationrule',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.duration',
                    toFieldPath: 'spec.forProvider.duration',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.important',
                    toFieldPath: 'spec.forProvider.important',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.position',
                    toFieldPath: 'spec.forProvider.position',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.type',
                    toFieldPath: 'spec.forProvider.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.userId',
                    toFieldPath: 'spec.forProvider.userId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.duration',
                    toFieldPath: 'spec.initProvider.duration',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.important',
                    toFieldPath: 'spec.initProvider.important',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.position',
                    toFieldPath: 'spec.initProvider.position',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.type',
                    toFieldPath: 'spec.initProvider.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.userId',
                    toFieldPath: 'spec.initProvider.userId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xusernotificationrules.oncall.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'UserNotificationRule',
              plural: 'usernotificationrules',
            },
            defaultCompositionRef: {
              name: 'usernotificationrule-namespaced',
            },
            group: 'oncall.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XUserNotificationRule',
              plural: 'xusernotificationrules',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'UserNotificationRuleSpec defines the desired state of UserNotificationRule',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  duration: {
                                    description: '(Number) A time in seconds to wait (when type=wait). Can be 60, 300, 900, 1800, 3600\nA time in seconds to wait (when `type=wait`). Can be 60, 300, 900, 1800, 3600',
                                    type: 'number',
                                  },
                                  important: {
                                    description: '(Boolean) Boolean value which indicates if a rule is “important”\nBoolean value which indicates if a rule is “important”',
                                    type: 'boolean',
                                  },
                                  position: {
                                    description: '(Number) Personal notification rules execute one after another starting from position=0. A new escalation policy created with a position of an existing escalation policy will move the old one (and all following) down on the list.\nPersonal notification rules execute one after another starting from position=0. A new escalation policy created with a position of an existing escalation policy will move the old one (and all following) down on the list.',
                                    type: 'number',
                                  },
                                  type: {
                                    description: '(String) The type of notification rule. Can be wait, notify_by_slack, notify_by_msteams, notify_by_sms, notify_by_phone_call, notify_by_telegram, notify_by_email, notify_by_mobile_app, notify_by_mobile_app_critical. NOTE: notify_by_msteams is only available for Grafana Cloud customers.\nThe type of notification rule. Can be wait, notify_by_slack, notify_by_msteams, notify_by_sms, notify_by_phone_call, notify_by_telegram, notify_by_email, notify_by_mobile_app, notify_by_mobile_app_critical. NOTE: `notify_by_msteams` is only available for Grafana Cloud customers.',
                                    type: 'string',
                                  },
                                  userId: {
                                    description: '(String) User ID\nUser ID',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  duration: {
                                    description: '(Number) A time in seconds to wait (when type=wait). Can be 60, 300, 900, 1800, 3600\nA time in seconds to wait (when `type=wait`). Can be 60, 300, 900, 1800, 3600',
                                    type: 'number',
                                  },
                                  important: {
                                    description: '(Boolean) Boolean value which indicates if a rule is “important”\nBoolean value which indicates if a rule is “important”',
                                    type: 'boolean',
                                  },
                                  position: {
                                    description: '(Number) Personal notification rules execute one after another starting from position=0. A new escalation policy created with a position of an existing escalation policy will move the old one (and all following) down on the list.\nPersonal notification rules execute one after another starting from position=0. A new escalation policy created with a position of an existing escalation policy will move the old one (and all following) down on the list.',
                                    type: 'number',
                                  },
                                  type: {
                                    description: '(String) The type of notification rule. Can be wait, notify_by_slack, notify_by_msteams, notify_by_sms, notify_by_phone_call, notify_by_telegram, notify_by_email, notify_by_mobile_app, notify_by_mobile_app_critical. NOTE: notify_by_msteams is only available for Grafana Cloud customers.\nThe type of notification rule. Can be wait, notify_by_slack, notify_by_msteams, notify_by_sms, notify_by_phone_call, notify_by_telegram, notify_by_email, notify_by_mobile_app, notify_by_mobile_app_critical. NOTE: `notify_by_msteams` is only available for Grafana Cloud customers.',
                                    type: 'string',
                                  },
                                  userId: {
                                    description: '(String) User ID\nUser ID',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.type is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.type) || (has(self.initProvider) && has(self.initProvider.type))",
                              },
                              {
                                message: 'spec.forProvider.userId is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.userId) || (has(self.initProvider) && has(self.initProvider.userId))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
    },
  },
  oss: {
    v1alpha1: {
      annotation: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xannotations.oss.grafana.crossplane.io.namespaced',
            },
            name: 'annotation-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XAnnotation',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'Annotation',
                },
                name: 'annotation',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardRef.name',
                    toFieldPath: 'spec.forProvider.dashboardRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.dashboardRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.dashboardRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.dashboardSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.dashboardSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.dashboardSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.dashboardSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardUid',
                    toFieldPath: 'spec.forProvider.dashboardUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.panelId',
                    toFieldPath: 'spec.forProvider.panelId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.tags',
                    toFieldPath: 'spec.forProvider.tags',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.text',
                    toFieldPath: 'spec.forProvider.text',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.time',
                    toFieldPath: 'spec.forProvider.time',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.timeEnd',
                    toFieldPath: 'spec.forProvider.timeEnd',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardRef.name',
                    toFieldPath: 'spec.initProvider.dashboardRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.dashboardRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.dashboardRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.dashboardSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.dashboardSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.dashboardSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.dashboardSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardUid',
                    toFieldPath: 'spec.initProvider.dashboardUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.panelId',
                    toFieldPath: 'spec.initProvider.panelId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.tags',
                    toFieldPath: 'spec.initProvider.tags',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.text',
                    toFieldPath: 'spec.initProvider.text',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.time',
                    toFieldPath: 'spec.initProvider.time',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.timeEnd',
                    toFieldPath: 'spec.initProvider.timeEnd',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xannotations.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Annotation',
              plural: 'annotations',
            },
            defaultCompositionRef: {
              name: 'annotation-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XAnnotation',
              plural: 'xannotations',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'AnnotationSpec defines the desired state of Annotation',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  dashboardRef: {
                                    description: 'Reference to a Dashboard in oss to populate dashboardUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  dashboardSelector: {
                                    description: 'Selector for a Dashboard in oss to populate dashboardUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  dashboardUid: {
                                    description: '(String) The UID of the dashboard on which to create the annotation.\nThe UID of the dashboard on which to create the annotation.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  panelId: {
                                    description: '(Number) The ID of the dashboard panel on which to create the annotation.\nThe ID of the dashboard panel on which to create the annotation.',
                                    type: 'number',
                                  },
                                  tags: {
                                    description: '(Set of String) The tags to associate with the annotation.\nThe tags to associate with the annotation.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  text: {
                                    description: '(String) The text to associate with the annotation.\nThe text to associate with the annotation.',
                                    type: 'string',
                                  },
                                  time: {
                                    description: "formatted time string indicating the annotation's time.\nThe RFC 3339-formatted time string indicating the annotation's time.",
                                    type: 'string',
                                  },
                                  timeEnd: {
                                    description: "formatted time string indicating the annotation's end time.\nThe RFC 3339-formatted time string indicating the annotation's end time.",
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  dashboardRef: {
                                    description: 'Reference to a Dashboard in oss to populate dashboardUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  dashboardSelector: {
                                    description: 'Selector for a Dashboard in oss to populate dashboardUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  dashboardUid: {
                                    description: '(String) The UID of the dashboard on which to create the annotation.\nThe UID of the dashboard on which to create the annotation.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  panelId: {
                                    description: '(Number) The ID of the dashboard panel on which to create the annotation.\nThe ID of the dashboard panel on which to create the annotation.',
                                    type: 'number',
                                  },
                                  tags: {
                                    description: '(Set of String) The tags to associate with the annotation.\nThe tags to associate with the annotation.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  text: {
                                    description: '(String) The text to associate with the annotation.\nThe text to associate with the annotation.',
                                    type: 'string',
                                  },
                                  time: {
                                    description: "formatted time string indicating the annotation's time.\nThe RFC 3339-formatted time string indicating the annotation's time.",
                                    type: 'string',
                                  },
                                  timeEnd: {
                                    description: "formatted time string indicating the annotation's end time.\nThe RFC 3339-formatted time string indicating the annotation's end time.",
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.text is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.text) || (has(self.initProvider) && has(self.initProvider.text))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      dashboard: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xdashboards.oss.grafana.crossplane.io.namespaced',
            },
            name: 'dashboard-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XDashboard',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'Dashboard',
                },
                name: 'dashboard',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.configJson',
                    toFieldPath: 'spec.forProvider.configJson',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folder',
                    toFieldPath: 'spec.forProvider.folder',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.name',
                    toFieldPath: 'spec.forProvider.folderRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.folderRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.folderRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.folderSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.folderSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.folderSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.folderSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.message',
                    toFieldPath: 'spec.forProvider.message',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.overwrite',
                    toFieldPath: 'spec.forProvider.overwrite',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.configJson',
                    toFieldPath: 'spec.initProvider.configJson',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folder',
                    toFieldPath: 'spec.initProvider.folder',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.name',
                    toFieldPath: 'spec.initProvider.folderRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.folderRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.folderRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.folderSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.folderSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.folderSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.folderSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.message',
                    toFieldPath: 'spec.initProvider.message',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.overwrite',
                    toFieldPath: 'spec.initProvider.overwrite',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xdashboards.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Dashboard',
              plural: 'dashboards',
            },
            defaultCompositionRef: {
              name: 'dashboard-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XDashboard',
              plural: 'xdashboards',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'DashboardSpec defines the desired state of Dashboard',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  configJson: {
                                    description: '(String) The complete dashboard model JSON.\nThe complete dashboard model JSON.',
                                    type: 'string',
                                  },
                                  folder: {
                                    description: '(String) The id or UID of the folder to save the dashboard in.\nThe id or UID of the folder to save the dashboard in.',
                                    type: 'string',
                                  },
                                  folderRef: {
                                    description: 'Reference to a Folder in oss to populate folder.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  folderSelector: {
                                    description: 'Selector for a Folder in oss to populate folder.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  message: {
                                    description: '(String) Set a commit message for the version history.\nSet a commit message for the version history.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  overwrite: {
                                    description: '(Boolean) Set to true if you want to overwrite existing dashboard with newer version, same dashboard title in folder or same dashboard uid.\nSet to true if you want to overwrite existing dashboard with newer version, same dashboard title in folder or same dashboard uid.',
                                    type: 'boolean',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  configJson: {
                                    description: '(String) The complete dashboard model JSON.\nThe complete dashboard model JSON.',
                                    type: 'string',
                                  },
                                  folder: {
                                    description: '(String) The id or UID of the folder to save the dashboard in.\nThe id or UID of the folder to save the dashboard in.',
                                    type: 'string',
                                  },
                                  folderRef: {
                                    description: 'Reference to a Folder in oss to populate folder.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  folderSelector: {
                                    description: 'Selector for a Folder in oss to populate folder.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  message: {
                                    description: '(String) Set a commit message for the version history.\nSet a commit message for the version history.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  overwrite: {
                                    description: '(Boolean) Set to true if you want to overwrite existing dashboard with newer version, same dashboard title in folder or same dashboard uid.\nSet to true if you want to overwrite existing dashboard with newer version, same dashboard title in folder or same dashboard uid.',
                                    type: 'boolean',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.configJson is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.configJson) || (has(self.initProvider) && has(self.initProvider.configJson))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      dashboardPermission: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xdashboardpermissions.oss.grafana.crossplane.io.namespaced',
            },
            name: 'dashboardpermission-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XDashboardPermission',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'DashboardPermission',
                },
                name: 'dashboardpermission',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardRef.name',
                    toFieldPath: 'spec.forProvider.dashboardRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.dashboardRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.dashboardRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.dashboardSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.dashboardSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.dashboardSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.dashboardSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardUid',
                    toFieldPath: 'spec.forProvider.dashboardUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.permissions',
                    toFieldPath: 'spec.forProvider.permissions',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardRef.name',
                    toFieldPath: 'spec.initProvider.dashboardRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.dashboardRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.dashboardRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.dashboardSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.dashboardSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.dashboardSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.dashboardSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardUid',
                    toFieldPath: 'spec.initProvider.dashboardUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.permissions',
                    toFieldPath: 'spec.initProvider.permissions',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xdashboardpermissions.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'DashboardPermission',
              plural: 'dashboardpermissions',
            },
            defaultCompositionRef: {
              name: 'dashboardpermission-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XDashboardPermission',
              plural: 'xdashboardpermissions',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'DashboardPermissionSpec defines the desired state of DashboardPermission',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  dashboardRef: {
                                    description: 'Reference to a Dashboard in oss to populate dashboardUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  dashboardSelector: {
                                    description: 'Selector for a Dashboard in oss to populate dashboardUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  dashboardUid: {
                                    description: '(String) UID of the dashboard to apply permissions to.\nUID of the dashboard to apply permissions to.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  permissions: {
                                    description: '(Block Set) The permission items to add/update. Items that are omitted from the list will be removed. (see below for nested schema)\nThe permission items to add/update. Items that are omitted from the list will be removed.',
                                    items: {
                                      properties: {
                                        permission: {
                                          description: '(String) Permission to associate with item. Must be one of View, Edit, or Admin.\nPermission to associate with item. Must be one of `View`, `Edit`, or `Admin`.',
                                          type: 'string',
                                        },
                                        role: {
                                          description: '(String) Name of the basic role to manage permissions for. Options: Viewer, Editor or Admin.\nName of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.',
                                          type: 'string',
                                        },
                                        teamId: {
                                          description: '(String) ID of the team to manage permissions for. Defaults to 0.\nID of the team to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        teamRef: {
                                          description: 'Reference to a Team in oss to populate teamId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        teamSelector: {
                                          description: 'Selector for a Team in oss to populate teamId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        userId: {
                                          description: '(String) ID of the user or service account to manage permissions for. Defaults to 0.\nID of the user or service account to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        userRef: {
                                          description: 'Reference to a User in oss to populate userId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        userSelector: {
                                          description: 'Selector for a User in oss to populate userId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  dashboardRef: {
                                    description: 'Reference to a Dashboard in oss to populate dashboardUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  dashboardSelector: {
                                    description: 'Selector for a Dashboard in oss to populate dashboardUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  dashboardUid: {
                                    description: '(String) UID of the dashboard to apply permissions to.\nUID of the dashboard to apply permissions to.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  permissions: {
                                    description: '(Block Set) The permission items to add/update. Items that are omitted from the list will be removed. (see below for nested schema)\nThe permission items to add/update. Items that are omitted from the list will be removed.',
                                    items: {
                                      properties: {
                                        permission: {
                                          description: '(String) Permission to associate with item. Must be one of View, Edit, or Admin.\nPermission to associate with item. Must be one of `View`, `Edit`, or `Admin`.',
                                          type: 'string',
                                        },
                                        role: {
                                          description: '(String) Name of the basic role to manage permissions for. Options: Viewer, Editor or Admin.\nName of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.',
                                          type: 'string',
                                        },
                                        teamId: {
                                          description: '(String) ID of the team to manage permissions for. Defaults to 0.\nID of the team to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        teamRef: {
                                          description: 'Reference to a Team in oss to populate teamId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        teamSelector: {
                                          description: 'Selector for a Team in oss to populate teamId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        userId: {
                                          description: '(String) ID of the user or service account to manage permissions for. Defaults to 0.\nID of the user or service account to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        userRef: {
                                          description: 'Reference to a User in oss to populate userId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        userSelector: {
                                          description: 'Selector for a User in oss to populate userId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      dashboardPublic: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xdashboardpublics.oss.grafana.crossplane.io.namespaced',
            },
            name: 'dashboardpublic-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XDashboardPublic',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'DashboardPublic',
                },
                name: 'dashboardpublic',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.accessToken',
                    toFieldPath: 'spec.forProvider.accessToken',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.annotationsEnabled',
                    toFieldPath: 'spec.forProvider.annotationsEnabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardRef.name',
                    toFieldPath: 'spec.forProvider.dashboardRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.dashboardRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.dashboardRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.dashboardSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.dashboardSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.dashboardSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.dashboardSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.dashboardUid',
                    toFieldPath: 'spec.forProvider.dashboardUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.isEnabled',
                    toFieldPath: 'spec.forProvider.isEnabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.share',
                    toFieldPath: 'spec.forProvider.share',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.timeSelectionEnabled',
                    toFieldPath: 'spec.forProvider.timeSelectionEnabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.uid',
                    toFieldPath: 'spec.forProvider.uid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.accessToken',
                    toFieldPath: 'spec.initProvider.accessToken',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.annotationsEnabled',
                    toFieldPath: 'spec.initProvider.annotationsEnabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardRef.name',
                    toFieldPath: 'spec.initProvider.dashboardRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.dashboardRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.dashboardRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.dashboardSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.dashboardSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.dashboardSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.dashboardSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.dashboardUid',
                    toFieldPath: 'spec.initProvider.dashboardUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.isEnabled',
                    toFieldPath: 'spec.initProvider.isEnabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.share',
                    toFieldPath: 'spec.initProvider.share',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.timeSelectionEnabled',
                    toFieldPath: 'spec.initProvider.timeSelectionEnabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.uid',
                    toFieldPath: 'spec.initProvider.uid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xdashboardpublics.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'DashboardPublic',
              plural: 'dashboardpublics',
            },
            defaultCompositionRef: {
              name: 'dashboardpublic-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XDashboardPublic',
              plural: 'xdashboardpublics',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'DashboardPublicSpec defines the desired state of DashboardPublic',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  accessToken: {
                                    description: "(String) A public unique identifier of a public dashboard. This is used to construct its URL. It's automatically generated if not provided when creating a public dashboard.\nA public unique identifier of a public dashboard. This is used to construct its URL. It's automatically generated if not provided when creating a public dashboard.",
                                    type: 'string',
                                  },
                                  annotationsEnabled: {
                                    description: '(Boolean) Set to true to show annotations. The default value is false.\nSet to `true` to show annotations. The default value is `false`.',
                                    type: 'boolean',
                                  },
                                  dashboardRef: {
                                    description: 'Reference to a Dashboard in oss to populate dashboardUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  dashboardSelector: {
                                    description: 'Selector for a Dashboard in oss to populate dashboardUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  dashboardUid: {
                                    description: '(String) The unique identifier of the original dashboard.\nThe unique identifier of the original dashboard.',
                                    type: 'string',
                                  },
                                  isEnabled: {
                                    description: '(Boolean) Set to true to enable the public dashboard. The default value is false.\nSet to `true` to enable the public dashboard. The default value is `false`.',
                                    type: 'boolean',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  share: {
                                    description: '(String) Set the share mode. The default value is public.\nSet the share mode. The default value is `public`.',
                                    type: 'string',
                                  },
                                  timeSelectionEnabled: {
                                    description: '(Boolean) Set to true to enable the time picker in the public dashboard. The default value is false.\nSet to `true` to enable the time picker in the public dashboard. The default value is `false`.',
                                    type: 'boolean',
                                  },
                                  uid: {
                                    description: "(String) The unique identifier of a public dashboard. It's automatically generated if not provided when creating a public dashboard.\nThe unique identifier of a public dashboard. It's automatically generated if not provided when creating a public dashboard.",
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  accessToken: {
                                    description: "(String) A public unique identifier of a public dashboard. This is used to construct its URL. It's automatically generated if not provided when creating a public dashboard.\nA public unique identifier of a public dashboard. This is used to construct its URL. It's automatically generated if not provided when creating a public dashboard.",
                                    type: 'string',
                                  },
                                  annotationsEnabled: {
                                    description: '(Boolean) Set to true to show annotations. The default value is false.\nSet to `true` to show annotations. The default value is `false`.',
                                    type: 'boolean',
                                  },
                                  dashboardRef: {
                                    description: 'Reference to a Dashboard in oss to populate dashboardUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  dashboardSelector: {
                                    description: 'Selector for a Dashboard in oss to populate dashboardUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  dashboardUid: {
                                    description: '(String) The unique identifier of the original dashboard.\nThe unique identifier of the original dashboard.',
                                    type: 'string',
                                  },
                                  isEnabled: {
                                    description: '(Boolean) Set to true to enable the public dashboard. The default value is false.\nSet to `true` to enable the public dashboard. The default value is `false`.',
                                    type: 'boolean',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  share: {
                                    description: '(String) Set the share mode. The default value is public.\nSet the share mode. The default value is `public`.',
                                    type: 'string',
                                  },
                                  timeSelectionEnabled: {
                                    description: '(Boolean) Set to true to enable the time picker in the public dashboard. The default value is false.\nSet to `true` to enable the time picker in the public dashboard. The default value is `false`.',
                                    type: 'boolean',
                                  },
                                  uid: {
                                    description: "(String) The unique identifier of a public dashboard. It's automatically generated if not provided when creating a public dashboard.\nThe unique identifier of a public dashboard. It's automatically generated if not provided when creating a public dashboard.",
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      dataSource: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xdatasources.oss.grafana.crossplane.io.namespaced',
            },
            name: 'datasource-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XDataSource',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'DataSource',
                },
                name: 'datasource',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.accessMode',
                    toFieldPath: 'spec.forProvider.accessMode',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.basicAuthEnabled',
                    toFieldPath: 'spec.forProvider.basicAuthEnabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.basicAuthUsername',
                    toFieldPath: 'spec.forProvider.basicAuthUsername',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.databaseName',
                    toFieldPath: 'spec.forProvider.databaseName',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.httpHeadersSecretRef.name',
                    toFieldPath: 'spec.forProvider.httpHeadersSecretRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.httpHeadersSecretRef.namespace',
                    toFieldPath: 'spec.forProvider.httpHeadersSecretRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.isDefault',
                    toFieldPath: 'spec.forProvider.isDefault',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.jsonDataEncoded',
                    toFieldPath: 'spec.forProvider.jsonDataEncoded',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.secureJsonDataEncodedSecretRef.key',
                    toFieldPath: 'spec.forProvider.secureJsonDataEncodedSecretRef.key',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.secureJsonDataEncodedSecretRef.name',
                    toFieldPath: 'spec.forProvider.secureJsonDataEncodedSecretRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.secureJsonDataEncodedSecretRef.namespace',
                    toFieldPath: 'spec.forProvider.secureJsonDataEncodedSecretRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.type',
                    toFieldPath: 'spec.forProvider.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.uid',
                    toFieldPath: 'spec.forProvider.uid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.url',
                    toFieldPath: 'spec.forProvider.url',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.username',
                    toFieldPath: 'spec.forProvider.username',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.accessMode',
                    toFieldPath: 'spec.initProvider.accessMode',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.basicAuthEnabled',
                    toFieldPath: 'spec.initProvider.basicAuthEnabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.basicAuthUsername',
                    toFieldPath: 'spec.initProvider.basicAuthUsername',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.databaseName',
                    toFieldPath: 'spec.initProvider.databaseName',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.httpHeadersSecretRef',
                    toFieldPath: 'spec.initProvider.httpHeadersSecretRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.isDefault',
                    toFieldPath: 'spec.initProvider.isDefault',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.jsonDataEncoded',
                    toFieldPath: 'spec.initProvider.jsonDataEncoded',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.secureJsonDataEncodedSecretRef.key',
                    toFieldPath: 'spec.initProvider.secureJsonDataEncodedSecretRef.key',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.secureJsonDataEncodedSecretRef.name',
                    toFieldPath: 'spec.initProvider.secureJsonDataEncodedSecretRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.secureJsonDataEncodedSecretRef.namespace',
                    toFieldPath: 'spec.initProvider.secureJsonDataEncodedSecretRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.type',
                    toFieldPath: 'spec.initProvider.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.uid',
                    toFieldPath: 'spec.initProvider.uid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.url',
                    toFieldPath: 'spec.initProvider.url',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.username',
                    toFieldPath: 'spec.initProvider.username',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xdatasources.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'DataSource',
              plural: 'datasources',
            },
            defaultCompositionRef: {
              name: 'datasource-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XDataSource',
              plural: 'xdatasources',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'DataSourceSpec defines the desired state of DataSource',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  accessMode: {
                                    description: '(String) The method by which Grafana will access the data source: proxy or direct. Defaults to proxy.\nThe method by which Grafana will access the data source: `proxy` or `direct`. Defaults to `proxy`.',
                                    type: 'string',
                                  },
                                  basicAuthEnabled: {
                                    description: '(Boolean) Whether to enable basic auth for the data source. Defaults to false.\nWhether to enable basic auth for the data source. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  basicAuthUsername: {
                                    description: '(String) Basic auth username. Defaults to “.\nBasic auth username. Defaults to “.',
                                    type: 'string',
                                  },
                                  databaseName: {
                                    description: '(String)  The name of the database to use on the selected data source server. Defaults to “.\n(Required by some data source types) The name of the database to use on the selected data source server. Defaults to “.',
                                    type: 'string',
                                  },
                                  httpHeadersSecretRef: {
                                    description: '(Map of String, Sensitive) Custom HTTP headers\nCustom HTTP headers',
                                    properties: {
                                      name: {
                                        description: 'Name of the secret.',
                                        type: 'string',
                                      },
                                      namespace: {
                                        description: 'Namespace of the secret.',
                                        type: 'string',
                                      },
                                    },
                                    required: [
                                      'name',
                                      'namespace',
                                    ],
                                    type: 'object',
                                  },
                                  isDefault: {
                                    description: '(Boolean) Whether to set the data source as default. This should only be true to a single data source. Defaults to false.\nWhether to set the data source as default. This should only be `true` to a single data source. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  jsonDataEncoded: {
                                    description: '(String) Serialized JSON string containing the json data. This attribute can be used to pass configuration options to the data source. To figure out what options a datasource has available, see its docs or inspect the network data when saving it from the Grafana UI. Note that keys in this map are usually camelCased.\nSerialized JSON string containing the json data. This attribute can be used to pass configuration options to the data source. To figure out what options a datasource has available, see its docs or inspect the network data when saving it from the Grafana UI. Note that keys in this map are usually camelCased.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: '(String) A unique name for the data source.\nA unique name for the data source.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  secureJsonDataEncodedSecretRef: {
                                    description: '(String, Sensitive) Serialized JSON string containing the secure json data. This attribute can be used to pass secure configuration options to the data source. To figure out what options a datasource has available, see its docs or inspect the network data when saving it from the Grafana UI. Note that keys in this map are usually camelCased.\nSerialized JSON string containing the secure json data. This attribute can be used to pass secure configuration options to the data source. To figure out what options a datasource has available, see its docs or inspect the network data when saving it from the Grafana UI. Note that keys in this map are usually camelCased.',
                                    properties: {
                                      key: {
                                        description: 'The key to select.',
                                        type: 'string',
                                      },
                                      name: {
                                        description: 'Name of the secret.',
                                        type: 'string',
                                      },
                                      namespace: {
                                        description: 'Namespace of the secret.',
                                        type: 'string',
                                      },
                                    },
                                    required: [
                                      'key',
                                      'name',
                                      'namespace',
                                    ],
                                    type: 'object',
                                  },
                                  type: {
                                    description: '(String) The data source type. Must be one of the supported data source keywords.\nThe data source type. Must be one of the supported data source keywords.',
                                    type: 'string',
                                  },
                                  uid: {
                                    description: '(String) Unique identifier. If unset, this will be automatically generated.\nUnique identifier. If unset, this will be automatically generated.',
                                    type: 'string',
                                  },
                                  url: {
                                    description: '(String) The URL for the data source. The type of URL required varies depending on the chosen data source type.\nThe URL for the data source. The type of URL required varies depending on the chosen data source type.',
                                    type: 'string',
                                  },
                                  username: {
                                    description: '(String)  The username to use to authenticate to the data source. Defaults to “.\n(Required by some data source types) The username to use to authenticate to the data source. Defaults to “.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  accessMode: {
                                    description: '(String) The method by which Grafana will access the data source: proxy or direct. Defaults to proxy.\nThe method by which Grafana will access the data source: `proxy` or `direct`. Defaults to `proxy`.',
                                    type: 'string',
                                  },
                                  basicAuthEnabled: {
                                    description: '(Boolean) Whether to enable basic auth for the data source. Defaults to false.\nWhether to enable basic auth for the data source. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  basicAuthUsername: {
                                    description: '(String) Basic auth username. Defaults to “.\nBasic auth username. Defaults to “.',
                                    type: 'string',
                                  },
                                  databaseName: {
                                    description: '(String)  The name of the database to use on the selected data source server. Defaults to “.\n(Required by some data source types) The name of the database to use on the selected data source server. Defaults to “.',
                                    type: 'string',
                                  },
                                  httpHeadersSecretRef: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    type: 'object',
                                  },
                                  isDefault: {
                                    description: '(Boolean) Whether to set the data source as default. This should only be true to a single data source. Defaults to false.\nWhether to set the data source as default. This should only be `true` to a single data source. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  jsonDataEncoded: {
                                    description: '(String) Serialized JSON string containing the json data. This attribute can be used to pass configuration options to the data source. To figure out what options a datasource has available, see its docs or inspect the network data when saving it from the Grafana UI. Note that keys in this map are usually camelCased.\nSerialized JSON string containing the json data. This attribute can be used to pass configuration options to the data source. To figure out what options a datasource has available, see its docs or inspect the network data when saving it from the Grafana UI. Note that keys in this map are usually camelCased.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: '(String) A unique name for the data source.\nA unique name for the data source.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  secureJsonDataEncodedSecretRef: {
                                    description: '(String, Sensitive) Serialized JSON string containing the secure json data. This attribute can be used to pass secure configuration options to the data source. To figure out what options a datasource has available, see its docs or inspect the network data when saving it from the Grafana UI. Note that keys in this map are usually camelCased.\nSerialized JSON string containing the secure json data. This attribute can be used to pass secure configuration options to the data source. To figure out what options a datasource has available, see its docs or inspect the network data when saving it from the Grafana UI. Note that keys in this map are usually camelCased.',
                                    properties: {
                                      key: {
                                        description: 'The key to select.',
                                        type: 'string',
                                      },
                                      name: {
                                        description: 'Name of the secret.',
                                        type: 'string',
                                      },
                                      namespace: {
                                        description: 'Namespace of the secret.',
                                        type: 'string',
                                      },
                                    },
                                    required: [
                                      'key',
                                      'name',
                                      'namespace',
                                    ],
                                    type: 'object',
                                  },
                                  type: {
                                    description: '(String) The data source type. Must be one of the supported data source keywords.\nThe data source type. Must be one of the supported data source keywords.',
                                    type: 'string',
                                  },
                                  uid: {
                                    description: '(String) Unique identifier. If unset, this will be automatically generated.\nUnique identifier. If unset, this will be automatically generated.',
                                    type: 'string',
                                  },
                                  url: {
                                    description: '(String) The URL for the data source. The type of URL required varies depending on the chosen data source type.\nThe URL for the data source. The type of URL required varies depending on the chosen data source type.',
                                    type: 'string',
                                  },
                                  username: {
                                    description: '(String)  The username to use to authenticate to the data source. Defaults to “.\n(Required by some data source types) The username to use to authenticate to the data source. Defaults to “.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.type is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.type) || (has(self.initProvider) && has(self.initProvider.type))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      folder: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xfolders.oss.grafana.crossplane.io.namespaced',
            },
            name: 'folder-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XFolder',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'Folder',
                },
                name: 'folder',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.name',
                    toFieldPath: 'spec.forProvider.folderRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.folderRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.folderRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.folderSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.folderSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.folderSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.folderSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.parentFolderUid',
                    toFieldPath: 'spec.forProvider.parentFolderUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.preventDestroyIfNotEmpty',
                    toFieldPath: 'spec.forProvider.preventDestroyIfNotEmpty',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.title',
                    toFieldPath: 'spec.forProvider.title',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.uid',
                    toFieldPath: 'spec.forProvider.uid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.name',
                    toFieldPath: 'spec.initProvider.folderRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.folderRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.folderRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.folderSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.folderSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.folderSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.folderSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.parentFolderUid',
                    toFieldPath: 'spec.initProvider.parentFolderUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.preventDestroyIfNotEmpty',
                    toFieldPath: 'spec.initProvider.preventDestroyIfNotEmpty',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.title',
                    toFieldPath: 'spec.initProvider.title',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.uid',
                    toFieldPath: 'spec.initProvider.uid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xfolders.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Folder',
              plural: 'folders',
            },
            defaultCompositionRef: {
              name: 'folder-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XFolder',
              plural: 'xfolders',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'FolderSpec defines the desired state of Folder',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  folderRef: {
                                    description: 'Reference to a Folder in oss to populate parentFolderUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  folderSelector: {
                                    description: 'Selector for a Folder in oss to populate parentFolderUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  parentFolderUid: {
                                    description: '(String) The uid of the parent folder. If set, the folder will be nested. If not set, the folder will be created in the root folder. Note: This requires the nestedFolders feature flag to be enabled on your Grafana instance.\nThe uid of the parent folder. If set, the folder will be nested. If not set, the folder will be created in the root folder. Note: This requires the nestedFolders feature flag to be enabled on your Grafana instance.',
                                    type: 'string',
                                  },
                                  preventDestroyIfNotEmpty: {
                                    description: '(Boolean) Prevent deletion of the folder if it is not empty (contains dashboards or alert rules). This feature requires Grafana 10.2 or later. Defaults to false.\nPrevent deletion of the folder if it is not empty (contains dashboards or alert rules). This feature requires Grafana 10.2 or later. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  title: {
                                    description: '(String) The title of the folder.\nThe title of the folder.',
                                    type: 'string',
                                  },
                                  uid: {
                                    description: '(String) Unique identifier.\nUnique identifier.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  folderRef: {
                                    description: 'Reference to a Folder in oss to populate parentFolderUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  folderSelector: {
                                    description: 'Selector for a Folder in oss to populate parentFolderUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  parentFolderUid: {
                                    description: '(String) The uid of the parent folder. If set, the folder will be nested. If not set, the folder will be created in the root folder. Note: This requires the nestedFolders feature flag to be enabled on your Grafana instance.\nThe uid of the parent folder. If set, the folder will be nested. If not set, the folder will be created in the root folder. Note: This requires the nestedFolders feature flag to be enabled on your Grafana instance.',
                                    type: 'string',
                                  },
                                  preventDestroyIfNotEmpty: {
                                    description: '(Boolean) Prevent deletion of the folder if it is not empty (contains dashboards or alert rules). This feature requires Grafana 10.2 or later. Defaults to false.\nPrevent deletion of the folder if it is not empty (contains dashboards or alert rules). This feature requires Grafana 10.2 or later. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  title: {
                                    description: '(String) The title of the folder.\nThe title of the folder.',
                                    type: 'string',
                                  },
                                  uid: {
                                    description: '(String) Unique identifier.\nUnique identifier.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.title is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.title) || (has(self.initProvider) && has(self.initProvider.title))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      folderPermission: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xfolderpermissions.oss.grafana.crossplane.io.namespaced',
            },
            name: 'folderpermission-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XFolderPermission',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'FolderPermission',
                },
                name: 'folderpermission',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.name',
                    toFieldPath: 'spec.forProvider.folderRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.folderRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.folderRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.folderSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.folderSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.folderSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.folderSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderUid',
                    toFieldPath: 'spec.forProvider.folderUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.permissions',
                    toFieldPath: 'spec.forProvider.permissions',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.name',
                    toFieldPath: 'spec.initProvider.folderRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.folderRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.folderRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.folderSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.folderSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.folderSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.folderSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderUid',
                    toFieldPath: 'spec.initProvider.folderUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.permissions',
                    toFieldPath: 'spec.initProvider.permissions',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xfolderpermissions.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'FolderPermission',
              plural: 'folderpermissions',
            },
            defaultCompositionRef: {
              name: 'folderpermission-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XFolderPermission',
              plural: 'xfolderpermissions',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'FolderPermissionSpec defines the desired state of FolderPermission',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  folderRef: {
                                    description: 'Reference to a Folder in oss to populate folderUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  folderSelector: {
                                    description: 'Selector for a Folder in oss to populate folderUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  folderUid: {
                                    description: '(String) The UID of the folder.\nThe UID of the folder.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  permissions: {
                                    description: '(Block Set) The permission items to add/update. Items that are omitted from the list will be removed. (see below for nested schema)\nThe permission items to add/update. Items that are omitted from the list will be removed.',
                                    items: {
                                      properties: {
                                        permission: {
                                          description: '(String) Permission to associate with item. Must be one of View, Edit, or Admin.\nPermission to associate with item. Must be one of `View`, `Edit`, or `Admin`.',
                                          type: 'string',
                                        },
                                        role: {
                                          description: '(String) Name of the basic role to manage permissions for. Options: Viewer, Editor or Admin.\nName of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.',
                                          type: 'string',
                                        },
                                        teamId: {
                                          description: '(String) ID of the team to manage permissions for. Defaults to 0.\nID of the team to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        teamRef: {
                                          description: 'Reference to a Team in oss to populate teamId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        teamSelector: {
                                          description: 'Selector for a Team in oss to populate teamId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        userId: {
                                          description: '(String) ID of the user or service account to manage permissions for. Defaults to 0.\nID of the user or service account to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        userRef: {
                                          description: 'Reference to a User in oss to populate userId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        userSelector: {
                                          description: 'Selector for a User in oss to populate userId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  folderRef: {
                                    description: 'Reference to a Folder in oss to populate folderUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  folderSelector: {
                                    description: 'Selector for a Folder in oss to populate folderUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  folderUid: {
                                    description: '(String) The UID of the folder.\nThe UID of the folder.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  permissions: {
                                    description: '(Block Set) The permission items to add/update. Items that are omitted from the list will be removed. (see below for nested schema)\nThe permission items to add/update. Items that are omitted from the list will be removed.',
                                    items: {
                                      properties: {
                                        permission: {
                                          description: '(String) Permission to associate with item. Must be one of View, Edit, or Admin.\nPermission to associate with item. Must be one of `View`, `Edit`, or `Admin`.',
                                          type: 'string',
                                        },
                                        role: {
                                          description: '(String) Name of the basic role to manage permissions for. Options: Viewer, Editor or Admin.\nName of the basic role to manage permissions for. Options: `Viewer`, `Editor` or `Admin`.',
                                          type: 'string',
                                        },
                                        teamId: {
                                          description: '(String) ID of the team to manage permissions for. Defaults to 0.\nID of the team to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        teamRef: {
                                          description: 'Reference to a Team in oss to populate teamId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        teamSelector: {
                                          description: 'Selector for a Team in oss to populate teamId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        userId: {
                                          description: '(String) ID of the user or service account to manage permissions for. Defaults to 0.\nID of the user or service account to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        userRef: {
                                          description: 'Reference to a User in oss to populate userId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        userSelector: {
                                          description: 'Selector for a User in oss to populate userId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      libraryPanel: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xlibrarypanels.oss.grafana.crossplane.io.namespaced',
            },
            name: 'librarypanel-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XLibraryPanel',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'LibraryPanel',
                },
                name: 'librarypanel',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.name',
                    toFieldPath: 'spec.forProvider.folderRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.folderRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.folderRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.folderSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.folderSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.folderSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.folderSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderUid',
                    toFieldPath: 'spec.forProvider.folderUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.modelJson',
                    toFieldPath: 'spec.forProvider.modelJson',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.uid',
                    toFieldPath: 'spec.forProvider.uid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.name',
                    toFieldPath: 'spec.initProvider.folderRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.folderRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.folderRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.folderSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.folderSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.folderSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.folderSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderUid',
                    toFieldPath: 'spec.initProvider.folderUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.modelJson',
                    toFieldPath: 'spec.initProvider.modelJson',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.uid',
                    toFieldPath: 'spec.initProvider.uid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xlibrarypanels.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'LibraryPanel',
              plural: 'librarypanels',
            },
            defaultCompositionRef: {
              name: 'librarypanel-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XLibraryPanel',
              plural: 'xlibrarypanels',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'LibraryPanelSpec defines the desired state of LibraryPanel',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  folderRef: {
                                    description: 'Reference to a Folder in oss to populate folderUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  folderSelector: {
                                    description: 'Selector for a Folder in oss to populate folderUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  folderUid: {
                                    description: '(String) Unique ID (UID) of the folder containing the library panel.\nUnique ID (UID) of the folder containing the library panel.',
                                    type: 'string',
                                  },
                                  modelJson: {
                                    description: '(String) The JSON model for the library panel.\nThe JSON model for the library panel.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: '(String) Name of the library panel.\nName of the library panel.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  uid: {
                                    description: '(String) The unique identifier (UID) of a library panel uniquely identifies library panels between multiple Grafana installs. It’s automatically generated unless you specify it during library panel creation.The UID provides consistent URLs for accessing library panels and when syncing library panels between multiple Grafana installs.\nThe unique identifier (UID) of a library panel uniquely identifies library panels between multiple Grafana installs. It’s automatically generated unless you specify it during library panel creation.The UID provides consistent URLs for accessing library panels and when syncing library panels between multiple Grafana installs.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  folderRef: {
                                    description: 'Reference to a Folder in oss to populate folderUid.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  folderSelector: {
                                    description: 'Selector for a Folder in oss to populate folderUid.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  folderUid: {
                                    description: '(String) Unique ID (UID) of the folder containing the library panel.\nUnique ID (UID) of the folder containing the library panel.',
                                    type: 'string',
                                  },
                                  modelJson: {
                                    description: '(String) The JSON model for the library panel.\nThe JSON model for the library panel.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: '(String) Name of the library panel.\nName of the library panel.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  uid: {
                                    description: '(String) The unique identifier (UID) of a library panel uniquely identifies library panels between multiple Grafana installs. It’s automatically generated unless you specify it during library panel creation.The UID provides consistent URLs for accessing library panels and when syncing library panels between multiple Grafana installs.\nThe unique identifier (UID) of a library panel uniquely identifies library panels between multiple Grafana installs. It’s automatically generated unless you specify it during library panel creation.The UID provides consistent URLs for accessing library panels and when syncing library panels between multiple Grafana installs.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.modelJson is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.modelJson) || (has(self.initProvider) && has(self.initProvider.modelJson))",
                              },
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      organization: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xorganizations.oss.grafana.crossplane.io.namespaced',
            },
            name: 'organization-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XOrganization',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'Organization',
                },
                name: 'organization',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.adminUser',
                    toFieldPath: 'spec.forProvider.adminUser',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.admins',
                    toFieldPath: 'spec.forProvider.admins',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.createUsers',
                    toFieldPath: 'spec.forProvider.createUsers',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.editors',
                    toFieldPath: 'spec.forProvider.editors',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.usersWithoutAccess',
                    toFieldPath: 'spec.forProvider.usersWithoutAccess',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.viewers',
                    toFieldPath: 'spec.forProvider.viewers',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.adminUser',
                    toFieldPath: 'spec.initProvider.adminUser',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.admins',
                    toFieldPath: 'spec.initProvider.admins',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.createUsers',
                    toFieldPath: 'spec.initProvider.createUsers',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.editors',
                    toFieldPath: 'spec.initProvider.editors',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.usersWithoutAccess',
                    toFieldPath: 'spec.initProvider.usersWithoutAccess',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.viewers',
                    toFieldPath: 'spec.initProvider.viewers',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xorganizations.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Organization',
              plural: 'organizations',
            },
            defaultCompositionRef: {
              name: 'organization-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XOrganization',
              plural: 'xorganizations',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'OrganizationSpec defines the desired state of Organization',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  adminUser: {
                                    description: '(String) The login name of the configured default admin user for the Grafana\ninstallation. If unset, this value defaults to admin, the Grafana default.\nDefaults to admin.\nThe login name of the configured default admin user for the Grafana\ninstallation. If unset, this value defaults to admin, the Grafana default.\nDefaults to `admin`.',
                                    type: 'string',
                                  },
                                  admins: {
                                    description: "(Set of String) A list of email addresses corresponding to users who should be given admin\naccess to the organization. Note: users specified here must already exist in\nGrafana unless 'create_users' is set to true.\nA list of email addresses corresponding to users who should be given admin\naccess to the organization. Note: users specified here must already exist in\nGrafana unless 'create_users' is set to true.",
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  createUsers: {
                                    description: "(Boolean) Whether or not to create Grafana users specified in the organization's\nmembership if they don't already exist in Grafana. If unspecified, this\nparameter defaults to true, creating placeholder users with the name, login,\nand email set to the email of the user, and a random password. Setting this\noption to false will cause an error to be thrown for any users that do not\nalready exist in Grafana.\nDefaults to true.\nWhether or not to create Grafana users specified in the organization's\nmembership if they don't already exist in Grafana. If unspecified, this\nparameter defaults to true, creating placeholder users with the name, login,\nand email set to the email of the user, and a random password. Setting this\noption to false will cause an error to be thrown for any users that do not\nalready exist in Grafana.\nDefaults to `true`.",
                                    type: 'boolean',
                                  },
                                  editors: {
                                    description: "(Set of String) A list of email addresses corresponding to users who should be given editor\naccess to the organization. Note: users specified here must already exist in\nGrafana unless 'create_users' is set to true.\nA list of email addresses corresponding to users who should be given editor\naccess to the organization. Note: users specified here must already exist in\nGrafana unless 'create_users' is set to true.",
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  name: {
                                    description: '(String) The display name for the Grafana organization created.\nThe display name for the Grafana organization created.',
                                    type: 'string',
                                  },
                                  usersWithoutAccess: {
                                    description: "(Set of String) A list of email addresses corresponding to users who should be given none access to the organization.\nNote: users specified here must already exist in Grafana, unless 'create_users' is\nset to true. This feature is only available in Grafana 10.2+.\nA list of email addresses corresponding to users who should be given none access to the organization.\nNote: users specified here must already exist in Grafana, unless 'create_users' is\nset to true. This feature is only available in Grafana 10.2+.",
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  viewers: {
                                    description: "(Set of String) A list of email addresses corresponding to users who should be given viewer\naccess to the organization. Note: users specified here must already exist in\nGrafana unless 'create_users' is set to true.\nA list of email addresses corresponding to users who should be given viewer\naccess to the organization. Note: users specified here must already exist in\nGrafana unless 'create_users' is set to true.",
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  adminUser: {
                                    description: '(String) The login name of the configured default admin user for the Grafana\ninstallation. If unset, this value defaults to admin, the Grafana default.\nDefaults to admin.\nThe login name of the configured default admin user for the Grafana\ninstallation. If unset, this value defaults to admin, the Grafana default.\nDefaults to `admin`.',
                                    type: 'string',
                                  },
                                  admins: {
                                    description: "(Set of String) A list of email addresses corresponding to users who should be given admin\naccess to the organization. Note: users specified here must already exist in\nGrafana unless 'create_users' is set to true.\nA list of email addresses corresponding to users who should be given admin\naccess to the organization. Note: users specified here must already exist in\nGrafana unless 'create_users' is set to true.",
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  createUsers: {
                                    description: "(Boolean) Whether or not to create Grafana users specified in the organization's\nmembership if they don't already exist in Grafana. If unspecified, this\nparameter defaults to true, creating placeholder users with the name, login,\nand email set to the email of the user, and a random password. Setting this\noption to false will cause an error to be thrown for any users that do not\nalready exist in Grafana.\nDefaults to true.\nWhether or not to create Grafana users specified in the organization's\nmembership if they don't already exist in Grafana. If unspecified, this\nparameter defaults to true, creating placeholder users with the name, login,\nand email set to the email of the user, and a random password. Setting this\noption to false will cause an error to be thrown for any users that do not\nalready exist in Grafana.\nDefaults to `true`.",
                                    type: 'boolean',
                                  },
                                  editors: {
                                    description: "(Set of String) A list of email addresses corresponding to users who should be given editor\naccess to the organization. Note: users specified here must already exist in\nGrafana unless 'create_users' is set to true.\nA list of email addresses corresponding to users who should be given editor\naccess to the organization. Note: users specified here must already exist in\nGrafana unless 'create_users' is set to true.",
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  name: {
                                    description: '(String) The display name for the Grafana organization created.\nThe display name for the Grafana organization created.',
                                    type: 'string',
                                  },
                                  usersWithoutAccess: {
                                    description: "(Set of String) A list of email addresses corresponding to users who should be given none access to the organization.\nNote: users specified here must already exist in Grafana, unless 'create_users' is\nset to true. This feature is only available in Grafana 10.2+.\nA list of email addresses corresponding to users who should be given none access to the organization.\nNote: users specified here must already exist in Grafana, unless 'create_users' is\nset to true. This feature is only available in Grafana 10.2+.",
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  viewers: {
                                    description: "(Set of String) A list of email addresses corresponding to users who should be given viewer\naccess to the organization. Note: users specified here must already exist in\nGrafana unless 'create_users' is set to true.\nA list of email addresses corresponding to users who should be given viewer\naccess to the organization. Note: users specified here must already exist in\nGrafana unless 'create_users' is set to true.",
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      organizationPreferences: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xorganizationpreferences.oss.grafana.crossplane.io.namespaced',
            },
            name: 'organizationpreferences-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XOrganizationPreferences',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'OrganizationPreferences',
                },
                name: 'organizationpreferences',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.homeDashboardUid',
                    toFieldPath: 'spec.forProvider.homeDashboardUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.theme',
                    toFieldPath: 'spec.forProvider.theme',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.timezone',
                    toFieldPath: 'spec.forProvider.timezone',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.weekStart',
                    toFieldPath: 'spec.forProvider.weekStart',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.homeDashboardUid',
                    toFieldPath: 'spec.initProvider.homeDashboardUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.theme',
                    toFieldPath: 'spec.initProvider.theme',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.timezone',
                    toFieldPath: 'spec.initProvider.timezone',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.weekStart',
                    toFieldPath: 'spec.initProvider.weekStart',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xorganizationpreferences.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'OrganizationPreferences',
              plural: 'organizationpreferences',
            },
            defaultCompositionRef: {
              name: 'organizationpreferences-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XOrganizationPreferences',
              plural: 'xorganizationpreferences',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'OrganizationPreferencesSpec defines the desired state of OrganizationPreferences',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  homeDashboardUid: {
                                    description: '(String) The Organization home dashboard UID. This is only available in Grafana 9.0+.\nThe Organization home dashboard UID. This is only available in Grafana 9.0+.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  theme: {
                                    description: '(String) The Organization theme. Available values are light, dark, system, or an empty string for the default.\nThe Organization theme. Available values are `light`, `dark`, `system`, or an empty string for the default.',
                                    type: 'string',
                                  },
                                  timezone: {
                                    description: '(String) The Organization timezone. Available values are utc, browser, or an empty string for the default.\nThe Organization timezone. Available values are `utc`, `browser`, or an empty string for the default.',
                                    type: 'string',
                                  },
                                  weekStart: {
                                    description: '(String) The Organization week start day. Available values are sunday, monday, saturday, or an empty string for the default. Defaults to “.\nThe Organization week start day. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default. Defaults to “.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  homeDashboardUid: {
                                    description: '(String) The Organization home dashboard UID. This is only available in Grafana 9.0+.\nThe Organization home dashboard UID. This is only available in Grafana 9.0+.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  theme: {
                                    description: '(String) The Organization theme. Available values are light, dark, system, or an empty string for the default.\nThe Organization theme. Available values are `light`, `dark`, `system`, or an empty string for the default.',
                                    type: 'string',
                                  },
                                  timezone: {
                                    description: '(String) The Organization timezone. Available values are utc, browser, or an empty string for the default.\nThe Organization timezone. Available values are `utc`, `browser`, or an empty string for the default.',
                                    type: 'string',
                                  },
                                  weekStart: {
                                    description: '(String) The Organization week start day. Available values are sunday, monday, saturday, or an empty string for the default. Defaults to “.\nThe Organization week start day. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default. Defaults to “.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      playlist: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xplaylists.oss.grafana.crossplane.io.namespaced',
            },
            name: 'playlist-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XPlaylist',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'Playlist',
                },
                name: 'playlist',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.interval',
                    toFieldPath: 'spec.forProvider.interval',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.item',
                    toFieldPath: 'spec.forProvider.item',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.interval',
                    toFieldPath: 'spec.initProvider.interval',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.item',
                    toFieldPath: 'spec.initProvider.item',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xplaylists.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Playlist',
              plural: 'playlists',
            },
            defaultCompositionRef: {
              name: 'playlist-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XPlaylist',
              plural: 'xplaylists',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'PlaylistSpec defines the desired state of Playlist',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  interval: {
                                    description: '(String)',
                                    type: 'string',
                                  },
                                  item: {
                                    description: '(Block Set, Min: 1) (see below for nested schema)',
                                    items: {
                                      properties: {
                                        order: {
                                          description: '(Number)',
                                          type: 'number',
                                        },
                                        title: {
                                          description: '(String)',
                                          type: 'string',
                                        },
                                        type: {
                                          description: '(String)',
                                          type: 'string',
                                        },
                                        value: {
                                          description: '(String)',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  name: {
                                    description: '(String) The name of the playlist.\nThe name of the playlist.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  interval: {
                                    description: '(String)',
                                    type: 'string',
                                  },
                                  item: {
                                    description: '(Block Set, Min: 1) (see below for nested schema)',
                                    items: {
                                      properties: {
                                        order: {
                                          description: '(Number)',
                                          type: 'number',
                                        },
                                        title: {
                                          description: '(String)',
                                          type: 'string',
                                        },
                                        type: {
                                          description: '(String)',
                                          type: 'string',
                                        },
                                        value: {
                                          description: '(String)',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  name: {
                                    description: '(String) The name of the playlist.\nThe name of the playlist.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.interval is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.interval) || (has(self.initProvider) && has(self.initProvider.interval))",
                              },
                              {
                                message: 'spec.forProvider.item is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.item) || (has(self.initProvider) && has(self.initProvider.item))",
                              },
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      serviceAccount: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xserviceaccounts.oss.grafana.crossplane.io.namespaced',
            },
            name: 'serviceaccount-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XServiceAccount',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'ServiceAccount',
                },
                name: 'serviceaccount',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.isDisabled',
                    toFieldPath: 'spec.forProvider.isDisabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.role',
                    toFieldPath: 'spec.forProvider.role',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.isDisabled',
                    toFieldPath: 'spec.initProvider.isDisabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.role',
                    toFieldPath: 'spec.initProvider.role',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xserviceaccounts.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'ServiceAccount',
              plural: 'serviceaccounts',
            },
            defaultCompositionRef: {
              name: 'serviceaccount-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XServiceAccount',
              plural: 'xserviceaccounts',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'ServiceAccountSpec defines the desired state of ServiceAccount',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  isDisabled: {
                                    description: '(Boolean) The disabled status for the service account. Defaults to false.\nThe disabled status for the service account. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  name: {
                                    description: '(String) The name of the service account.\nThe name of the service account.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  role: {
                                    description: '(String) The basic role of the service account in the organization.\nThe basic role of the service account in the organization.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  isDisabled: {
                                    description: '(Boolean) The disabled status for the service account. Defaults to false.\nThe disabled status for the service account. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  name: {
                                    description: '(String) The name of the service account.\nThe name of the service account.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  role: {
                                    description: '(String) The basic role of the service account in the organization.\nThe basic role of the service account in the organization.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.role is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.role) || (has(self.initProvider) && has(self.initProvider.role))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      serviceAccountPermission: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xserviceaccountpermissions.oss.grafana.crossplane.io.namespaced',
            },
            name: 'serviceaccountpermission-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XServiceAccountPermission',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'ServiceAccountPermission',
                },
                name: 'serviceaccountpermission',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.permissions',
                    toFieldPath: 'spec.forProvider.permissions',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountId',
                    toFieldPath: 'spec.forProvider.serviceAccountId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountRef.name',
                    toFieldPath: 'spec.forProvider.serviceAccountRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.serviceAccountRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.serviceAccountRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.permissions',
                    toFieldPath: 'spec.initProvider.permissions',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountId',
                    toFieldPath: 'spec.initProvider.serviceAccountId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountRef.name',
                    toFieldPath: 'spec.initProvider.serviceAccountRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.serviceAccountRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.serviceAccountRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xserviceaccountpermissions.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'ServiceAccountPermission',
              plural: 'serviceaccountpermissions',
            },
            defaultCompositionRef: {
              name: 'serviceaccountpermission-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XServiceAccountPermission',
              plural: 'xserviceaccountpermissions',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'ServiceAccountPermissionSpec defines the desired state of ServiceAccountPermission',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  permissions: {
                                    description: '(Block Set) The permission items to add/update. Items that are omitted from the list will be removed. (see below for nested schema)\nThe permission items to add/update. Items that are omitted from the list will be removed.',
                                    items: {
                                      properties: {
                                        permission: {
                                          description: '(String) Permission to associate with item. Must be one of View, Edit, or Admin.\nPermission to associate with item. Must be one of `View`, `Edit`, or `Admin`.',
                                          type: 'string',
                                        },
                                        teamId: {
                                          description: '(String) ID of the team to manage permissions for. Defaults to 0.\nID of the team to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        teamRef: {
                                          description: 'Reference to a Team in oss to populate teamId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        teamSelector: {
                                          description: 'Selector for a Team in oss to populate teamId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        userId: {
                                          description: '(String) ID of the user or service account to manage permissions for. Defaults to 0.\nID of the user or service account to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        userRef: {
                                          description: 'Reference to a User in oss to populate userId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        userSelector: {
                                          description: 'Selector for a User in oss to populate userId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  serviceAccountId: {
                                    description: '(String) The id of the service account.\nThe id of the service account.',
                                    type: 'string',
                                  },
                                  serviceAccountRef: {
                                    description: 'Reference to a ServiceAccount in oss to populate serviceAccountId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  serviceAccountSelector: {
                                    description: 'Selector for a ServiceAccount in oss to populate serviceAccountId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  permissions: {
                                    description: '(Block Set) The permission items to add/update. Items that are omitted from the list will be removed. (see below for nested schema)\nThe permission items to add/update. Items that are omitted from the list will be removed.',
                                    items: {
                                      properties: {
                                        permission: {
                                          description: '(String) Permission to associate with item. Must be one of View, Edit, or Admin.\nPermission to associate with item. Must be one of `View`, `Edit`, or `Admin`.',
                                          type: 'string',
                                        },
                                        teamId: {
                                          description: '(String) ID of the team to manage permissions for. Defaults to 0.\nID of the team to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        teamRef: {
                                          description: 'Reference to a Team in oss to populate teamId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        teamSelector: {
                                          description: 'Selector for a Team in oss to populate teamId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        userId: {
                                          description: '(String) ID of the user or service account to manage permissions for. Defaults to 0.\nID of the user or service account to manage permissions for. Defaults to `0`.',
                                          type: 'string',
                                        },
                                        userRef: {
                                          description: 'Reference to a User in oss to populate userId.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        userSelector: {
                                          description: 'Selector for a User in oss to populate userId.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  serviceAccountId: {
                                    description: '(String) The id of the service account.\nThe id of the service account.',
                                    type: 'string',
                                  },
                                  serviceAccountRef: {
                                    description: 'Reference to a ServiceAccount in oss to populate serviceAccountId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  serviceAccountSelector: {
                                    description: 'Selector for a ServiceAccount in oss to populate serviceAccountId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      serviceAccountToken: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xserviceaccounttokens.oss.grafana.crossplane.io.namespaced',
            },
            name: 'serviceaccounttoken-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XServiceAccountToken',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'ServiceAccountToken',
                },
                name: 'serviceaccounttoken',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.secondsToLive',
                    toFieldPath: 'spec.forProvider.secondsToLive',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountId',
                    toFieldPath: 'spec.forProvider.serviceAccountId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountRef.name',
                    toFieldPath: 'spec.forProvider.serviceAccountRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.serviceAccountRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.serviceAccountRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.serviceAccountSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.serviceAccountSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.secondsToLive',
                    toFieldPath: 'spec.initProvider.secondsToLive',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountId',
                    toFieldPath: 'spec.initProvider.serviceAccountId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountRef.name',
                    toFieldPath: 'spec.initProvider.serviceAccountRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.serviceAccountRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.serviceAccountRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.serviceAccountSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.serviceAccountSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xserviceaccounttokens.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'ServiceAccountToken',
              plural: 'serviceaccounttokens',
            },
            defaultCompositionRef: {
              name: 'serviceaccounttoken-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XServiceAccountToken',
              plural: 'xserviceaccounttokens',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'ServiceAccountTokenSpec defines the desired state of ServiceAccountToken',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  name: {
                                    description: '(String) The name of the service account token.\nThe name of the service account token.',
                                    type: 'string',
                                  },
                                  secondsToLive: {
                                    description: '(Number) The key expiration in seconds. It is optional. If it is a positive number an expiration date for the key is set. If it is null, zero or is omitted completely (unless api_key_max_seconds_to_live configuration option is set) the key will never expire.\nThe key expiration in seconds. It is optional. If it is a positive number an expiration date for the key is set. If it is null, zero or is omitted completely (unless `api_key_max_seconds_to_live` configuration option is set) the key will never expire.',
                                    type: 'number',
                                  },
                                  serviceAccountId: {
                                    description: '(String) The ID of the service account to which the token belongs.\nThe ID of the service account to which the token belongs.',
                                    type: 'string',
                                  },
                                  serviceAccountRef: {
                                    description: 'Reference to a ServiceAccount in oss to populate serviceAccountId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  serviceAccountSelector: {
                                    description: 'Selector for a ServiceAccount in oss to populate serviceAccountId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  name: {
                                    description: '(String) The name of the service account token.\nThe name of the service account token.',
                                    type: 'string',
                                  },
                                  secondsToLive: {
                                    description: '(Number) The key expiration in seconds. It is optional. If it is a positive number an expiration date for the key is set. If it is null, zero or is omitted completely (unless api_key_max_seconds_to_live configuration option is set) the key will never expire.\nThe key expiration in seconds. It is optional. If it is a positive number an expiration date for the key is set. If it is null, zero or is omitted completely (unless `api_key_max_seconds_to_live` configuration option is set) the key will never expire.',
                                    type: 'number',
                                  },
                                  serviceAccountId: {
                                    description: '(String) The ID of the service account to which the token belongs.\nThe ID of the service account to which the token belongs.',
                                    type: 'string',
                                  },
                                  serviceAccountRef: {
                                    description: 'Reference to a ServiceAccount in oss to populate serviceAccountId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  serviceAccountSelector: {
                                    description: 'Selector for a ServiceAccount in oss to populate serviceAccountId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      ssoSettings: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xssosettings.oss.grafana.crossplane.io.namespaced',
            },
            name: 'ssosettings-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XSsoSettings',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'SsoSettings',
                },
                name: 'ssosettings',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.oauth2Settings',
                    toFieldPath: 'spec.forProvider.oauth2Settings',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.providerName',
                    toFieldPath: 'spec.forProvider.providerName',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.samlSettings',
                    toFieldPath: 'spec.forProvider.samlSettings',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.oauth2Settings',
                    toFieldPath: 'spec.initProvider.oauth2Settings',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.providerName',
                    toFieldPath: 'spec.initProvider.providerName',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.samlSettings',
                    toFieldPath: 'spec.initProvider.samlSettings',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xssosettings.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'SsoSettings',
              plural: 'ssosettings',
            },
            defaultCompositionRef: {
              name: 'ssosettings-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XSsoSettings',
              plural: 'xssosettings',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'SsoSettingsSpec defines the desired state of SsoSettings',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  oauth2Settings: {
                                    description: '(Block Set, Max: 1) The OAuth2 settings set. Required for github, gitlab, google, azuread, okta, generic_oauth providers. (see below for nested schema)\nThe OAuth2 settings set. Required for github, gitlab, google, azuread, okta, generic_oauth providers.',
                                    items: {
                                      properties: {
                                        allowAssignGrafanaAdmin: {
                                          description: '(Boolean) If enabled, it will automatically sync the Grafana server administrator role.\nIf enabled, it will automatically sync the Grafana server administrator role.',
                                          type: 'boolean',
                                        },
                                        allowSignUp: {
                                          description: '(Boolean) If not enabled, only existing Grafana users can log in using OAuth.\nIf not enabled, only existing Grafana users can log in using OAuth.',
                                          type: 'boolean',
                                        },
                                        allowedDomains: {
                                          description: 'or space-separated domains. The user should belong to at least one domain to log in.\nList of comma- or space-separated domains. The user should belong to at least one domain to log in.',
                                          type: 'string',
                                        },
                                        allowedGroups: {
                                          description: 'or space-separated groups. The user should be a member of at least one group to log in. For Generic OAuth, if you configure allowed_groups, you must also configure groups_attribute_path.\nList of comma- or space-separated groups. The user should be a member of at least one group to log in. For Generic OAuth, if you configure allowed_groups, you must also configure groups_attribute_path.',
                                          type: 'string',
                                        },
                                        allowedOrganizations: {
                                          description: 'or space-separated organizations. The user should be a member of at least one organization to log in.\nList of comma- or space-separated organizations. The user should be a member of at least one organization to log in.',
                                          type: 'string',
                                        },
                                        apiUrl: {
                                          description: '(String) The user information endpoint of your OAuth2 provider. Required for okta and generic_oauth providers.\nThe user information endpoint of your OAuth2 provider. Required for okta and generic_oauth providers.',
                                          type: 'string',
                                        },
                                        authStyle: {
                                          description: '(String) It determines how client_id and client_secret are sent to Oauth2 provider. Possible values are AutoDetect, InParams, InHeader. Default is AutoDetect.\nIt determines how client_id and client_secret are sent to Oauth2 provider. Possible values are AutoDetect, InParams, InHeader. Default is AutoDetect.',
                                          type: 'string',
                                        },
                                        authUrl: {
                                          description: '(String) The authorization endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.\nThe authorization endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.',
                                          type: 'string',
                                        },
                                        autoLogin: {
                                          description: '(Boolean) Log in automatically, skipping the login screen.\nLog in automatically, skipping the login screen.',
                                          type: 'boolean',
                                        },
                                        clientId: {
                                          description: '(String) The client Id of your OAuth2 app.\nThe client Id of your OAuth2 app.',
                                          type: 'string',
                                        },
                                        clientSecretSecretRef: {
                                          description: '(String, Sensitive) The client secret of your OAuth2 app.\nThe client secret of your OAuth2 app.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        custom: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          description: '(Map of String) Custom fields to configure for OAuth2 such as the force_use_graph_api field.\nCustom fields to configure for OAuth2 such as the [force_use_graph_api](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/azuread/#force-fetching-groups-from-microsoft-graph-api) field.',
                                          type: 'object',
                                          'x-kubernetes-map-type': 'granular',
                                        },
                                        defineAllowedGroups: {
                                          description: '(Boolean) Define allowed groups.\nDefine allowed groups.',
                                          type: 'boolean',
                                        },
                                        defineAllowedTeamsIds: {
                                          description: '(Boolean) Define allowed teams ids.\nDefine allowed teams ids.',
                                          type: 'boolean',
                                        },
                                        emailAttributeName: {
                                          description: '(String) Name of the key to use for user email lookup within the attributes map of OAuth2 ID token. Only applicable to Generic OAuth.\nName of the key to use for user email lookup within the attributes map of OAuth2 ID token. Only applicable to Generic OAuth.',
                                          type: 'string',
                                        },
                                        emailAttributePath: {
                                          description: '(String) JMESPath expression to use for user email lookup from the user information. Only applicable to Generic OAuth.\nJMESPath expression to use for user email lookup from the user information. Only applicable to Generic OAuth.',
                                          type: 'string',
                                        },
                                        emptyScopes: {
                                          description: '(Boolean) If enabled, no scopes will be sent to the OAuth2 provider.\nIf enabled, no scopes will be sent to the OAuth2 provider.',
                                          type: 'boolean',
                                        },
                                        enabled: {
                                          description: '(Boolean) Define whether this configuration is enabled for the specified provider. Defaults to true.\nDefine whether this configuration is enabled for the specified provider. Defaults to `true`.',
                                          type: 'boolean',
                                        },
                                        groupsAttributePath: {
                                          description: '(String) JMESPath expression to use for user group lookup. If you configure allowed_groups, you must also configure groups_attribute_path.\nJMESPath expression to use for user group lookup. If you configure allowed_groups, you must also configure groups_attribute_path.',
                                          type: 'string',
                                        },
                                        idTokenAttributeName: {
                                          description: '(String) The name of the key used to extract the ID token from the returned OAuth2 token. Only applicable to Generic OAuth.\nThe name of the key used to extract the ID token from the returned OAuth2 token. Only applicable to Generic OAuth.',
                                          type: 'string',
                                        },
                                        loginAttributePath: {
                                          description: '(String) JMESPath expression to use for user login lookup from the user ID token. Only applicable to Generic OAuth.\nJMESPath expression to use for user login lookup from the user ID token. Only applicable to Generic OAuth.',
                                          type: 'string',
                                        },
                                        name: {
                                          description: '(String) Helpful if you use more than one identity providers or SSO protocols.\nHelpful if you use more than one identity providers or SSO protocols.',
                                          type: 'string',
                                        },
                                        nameAttributePath: {
                                          description: '(String) JMESPath expression to use for user name lookup from the user ID token. This name will be used as the user’s display name. Only applicable to Generic OAuth.\nJMESPath expression to use for user name lookup from the user ID token. This name will be used as the user’s display name. Only applicable to Generic OAuth.',
                                          type: 'string',
                                        },
                                        roleAttributePath: {
                                          description: '(String) JMESPath expression to use for Grafana role lookup.\nJMESPath expression to use for Grafana role lookup.',
                                          type: 'string',
                                        },
                                        roleAttributeStrict: {
                                          description: '(Boolean) If enabled, denies user login if the Grafana role cannot be extracted using Role attribute path.\nIf enabled, denies user login if the Grafana role cannot be extracted using Role attribute path.',
                                          type: 'boolean',
                                        },
                                        scopes: {
                                          description: 'or space-separated OAuth2 scopes.\nList of comma- or space-separated OAuth2 scopes.',
                                          type: 'string',
                                        },
                                        signoutRedirectUrl: {
                                          description: '(String) The URL to redirect the user to after signing out from Grafana.\nThe URL to redirect the user to after signing out from Grafana.',
                                          type: 'string',
                                        },
                                        skipOrgRoleSync: {
                                          description: '(Boolean) Prevent synchronizing users’ organization roles from your IdP.\nPrevent synchronizing users’ organization roles from your IdP.',
                                          type: 'boolean',
                                        },
                                        teamIds: {
                                          description: '(String) String list of Team Ids. If set, the user must be a member of one of the given teams to log in. If you configure team_ids, you must also configure teams_url and team_ids_attribute_path.\nString list of Team Ids. If set, the user must be a member of one of the given teams to log in. If you configure team_ids, you must also configure teams_url and team_ids_attribute_path.',
                                          type: 'string',
                                        },
                                        teamIdsAttributePath: {
                                          description: '(String) The JMESPath expression to use for Grafana Team Id lookup within the results returned by the teams_url endpoint. Only applicable to Generic OAuth.\nThe JMESPath expression to use for Grafana Team Id lookup within the results returned by the teams_url endpoint. Only applicable to Generic OAuth.',
                                          type: 'string',
                                        },
                                        teamsUrl: {
                                          description: '(String) The URL used to query for Team Ids. If not set, the default value is /teams. If you configure teams_url, you must also configure team_ids_attribute_path. Only applicable to Generic OAuth.\nThe URL used to query for Team Ids. If not set, the default value is /teams. If you configure teams_url, you must also configure team_ids_attribute_path. Only applicable to Generic OAuth.',
                                          type: 'string',
                                        },
                                        tlsClientCa: {
                                          description: '(String) The path to the trusted certificate authority list. Is not applicable on Grafana Cloud.\nThe path to the trusted certificate authority list. Is not applicable on Grafana Cloud.',
                                          type: 'string',
                                        },
                                        tlsClientCert: {
                                          description: '(String) The path to the certificate. Is not applicable on Grafana Cloud.\nThe path to the certificate. Is not applicable on Grafana Cloud.',
                                          type: 'string',
                                        },
                                        tlsClientKey: {
                                          description: '(String) The path to the key. Is not applicable on Grafana Cloud.\nThe path to the key. Is not applicable on Grafana Cloud.',
                                          type: 'string',
                                        },
                                        tlsSkipVerifyInsecure: {
                                          description: 'in-the-middle attacks.\nIf enabled, the client accepts any certificate presented by the server and any host name in that certificate. You should only use this for testing, because this mode leaves SSL/TLS susceptible to man-in-the-middle attacks.',
                                          type: 'boolean',
                                        },
                                        tokenUrl: {
                                          description: '(String) The token endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.\nThe token endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.',
                                          type: 'string',
                                        },
                                        usePkce: {
                                          description: '(Boolean) If enabled, Grafana will use Proof Key for Code Exchange (PKCE) with the OAuth2 Authorization Code Grant.\nIf enabled, Grafana will use Proof Key for Code Exchange (PKCE) with the OAuth2 Authorization Code Grant.',
                                          type: 'boolean',
                                        },
                                        useRefreshToken: {
                                          description: '(Boolean) If enabled, Grafana will fetch a new access token using the refresh token provided by the OAuth2 provider.\nIf enabled, Grafana will fetch a new access token using the refresh token provided by the OAuth2 provider.',
                                          type: 'boolean',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  providerName: {
                                    description: '(String) The name of the SSO provider. Supported values: github, gitlab, google, azuread, okta, generic_oauth, saml.\nThe name of the SSO provider. Supported values: github, gitlab, google, azuread, okta, generic_oauth, saml.',
                                    type: 'string',
                                  },
                                  samlSettings: {
                                    description: '(Block Set, Max: 1) The SAML settings set. Required for the saml provider. (see below for nested schema)\nThe SAML settings set. Required for the saml provider.',
                                    items: {
                                      properties: {
                                        allowIdpInitiated: {
                                          description: 'initiated login is allowed.\nWhether SAML IdP-initiated login is allowed.',
                                          type: 'boolean',
                                        },
                                        allowSignUp: {
                                          description: '(Boolean) If not enabled, only existing Grafana users can log in using OAuth.\nWhether to allow new Grafana user creation through SAML login. If set to false, then only existing Grafana users can log in with SAML.',
                                          type: 'boolean',
                                        },
                                        allowedOrganizations: {
                                          description: 'or space-separated organizations. The user should be a member of at least one organization to log in.\nList of comma- or space-separated organizations. User should be a member of at least one organization to log in.',
                                          type: 'string',
                                        },
                                        assertionAttributeEmail: {
                                          description: '(String) Friendly name or name of the attribute within the SAML assertion to use as the user email.\nFriendly name or name of the attribute within the SAML assertion to use as the user email.',
                                          type: 'string',
                                        },
                                        assertionAttributeGroups: {
                                          description: '(String) Friendly name or name of the attribute within the SAML assertion to use as the user groups.\nFriendly name or name of the attribute within the SAML assertion to use as the user groups.',
                                          type: 'string',
                                        },
                                        assertionAttributeLogin: {
                                          description: '(String) Friendly name or name of the attribute within the SAML assertion to use as the user login handle.\nFriendly name or name of the attribute within the SAML assertion to use as the user login handle.',
                                          type: 'string',
                                        },
                                        assertionAttributeName: {
                                          description: '(String) Friendly name or name of the attribute within the SAML assertion to use as the user name. Alternatively, this can be a template with variables that match the names of attributes within the SAML assertion.\nFriendly name or name of the attribute within the SAML assertion to use as the user name. Alternatively, this can be a template with variables that match the names of attributes within the SAML assertion.',
                                          type: 'string',
                                        },
                                        assertionAttributeOrg: {
                                          description: '(String) Friendly name or name of the attribute within the SAML assertion to use as the user organization.\nFriendly name or name of the attribute within the SAML assertion to use as the user organization.',
                                          type: 'string',
                                        },
                                        assertionAttributeRole: {
                                          description: '(String) Friendly name or name of the attribute within the SAML assertion to use as the user roles.\nFriendly name or name of the attribute within the SAML assertion to use as the user roles.',
                                          type: 'string',
                                        },
                                        autoLogin: {
                                          description: '(Boolean) Log in automatically, skipping the login screen.\nWhether SAML auto login is enabled.',
                                          type: 'boolean',
                                        },
                                        certificatePath: {
                                          description: '(String) Path for the SP X.509 certificate.\nPath for the SP X.509 certificate.',
                                          type: 'string',
                                        },
                                        certificateSecretRef: {
                                          description: 'encoded string for the SP X.509 certificate.\nBase64-encoded string for the SP X.509 certificate.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        enabled: {
                                          description: '(Boolean) Define whether this configuration is enabled for the specified provider. Defaults to true.\nDefine whether this configuration is enabled for SAML. Defaults to `true`.',
                                          type: 'boolean',
                                        },
                                        idpMetadata: {
                                          description: 'encoded string for the IdP SAML metadata XML.\nBase64-encoded string for the IdP SAML metadata XML.',
                                          type: 'string',
                                        },
                                        idpMetadataPath: {
                                          description: '(String) Path for the IdP SAML metadata XML.\nPath for the IdP SAML metadata XML.',
                                          type: 'string',
                                        },
                                        idpMetadataUrl: {
                                          description: '(String) URL for the IdP SAML metadata XML.\nURL for the IdP SAML metadata XML.',
                                          type: 'string',
                                        },
                                        maxIssueDelay: {
                                          description: '(String) Duration, since the IdP issued a response and the SP is allowed to process it. For example: 90s, 1h.\nDuration, since the IdP issued a response and the SP is allowed to process it. For example: 90s, 1h.',
                                          type: 'string',
                                        },
                                        metadataValidDuration: {
                                          description: '(String) Duration, for how long the SP metadata is valid. For example: 48h, 5d.\nDuration, for how long the SP metadata is valid. For example: 48h, 5d.',
                                          type: 'string',
                                        },
                                        name: {
                                          description: '(String) Helpful if you use more than one identity providers or SSO protocols.\nName used to refer to the SAML authentication.',
                                          type: 'string',
                                        },
                                        nameIdFormat: {
                                          description: 'format:transient\nThe Name ID Format to request within the SAML assertion. Defaults to urn:oasis:names:tc:SAML:2.0:nameid-format:transient',
                                          type: 'string',
                                        },
                                        orgMapping: {
                                          description: 'or space-separated Organization:OrgId:Role mappings. Organization can be * meaning “All users”. Role is optional and can have the following values: Viewer, Editor or Admin.\nList of comma- or space-separated Organization:OrgId:Role mappings. Organization can be * meaning “All users”. Role is optional and can have the following values: Viewer, Editor or Admin.',
                                          type: 'string',
                                        },
                                        privateKeyPath: {
                                          description: '(String) Path for the SP private key.\nPath for the SP private key.',
                                          type: 'string',
                                        },
                                        privateKeySecretRef: {
                                          description: 'encoded string for the SP private key.\nBase64-encoded string for the SP private key.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        relayState: {
                                          description: 'initiated login. Should match relay state configured in IdP.\nRelay state for IdP-initiated login. Should match relay state configured in IdP.',
                                          type: 'string',
                                        },
                                        roleValuesAdmin: {
                                          description: 'or space-separated roles which will be mapped into the Admin role.\nList of comma- or space-separated roles which will be mapped into the Admin role.',
                                          type: 'string',
                                        },
                                        roleValuesEditor: {
                                          description: 'or space-separated roles which will be mapped into the Editor role.\nList of comma- or space-separated roles which will be mapped into the Editor role.',
                                          type: 'string',
                                        },
                                        roleValuesGrafanaAdmin: {
                                          description: 'or space-separated roles which will be mapped into the Grafana Admin (Super Admin) role.\nList of comma- or space-separated roles which will be mapped into the Grafana Admin (Super Admin) role.',
                                          type: 'string',
                                        },
                                        roleValuesNone: {
                                          description: 'or space-separated roles which will be mapped into the None role.\nList of comma- or space-separated roles which will be mapped into the None role.',
                                          type: 'string',
                                        },
                                        roleValuesViewer: {
                                          description: 'or space-separated roles which will be mapped into the Viewer role.\nList of comma- or space-separated roles which will be mapped into the Viewer role.',
                                          type: 'string',
                                        },
                                        signatureAlgorithm: {
                                          description: 'sha1, rsa-sha256, rsa-sha512.\nSignature algorithm used for signing requests to the IdP. Supported values are rsa-sha1, rsa-sha256, rsa-sha512.',
                                          type: 'string',
                                        },
                                        singleLogout: {
                                          description: '(Boolean) Whether SAML Single Logout is enabled.\nWhether SAML Single Logout is enabled.',
                                          type: 'boolean',
                                        },
                                        skipOrgRoleSync: {
                                          description: '(Boolean) Prevent synchronizing users’ organization roles from your IdP.\nPrevent synchronizing users’ organization roles from your IdP.',
                                          type: 'boolean',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  oauth2Settings: {
                                    description: '(Block Set, Max: 1) The OAuth2 settings set. Required for github, gitlab, google, azuread, okta, generic_oauth providers. (see below for nested schema)\nThe OAuth2 settings set. Required for github, gitlab, google, azuread, okta, generic_oauth providers.',
                                    items: {
                                      properties: {
                                        allowAssignGrafanaAdmin: {
                                          description: '(Boolean) If enabled, it will automatically sync the Grafana server administrator role.\nIf enabled, it will automatically sync the Grafana server administrator role.',
                                          type: 'boolean',
                                        },
                                        allowSignUp: {
                                          description: '(Boolean) If not enabled, only existing Grafana users can log in using OAuth.\nIf not enabled, only existing Grafana users can log in using OAuth.',
                                          type: 'boolean',
                                        },
                                        allowedDomains: {
                                          description: 'or space-separated domains. The user should belong to at least one domain to log in.\nList of comma- or space-separated domains. The user should belong to at least one domain to log in.',
                                          type: 'string',
                                        },
                                        allowedGroups: {
                                          description: 'or space-separated groups. The user should be a member of at least one group to log in. For Generic OAuth, if you configure allowed_groups, you must also configure groups_attribute_path.\nList of comma- or space-separated groups. The user should be a member of at least one group to log in. For Generic OAuth, if you configure allowed_groups, you must also configure groups_attribute_path.',
                                          type: 'string',
                                        },
                                        allowedOrganizations: {
                                          description: 'or space-separated organizations. The user should be a member of at least one organization to log in.\nList of comma- or space-separated organizations. The user should be a member of at least one organization to log in.',
                                          type: 'string',
                                        },
                                        apiUrl: {
                                          description: '(String) The user information endpoint of your OAuth2 provider. Required for okta and generic_oauth providers.\nThe user information endpoint of your OAuth2 provider. Required for okta and generic_oauth providers.',
                                          type: 'string',
                                        },
                                        authStyle: {
                                          description: '(String) It determines how client_id and client_secret are sent to Oauth2 provider. Possible values are AutoDetect, InParams, InHeader. Default is AutoDetect.\nIt determines how client_id and client_secret are sent to Oauth2 provider. Possible values are AutoDetect, InParams, InHeader. Default is AutoDetect.',
                                          type: 'string',
                                        },
                                        authUrl: {
                                          description: '(String) The authorization endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.\nThe authorization endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.',
                                          type: 'string',
                                        },
                                        autoLogin: {
                                          description: '(Boolean) Log in automatically, skipping the login screen.\nLog in automatically, skipping the login screen.',
                                          type: 'boolean',
                                        },
                                        clientId: {
                                          description: '(String) The client Id of your OAuth2 app.\nThe client Id of your OAuth2 app.',
                                          type: 'string',
                                        },
                                        clientSecretSecretRef: {
                                          description: '(String, Sensitive) The client secret of your OAuth2 app.\nThe client secret of your OAuth2 app.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        custom: {
                                          additionalProperties: {
                                            type: 'string',
                                          },
                                          description: '(Map of String) Custom fields to configure for OAuth2 such as the force_use_graph_api field.\nCustom fields to configure for OAuth2 such as the [force_use_graph_api](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/azuread/#force-fetching-groups-from-microsoft-graph-api) field.',
                                          type: 'object',
                                          'x-kubernetes-map-type': 'granular',
                                        },
                                        defineAllowedGroups: {
                                          description: '(Boolean) Define allowed groups.\nDefine allowed groups.',
                                          type: 'boolean',
                                        },
                                        defineAllowedTeamsIds: {
                                          description: '(Boolean) Define allowed teams ids.\nDefine allowed teams ids.',
                                          type: 'boolean',
                                        },
                                        emailAttributeName: {
                                          description: '(String) Name of the key to use for user email lookup within the attributes map of OAuth2 ID token. Only applicable to Generic OAuth.\nName of the key to use for user email lookup within the attributes map of OAuth2 ID token. Only applicable to Generic OAuth.',
                                          type: 'string',
                                        },
                                        emailAttributePath: {
                                          description: '(String) JMESPath expression to use for user email lookup from the user information. Only applicable to Generic OAuth.\nJMESPath expression to use for user email lookup from the user information. Only applicable to Generic OAuth.',
                                          type: 'string',
                                        },
                                        emptyScopes: {
                                          description: '(Boolean) If enabled, no scopes will be sent to the OAuth2 provider.\nIf enabled, no scopes will be sent to the OAuth2 provider.',
                                          type: 'boolean',
                                        },
                                        enabled: {
                                          description: '(Boolean) Define whether this configuration is enabled for the specified provider. Defaults to true.\nDefine whether this configuration is enabled for the specified provider. Defaults to `true`.',
                                          type: 'boolean',
                                        },
                                        groupsAttributePath: {
                                          description: '(String) JMESPath expression to use for user group lookup. If you configure allowed_groups, you must also configure groups_attribute_path.\nJMESPath expression to use for user group lookup. If you configure allowed_groups, you must also configure groups_attribute_path.',
                                          type: 'string',
                                        },
                                        idTokenAttributeName: {
                                          description: '(String) The name of the key used to extract the ID token from the returned OAuth2 token. Only applicable to Generic OAuth.\nThe name of the key used to extract the ID token from the returned OAuth2 token. Only applicable to Generic OAuth.',
                                          type: 'string',
                                        },
                                        loginAttributePath: {
                                          description: '(String) JMESPath expression to use for user login lookup from the user ID token. Only applicable to Generic OAuth.\nJMESPath expression to use for user login lookup from the user ID token. Only applicable to Generic OAuth.',
                                          type: 'string',
                                        },
                                        name: {
                                          description: '(String) Helpful if you use more than one identity providers or SSO protocols.\nHelpful if you use more than one identity providers or SSO protocols.',
                                          type: 'string',
                                        },
                                        nameAttributePath: {
                                          description: '(String) JMESPath expression to use for user name lookup from the user ID token. This name will be used as the user’s display name. Only applicable to Generic OAuth.\nJMESPath expression to use for user name lookup from the user ID token. This name will be used as the user’s display name. Only applicable to Generic OAuth.',
                                          type: 'string',
                                        },
                                        roleAttributePath: {
                                          description: '(String) JMESPath expression to use for Grafana role lookup.\nJMESPath expression to use for Grafana role lookup.',
                                          type: 'string',
                                        },
                                        roleAttributeStrict: {
                                          description: '(Boolean) If enabled, denies user login if the Grafana role cannot be extracted using Role attribute path.\nIf enabled, denies user login if the Grafana role cannot be extracted using Role attribute path.',
                                          type: 'boolean',
                                        },
                                        scopes: {
                                          description: 'or space-separated OAuth2 scopes.\nList of comma- or space-separated OAuth2 scopes.',
                                          type: 'string',
                                        },
                                        signoutRedirectUrl: {
                                          description: '(String) The URL to redirect the user to after signing out from Grafana.\nThe URL to redirect the user to after signing out from Grafana.',
                                          type: 'string',
                                        },
                                        skipOrgRoleSync: {
                                          description: '(Boolean) Prevent synchronizing users’ organization roles from your IdP.\nPrevent synchronizing users’ organization roles from your IdP.',
                                          type: 'boolean',
                                        },
                                        teamIds: {
                                          description: '(String) String list of Team Ids. If set, the user must be a member of one of the given teams to log in. If you configure team_ids, you must also configure teams_url and team_ids_attribute_path.\nString list of Team Ids. If set, the user must be a member of one of the given teams to log in. If you configure team_ids, you must also configure teams_url and team_ids_attribute_path.',
                                          type: 'string',
                                        },
                                        teamIdsAttributePath: {
                                          description: '(String) The JMESPath expression to use for Grafana Team Id lookup within the results returned by the teams_url endpoint. Only applicable to Generic OAuth.\nThe JMESPath expression to use for Grafana Team Id lookup within the results returned by the teams_url endpoint. Only applicable to Generic OAuth.',
                                          type: 'string',
                                        },
                                        teamsUrl: {
                                          description: '(String) The URL used to query for Team Ids. If not set, the default value is /teams. If you configure teams_url, you must also configure team_ids_attribute_path. Only applicable to Generic OAuth.\nThe URL used to query for Team Ids. If not set, the default value is /teams. If you configure teams_url, you must also configure team_ids_attribute_path. Only applicable to Generic OAuth.',
                                          type: 'string',
                                        },
                                        tlsClientCa: {
                                          description: '(String) The path to the trusted certificate authority list. Is not applicable on Grafana Cloud.\nThe path to the trusted certificate authority list. Is not applicable on Grafana Cloud.',
                                          type: 'string',
                                        },
                                        tlsClientCert: {
                                          description: '(String) The path to the certificate. Is not applicable on Grafana Cloud.\nThe path to the certificate. Is not applicable on Grafana Cloud.',
                                          type: 'string',
                                        },
                                        tlsClientKey: {
                                          description: '(String) The path to the key. Is not applicable on Grafana Cloud.\nThe path to the key. Is not applicable on Grafana Cloud.',
                                          type: 'string',
                                        },
                                        tlsSkipVerifyInsecure: {
                                          description: 'in-the-middle attacks.\nIf enabled, the client accepts any certificate presented by the server and any host name in that certificate. You should only use this for testing, because this mode leaves SSL/TLS susceptible to man-in-the-middle attacks.',
                                          type: 'boolean',
                                        },
                                        tokenUrl: {
                                          description: '(String) The token endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.\nThe token endpoint of your OAuth2 provider. Required for azuread, okta and generic_oauth providers.',
                                          type: 'string',
                                        },
                                        usePkce: {
                                          description: '(Boolean) If enabled, Grafana will use Proof Key for Code Exchange (PKCE) with the OAuth2 Authorization Code Grant.\nIf enabled, Grafana will use Proof Key for Code Exchange (PKCE) with the OAuth2 Authorization Code Grant.',
                                          type: 'boolean',
                                        },
                                        useRefreshToken: {
                                          description: '(Boolean) If enabled, Grafana will fetch a new access token using the refresh token provided by the OAuth2 provider.\nIf enabled, Grafana will fetch a new access token using the refresh token provided by the OAuth2 provider.',
                                          type: 'boolean',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  providerName: {
                                    description: '(String) The name of the SSO provider. Supported values: github, gitlab, google, azuread, okta, generic_oauth, saml.\nThe name of the SSO provider. Supported values: github, gitlab, google, azuread, okta, generic_oauth, saml.',
                                    type: 'string',
                                  },
                                  samlSettings: {
                                    description: '(Block Set, Max: 1) The SAML settings set. Required for the saml provider. (see below for nested schema)\nThe SAML settings set. Required for the saml provider.',
                                    items: {
                                      properties: {
                                        allowIdpInitiated: {
                                          description: 'initiated login is allowed.\nWhether SAML IdP-initiated login is allowed.',
                                          type: 'boolean',
                                        },
                                        allowSignUp: {
                                          description: '(Boolean) If not enabled, only existing Grafana users can log in using OAuth.\nWhether to allow new Grafana user creation through SAML login. If set to false, then only existing Grafana users can log in with SAML.',
                                          type: 'boolean',
                                        },
                                        allowedOrganizations: {
                                          description: 'or space-separated organizations. The user should be a member of at least one organization to log in.\nList of comma- or space-separated organizations. User should be a member of at least one organization to log in.',
                                          type: 'string',
                                        },
                                        assertionAttributeEmail: {
                                          description: '(String) Friendly name or name of the attribute within the SAML assertion to use as the user email.\nFriendly name or name of the attribute within the SAML assertion to use as the user email.',
                                          type: 'string',
                                        },
                                        assertionAttributeGroups: {
                                          description: '(String) Friendly name or name of the attribute within the SAML assertion to use as the user groups.\nFriendly name or name of the attribute within the SAML assertion to use as the user groups.',
                                          type: 'string',
                                        },
                                        assertionAttributeLogin: {
                                          description: '(String) Friendly name or name of the attribute within the SAML assertion to use as the user login handle.\nFriendly name or name of the attribute within the SAML assertion to use as the user login handle.',
                                          type: 'string',
                                        },
                                        assertionAttributeName: {
                                          description: '(String) Friendly name or name of the attribute within the SAML assertion to use as the user name. Alternatively, this can be a template with variables that match the names of attributes within the SAML assertion.\nFriendly name or name of the attribute within the SAML assertion to use as the user name. Alternatively, this can be a template with variables that match the names of attributes within the SAML assertion.',
                                          type: 'string',
                                        },
                                        assertionAttributeOrg: {
                                          description: '(String) Friendly name or name of the attribute within the SAML assertion to use as the user organization.\nFriendly name or name of the attribute within the SAML assertion to use as the user organization.',
                                          type: 'string',
                                        },
                                        assertionAttributeRole: {
                                          description: '(String) Friendly name or name of the attribute within the SAML assertion to use as the user roles.\nFriendly name or name of the attribute within the SAML assertion to use as the user roles.',
                                          type: 'string',
                                        },
                                        autoLogin: {
                                          description: '(Boolean) Log in automatically, skipping the login screen.\nWhether SAML auto login is enabled.',
                                          type: 'boolean',
                                        },
                                        certificatePath: {
                                          description: '(String) Path for the SP X.509 certificate.\nPath for the SP X.509 certificate.',
                                          type: 'string',
                                        },
                                        certificateSecretRef: {
                                          description: 'encoded string for the SP X.509 certificate.\nBase64-encoded string for the SP X.509 certificate.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        enabled: {
                                          description: '(Boolean) Define whether this configuration is enabled for the specified provider. Defaults to true.\nDefine whether this configuration is enabled for SAML. Defaults to `true`.',
                                          type: 'boolean',
                                        },
                                        idpMetadata: {
                                          description: 'encoded string for the IdP SAML metadata XML.\nBase64-encoded string for the IdP SAML metadata XML.',
                                          type: 'string',
                                        },
                                        idpMetadataPath: {
                                          description: '(String) Path for the IdP SAML metadata XML.\nPath for the IdP SAML metadata XML.',
                                          type: 'string',
                                        },
                                        idpMetadataUrl: {
                                          description: '(String) URL for the IdP SAML metadata XML.\nURL for the IdP SAML metadata XML.',
                                          type: 'string',
                                        },
                                        maxIssueDelay: {
                                          description: '(String) Duration, since the IdP issued a response and the SP is allowed to process it. For example: 90s, 1h.\nDuration, since the IdP issued a response and the SP is allowed to process it. For example: 90s, 1h.',
                                          type: 'string',
                                        },
                                        metadataValidDuration: {
                                          description: '(String) Duration, for how long the SP metadata is valid. For example: 48h, 5d.\nDuration, for how long the SP metadata is valid. For example: 48h, 5d.',
                                          type: 'string',
                                        },
                                        name: {
                                          description: '(String) Helpful if you use more than one identity providers or SSO protocols.\nName used to refer to the SAML authentication.',
                                          type: 'string',
                                        },
                                        nameIdFormat: {
                                          description: 'format:transient\nThe Name ID Format to request within the SAML assertion. Defaults to urn:oasis:names:tc:SAML:2.0:nameid-format:transient',
                                          type: 'string',
                                        },
                                        orgMapping: {
                                          description: 'or space-separated Organization:OrgId:Role mappings. Organization can be * meaning “All users”. Role is optional and can have the following values: Viewer, Editor or Admin.\nList of comma- or space-separated Organization:OrgId:Role mappings. Organization can be * meaning “All users”. Role is optional and can have the following values: Viewer, Editor or Admin.',
                                          type: 'string',
                                        },
                                        privateKeyPath: {
                                          description: '(String) Path for the SP private key.\nPath for the SP private key.',
                                          type: 'string',
                                        },
                                        privateKeySecretRef: {
                                          description: 'encoded string for the SP private key.\nBase64-encoded string for the SP private key.',
                                          properties: {
                                            key: {
                                              description: 'The key to select.',
                                              type: 'string',
                                            },
                                            name: {
                                              description: 'Name of the secret.',
                                              type: 'string',
                                            },
                                            namespace: {
                                              description: 'Namespace of the secret.',
                                              type: 'string',
                                            },
                                          },
                                          required: [
                                            'key',
                                            'name',
                                            'namespace',
                                          ],
                                          type: 'object',
                                        },
                                        relayState: {
                                          description: 'initiated login. Should match relay state configured in IdP.\nRelay state for IdP-initiated login. Should match relay state configured in IdP.',
                                          type: 'string',
                                        },
                                        roleValuesAdmin: {
                                          description: 'or space-separated roles which will be mapped into the Admin role.\nList of comma- or space-separated roles which will be mapped into the Admin role.',
                                          type: 'string',
                                        },
                                        roleValuesEditor: {
                                          description: 'or space-separated roles which will be mapped into the Editor role.\nList of comma- or space-separated roles which will be mapped into the Editor role.',
                                          type: 'string',
                                        },
                                        roleValuesGrafanaAdmin: {
                                          description: 'or space-separated roles which will be mapped into the Grafana Admin (Super Admin) role.\nList of comma- or space-separated roles which will be mapped into the Grafana Admin (Super Admin) role.',
                                          type: 'string',
                                        },
                                        roleValuesNone: {
                                          description: 'or space-separated roles which will be mapped into the None role.\nList of comma- or space-separated roles which will be mapped into the None role.',
                                          type: 'string',
                                        },
                                        roleValuesViewer: {
                                          description: 'or space-separated roles which will be mapped into the Viewer role.\nList of comma- or space-separated roles which will be mapped into the Viewer role.',
                                          type: 'string',
                                        },
                                        signatureAlgorithm: {
                                          description: 'sha1, rsa-sha256, rsa-sha512.\nSignature algorithm used for signing requests to the IdP. Supported values are rsa-sha1, rsa-sha256, rsa-sha512.',
                                          type: 'string',
                                        },
                                        singleLogout: {
                                          description: '(Boolean) Whether SAML Single Logout is enabled.\nWhether SAML Single Logout is enabled.',
                                          type: 'boolean',
                                        },
                                        skipOrgRoleSync: {
                                          description: '(Boolean) Prevent synchronizing users’ organization roles from your IdP.\nPrevent synchronizing users’ organization roles from your IdP.',
                                          type: 'boolean',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.providerName is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.providerName) || (has(self.initProvider) && has(self.initProvider.providerName))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      team: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xteams.oss.grafana.crossplane.io.namespaced',
            },
            name: 'team-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XTeam',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'Team',
                },
                name: 'team',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.email',
                    toFieldPath: 'spec.forProvider.email',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.ignoreExternallySyncedMembers',
                    toFieldPath: 'spec.forProvider.ignoreExternallySyncedMembers',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.memberRefs',
                    toFieldPath: 'spec.forProvider.memberRefs',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.memberSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.memberSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.memberSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.memberSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.memberSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.memberSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.memberSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.memberSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.members',
                    toFieldPath: 'spec.forProvider.members',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.orgId',
                    toFieldPath: 'spec.forProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.name',
                    toFieldPath: 'spec.forProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.preferences',
                    toFieldPath: 'spec.forProvider.preferences',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.teamSync',
                    toFieldPath: 'spec.forProvider.teamSync',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.email',
                    toFieldPath: 'spec.initProvider.email',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.ignoreExternallySyncedMembers',
                    toFieldPath: 'spec.initProvider.ignoreExternallySyncedMembers',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.memberRefs',
                    toFieldPath: 'spec.initProvider.memberRefs',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.memberSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.memberSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.memberSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.memberSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.memberSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.memberSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.memberSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.memberSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.members',
                    toFieldPath: 'spec.initProvider.members',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.orgId',
                    toFieldPath: 'spec.initProvider.orgId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.name',
                    toFieldPath: 'spec.initProvider.organizationRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.organizationSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.organizationSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.organizationSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.preferences',
                    toFieldPath: 'spec.initProvider.preferences',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.teamSync',
                    toFieldPath: 'spec.initProvider.teamSync',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xteams.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Team',
              plural: 'teams',
            },
            defaultCompositionRef: {
              name: 'team-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XTeam',
              plural: 'xteams',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'TeamSpec defines the desired state of Team',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  email: {
                                    description: '(String) An email address for the team.\nAn email address for the team.',
                                    type: 'string',
                                  },
                                  ignoreExternallySyncedMembers: {
                                    description: '(Boolean) Ignores team members that have been added to team by Team Sync.\nTeam Sync can be provisioned using grafana_team_external_group resource.\nDefaults to true.\nIgnores team members that have been added to team by [Team Sync](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-team-sync/).\nTeam Sync can be provisioned using [grafana_team_external_group resource](https://registry.io/providers/grafana/grafana/latest/docs/resources/team_external_group).\nDefaults to `true`.',
                                    type: 'boolean',
                                  },
                                  memberRefs: {
                                    description: 'References to User in oss to populate members.',
                                    items: {
                                      description: 'A Reference to a named object.',
                                      properties: {
                                        name: {
                                          description: 'Name of the referenced object.',
                                          type: 'string',
                                        },
                                        policy: {
                                          description: 'Policies for referencing.',
                                          properties: {
                                            resolution: {
                                              default: 'Required',
                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                              enum: [
                                                'Required',
                                                'Optional',
                                              ],
                                              type: 'string',
                                            },
                                            resolve: {
                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                              enum: [
                                                'Always',
                                                'IfNotPresent',
                                              ],
                                              type: 'string',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'name',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  memberSelector: {
                                    description: 'Selector for a list of User in oss to populate members.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  members: {
                                    description: '(Set of String) A set of email addresses corresponding to users who should be given membership\nto the team. Note: users specified here must already exist in Grafana.\nA set of email addresses corresponding to users who should be given membership\nto the team. Note: users specified here must already exist in Grafana.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  name: {
                                    description: '(String) The display name for the Grafana team created.\nThe display name for the Grafana team created.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  preferences: {
                                    description: '(Block List, Max: 1) (see below for nested schema)',
                                    items: {
                                      properties: {
                                        homeDashboardUid: {
                                          description: '(String) The UID of the dashboard to display when a team member logs in. Defaults to “.\nThe UID of the dashboard to display when a team member logs in. Defaults to “.',
                                          type: 'string',
                                        },
                                        theme: {
                                          description: '(String) The default theme for this team. Available themes are light, dark, system, or an empty string for the default theme. Defaults to “.\nThe default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme. Defaults to “.',
                                          type: 'string',
                                        },
                                        timezone: {
                                          description: '(String) The default timezone for this team. Available values are utc, browser, or an empty string for the default. Defaults to “.\nThe default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default. Defaults to “.',
                                          type: 'string',
                                        },
                                        weekStart: {
                                          description: '(String) The default week start day for this team. Available values are sunday, monday, saturday, or an empty string for the default. Defaults to “.\nThe default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default. Defaults to “.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  teamSync: {
                                    description: '(Block List, Max: 1) Sync external auth provider groups with this Grafana team. Only available in Grafana Enterprise.\nSync external auth provider groups with this Grafana team. Only available in Grafana Enterprise.\n* [Official documentation](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-team-sync/)\n* [HTTP API](https://grafana.com/docs/grafana/latest/developers/http_api/team_sync/)',
                                    items: {
                                      properties: {
                                        groups: {
                                          description: '(Set of String)',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                          'x-kubernetes-list-type': 'set',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  email: {
                                    description: '(String) An email address for the team.\nAn email address for the team.',
                                    type: 'string',
                                  },
                                  ignoreExternallySyncedMembers: {
                                    description: '(Boolean) Ignores team members that have been added to team by Team Sync.\nTeam Sync can be provisioned using grafana_team_external_group resource.\nDefaults to true.\nIgnores team members that have been added to team by [Team Sync](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-team-sync/).\nTeam Sync can be provisioned using [grafana_team_external_group resource](https://registry.io/providers/grafana/grafana/latest/docs/resources/team_external_group).\nDefaults to `true`.',
                                    type: 'boolean',
                                  },
                                  memberRefs: {
                                    description: 'References to User in oss to populate members.',
                                    items: {
                                      description: 'A Reference to a named object.',
                                      properties: {
                                        name: {
                                          description: 'Name of the referenced object.',
                                          type: 'string',
                                        },
                                        policy: {
                                          description: 'Policies for referencing.',
                                          properties: {
                                            resolution: {
                                              default: 'Required',
                                              description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                              enum: [
                                                'Required',
                                                'Optional',
                                              ],
                                              type: 'string',
                                            },
                                            resolve: {
                                              description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                              enum: [
                                                'Always',
                                                'IfNotPresent',
                                              ],
                                              type: 'string',
                                            },
                                          },
                                          type: 'object',
                                        },
                                      },
                                      required: [
                                        'name',
                                      ],
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  memberSelector: {
                                    description: 'Selector for a list of User in oss to populate members.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  members: {
                                    description: '(Set of String) A set of email addresses corresponding to users who should be given membership\nto the team. Note: users specified here must already exist in Grafana.\nA set of email addresses corresponding to users who should be given membership\nto the team. Note: users specified here must already exist in Grafana.',
                                    items: {
                                      type: 'string',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  name: {
                                    description: '(String) The display name for the Grafana team created.\nThe display name for the Grafana team created.',
                                    type: 'string',
                                  },
                                  orgId: {
                                    description: '(String) The Organization ID. If not set, the Org ID defined in the provider block will be used.\nThe Organization ID. If not set, the Org ID defined in the provider block will be used.',
                                    type: 'string',
                                  },
                                  organizationRef: {
                                    description: 'Reference to a Organization in oss to populate orgId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  organizationSelector: {
                                    description: 'Selector for a Organization in oss to populate orgId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  preferences: {
                                    description: '(Block List, Max: 1) (see below for nested schema)',
                                    items: {
                                      properties: {
                                        homeDashboardUid: {
                                          description: '(String) The UID of the dashboard to display when a team member logs in. Defaults to “.\nThe UID of the dashboard to display when a team member logs in. Defaults to “.',
                                          type: 'string',
                                        },
                                        theme: {
                                          description: '(String) The default theme for this team. Available themes are light, dark, system, or an empty string for the default theme. Defaults to “.\nThe default theme for this team. Available themes are `light`, `dark`, `system`, or an empty string for the default theme. Defaults to “.',
                                          type: 'string',
                                        },
                                        timezone: {
                                          description: '(String) The default timezone for this team. Available values are utc, browser, or an empty string for the default. Defaults to “.\nThe default timezone for this team. Available values are `utc`, `browser`, or an empty string for the default. Defaults to “.',
                                          type: 'string',
                                        },
                                        weekStart: {
                                          description: '(String) The default week start day for this team. Available values are sunday, monday, saturday, or an empty string for the default. Defaults to “.\nThe default week start day for this team. Available values are `sunday`, `monday`, `saturday`, or an empty string for the default. Defaults to “.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  teamSync: {
                                    description: '(Block List, Max: 1) Sync external auth provider groups with this Grafana team. Only available in Grafana Enterprise.\nSync external auth provider groups with this Grafana team. Only available in Grafana Enterprise.\n* [Official documentation](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-team-sync/)\n* [HTTP API](https://grafana.com/docs/grafana/latest/developers/http_api/team_sync/)',
                                    items: {
                                      properties: {
                                        groups: {
                                          description: '(Set of String)',
                                          items: {
                                            type: 'string',
                                          },
                                          type: 'array',
                                          'x-kubernetes-list-type': 'set',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      user: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xusers.oss.grafana.crossplane.io.namespaced',
            },
            name: 'user-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'oss.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XUser',
            },
            resources: [
              {
                base: {
                  apiVersion: 'oss.grafana.crossplane.io/v1alpha1',
                  kind: 'User',
                },
                name: 'user',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.email',
                    toFieldPath: 'spec.forProvider.email',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.isAdmin',
                    toFieldPath: 'spec.forProvider.isAdmin',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.login',
                    toFieldPath: 'spec.forProvider.login',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.passwordSecretRef.key',
                    toFieldPath: 'spec.forProvider.passwordSecretRef.key',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.passwordSecretRef.name',
                    toFieldPath: 'spec.forProvider.passwordSecretRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.passwordSecretRef.namespace',
                    toFieldPath: 'spec.forProvider.passwordSecretRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.email',
                    toFieldPath: 'spec.initProvider.email',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.isAdmin',
                    toFieldPath: 'spec.initProvider.isAdmin',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.login',
                    toFieldPath: 'spec.initProvider.login',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.passwordSecretRef.key',
                    toFieldPath: 'spec.initProvider.passwordSecretRef.key',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.passwordSecretRef.name',
                    toFieldPath: 'spec.initProvider.passwordSecretRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.passwordSecretRef.namespace',
                    toFieldPath: 'spec.initProvider.passwordSecretRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xusers.oss.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'User',
              plural: 'users',
            },
            defaultCompositionRef: {
              name: 'user-namespaced',
            },
            group: 'oss.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XUser',
              plural: 'xusers',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'UserSpec defines the desired state of User',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  email: {
                                    description: '(String) The email address of the Grafana user.\nThe email address of the Grafana user.',
                                    type: 'string',
                                  },
                                  isAdmin: {
                                    description: '(Boolean) Whether to make user an admin. Defaults to false.\nWhether to make user an admin. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  login: {
                                    description: '(String) The username for the Grafana user.\nThe username for the Grafana user.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: '(String) The display name for the Grafana user.\nThe display name for the Grafana user.',
                                    type: 'string',
                                  },
                                  passwordSecretRef: {
                                    description: '(String, Sensitive) The password for the Grafana user.\nThe password for the Grafana user.',
                                    properties: {
                                      key: {
                                        description: 'The key to select.',
                                        type: 'string',
                                      },
                                      name: {
                                        description: 'Name of the secret.',
                                        type: 'string',
                                      },
                                      namespace: {
                                        description: 'Namespace of the secret.',
                                        type: 'string',
                                      },
                                    },
                                    required: [
                                      'key',
                                      'name',
                                      'namespace',
                                    ],
                                    type: 'object',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  email: {
                                    description: '(String) The email address of the Grafana user.\nThe email address of the Grafana user.',
                                    type: 'string',
                                  },
                                  isAdmin: {
                                    description: '(Boolean) Whether to make user an admin. Defaults to false.\nWhether to make user an admin. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  login: {
                                    description: '(String) The username for the Grafana user.\nThe username for the Grafana user.',
                                    type: 'string',
                                  },
                                  name: {
                                    description: '(String) The display name for the Grafana user.\nThe display name for the Grafana user.',
                                    type: 'string',
                                  },
                                  passwordSecretRef: {
                                    description: '(String, Sensitive) The password for the Grafana user.\nThe password for the Grafana user.',
                                    properties: {
                                      key: {
                                        description: 'The key to select.',
                                        type: 'string',
                                      },
                                      name: {
                                        description: 'Name of the secret.',
                                        type: 'string',
                                      },
                                      namespace: {
                                        description: 'Namespace of the secret.',
                                        type: 'string',
                                      },
                                    },
                                    required: [
                                      'key',
                                      'name',
                                      'namespace',
                                    ],
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'passwordSecretRef',
                                ],
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.email is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.email) || (has(self.initProvider) && has(self.initProvider.email))",
                              },
                              {
                                message: 'spec.forProvider.passwordSecretRef is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.passwordSecretRef)",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
    },
  },
  slo: {
    v1alpha1: {
      slo: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xslos.slo.grafana.crossplane.io.namespaced',
            },
            name: 'slo-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'slo.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XSLO',
            },
            resources: [
              {
                base: {
                  apiVersion: 'slo.grafana.crossplane.io/v1alpha1',
                  kind: 'SLO',
                },
                name: 'slo',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.alerting',
                    toFieldPath: 'spec.forProvider.alerting',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.description',
                    toFieldPath: 'spec.forProvider.description',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.destinationDatasource',
                    toFieldPath: 'spec.forProvider.destinationDatasource',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.folderUid',
                    toFieldPath: 'spec.forProvider.folderUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.label',
                    toFieldPath: 'spec.forProvider.label',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.objectives',
                    toFieldPath: 'spec.forProvider.objectives',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.query',
                    toFieldPath: 'spec.forProvider.query',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.alerting',
                    toFieldPath: 'spec.initProvider.alerting',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.description',
                    toFieldPath: 'spec.initProvider.description',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.destinationDatasource',
                    toFieldPath: 'spec.initProvider.destinationDatasource',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.folderUid',
                    toFieldPath: 'spec.initProvider.folderUid',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.label',
                    toFieldPath: 'spec.initProvider.label',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.objectives',
                    toFieldPath: 'spec.initProvider.objectives',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.query',
                    toFieldPath: 'spec.initProvider.query',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xslos.slo.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'SLO',
              plural: 'slos',
            },
            defaultCompositionRef: {
              name: 'slo-namespaced',
            },
            group: 'slo.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XSLO',
              plural: 'xslos',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'SLOSpec defines the desired state of SLO',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  alerting: {
                                    description: 'term error budget burn is very high, the\nlong-term error budget burn rate is high, or when the remaining\nerror budget is below a certain threshold. Annotations and Labels support templating. (see below for nested schema)\nConfigures the alerting rules that will be generated for each\ntime window associated with the SLO. Grafana SLOs can generate\nalerts when the short-term error budget burn is very high, the\nlong-term error budget burn rate is high, or when the remaining\nerror budget is below a certain threshold. Annotations and Labels support templating.',
                                    items: {
                                      properties: {
                                        advancedOptions: {
                                          description: '(Block List, Max: 1) Advanced Options for Alert Rules (see below for nested schema)\nAdvanced Options for Alert Rules',
                                          items: {
                                            properties: {
                                              minFailures: {
                                                description: '(Number) Minimum number of failed events to trigger an alert\nMinimum number of failed events to trigger an alert',
                                                type: 'number',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        annotation: {
                                          description: '(Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)\nAnnotations will be attached to all alerts generated by any of these rules.',
                                          items: {
                                            properties: {
                                              key: {
                                                description: '(String)',
                                                type: 'string',
                                              },
                                              value: {
                                                description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        fastburn: {
                                          description: '(Block List, Max: 1) Alerting Rules generated for Fast Burn alerts (see below for nested schema)\nAlerting Rules generated for Fast Burn alerts',
                                          items: {
                                            properties: {
                                              annotation: {
                                                description: '(Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)\nAnnotations to attach only to Fast Burn alerts.',
                                                items: {
                                                  properties: {
                                                    key: {
                                                      description: '(String)',
                                                      type: 'string',
                                                    },
                                                    value: {
                                                      description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              label: {
                                                description: '"^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)\nLabels to attach only to Fast Burn alerts.',
                                                items: {
                                                  properties: {
                                                    key: {
                                                      description: '(String)',
                                                      type: 'string',
                                                    },
                                                    value: {
                                                      description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        label: {
                                          description: '"^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)\nLabels will be attached to all alerts generated by any of these rules.',
                                          items: {
                                            properties: {
                                              key: {
                                                description: '(String)',
                                                type: 'string',
                                              },
                                              value: {
                                                description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        slowburn: {
                                          description: '(Block List, Max: 1) Alerting Rules generated for Slow Burn alerts (see below for nested schema)\nAlerting Rules generated for Slow Burn alerts',
                                          items: {
                                            properties: {
                                              annotation: {
                                                description: '(Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)\nAnnotations to attach only to Slow Burn alerts.',
                                                items: {
                                                  properties: {
                                                    key: {
                                                      description: '(String)',
                                                      type: 'string',
                                                    },
                                                    value: {
                                                      description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              label: {
                                                description: '"^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)\nLabels to attach only to Slow Burn alerts.',
                                                items: {
                                                  properties: {
                                                    key: {
                                                      description: '(String)',
                                                      type: 'string',
                                                    },
                                                    value: {
                                                      description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  description: {
                                    description: 'text field that can provide more context to an SLO.\nDescription is a free-text field that can provide more context to an SLO.',
                                    type: 'string',
                                  },
                                  destinationDatasource: {
                                    description: '(Block List, Max: 1) Destination Datasource sets the datasource defined for an SLO (see below for nested schema)\nDestination Datasource sets the datasource defined for an SLO',
                                    items: {
                                      properties: {
                                        ref: {
                                          description: 'Reference to a DataSource in oss to populate uid.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        selector: {
                                          description: 'Selector for a DataSource in oss to populate uid.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        uid: {
                                          description: '(String) UID for the Mimir Datasource\nUID for the Mimir Datasource',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  folderUid: {
                                    description: '(String) UID for the SLO folder\nUID for the SLO folder',
                                    type: 'string',
                                  },
                                  label: {
                                    description: '"^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)\nAdditional labels that will be attached to all metrics generated from the query. These labels are useful for grouping SLOs in dashboard views that you create by hand. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"',
                                    items: {
                                      properties: {
                                        key: {
                                          description: '(String)',
                                          type: 'string',
                                        },
                                        value: {
                                          description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  name: {
                                    description: '(String) Name should be a short description of your indicator. Consider names like "API Availability"\nName should be a short description of your indicator. Consider names like "API Availability"',
                                    type: 'string',
                                  },
                                  objectives: {
                                    description: '(Block List, Min: 1) Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget. (see below for nested schema)\nOver each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget.',
                                    items: {
                                      properties: {
                                        value: {
                                          description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.\nValue between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                          type: 'number',
                                        },
                                        window: {
                                          description: 'parsable time duration string like 24h, 60m. This is the time window the objective is measured over.\nA Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  query: {
                                    description: '(Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)\nQuery describes the indicator that will be measured against the objective. Freeform Query types are currently supported.',
                                    items: {
                                      properties: {
                                        freeform: {
                                          description: '(Block List, Max: 1) (see below for nested schema)',
                                          items: {
                                            properties: {
                                              query: {
                                                description: '(Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)\nFreeform Query Field',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        ratio: {
                                          description: '(Block List, Max: 1) (see below for nested schema)',
                                          items: {
                                            properties: {
                                              groupByLabels: {
                                                description: 'label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"\nDefines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                              },
                                              successMetric: {
                                                description: '(String) Counter metric for success events (numerator)\nCounter metric for success events (numerator)',
                                                type: 'string',
                                              },
                                              totalMetric: {
                                                description: '(String) Metric for total events (denominator)\nMetric for total events (denominator)',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        type: {
                                          description: '(String) Query type must be one of: "freeform", "query", "ratio", or "threshold"\nQuery type must be one of: "freeform", "query", "ratio", or "threshold"',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  alerting: {
                                    description: 'term error budget burn is very high, the\nlong-term error budget burn rate is high, or when the remaining\nerror budget is below a certain threshold. Annotations and Labels support templating. (see below for nested schema)\nConfigures the alerting rules that will be generated for each\ntime window associated with the SLO. Grafana SLOs can generate\nalerts when the short-term error budget burn is very high, the\nlong-term error budget burn rate is high, or when the remaining\nerror budget is below a certain threshold. Annotations and Labels support templating.',
                                    items: {
                                      properties: {
                                        advancedOptions: {
                                          description: '(Block List, Max: 1) Advanced Options for Alert Rules (see below for nested schema)\nAdvanced Options for Alert Rules',
                                          items: {
                                            properties: {
                                              minFailures: {
                                                description: '(Number) Minimum number of failed events to trigger an alert\nMinimum number of failed events to trigger an alert',
                                                type: 'number',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        annotation: {
                                          description: '(Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)\nAnnotations will be attached to all alerts generated by any of these rules.',
                                          items: {
                                            properties: {
                                              key: {
                                                description: '(String)',
                                                type: 'string',
                                              },
                                              value: {
                                                description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        fastburn: {
                                          description: '(Block List, Max: 1) Alerting Rules generated for Fast Burn alerts (see below for nested schema)\nAlerting Rules generated for Fast Burn alerts',
                                          items: {
                                            properties: {
                                              annotation: {
                                                description: '(Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)\nAnnotations to attach only to Fast Burn alerts.',
                                                items: {
                                                  properties: {
                                                    key: {
                                                      description: '(String)',
                                                      type: 'string',
                                                    },
                                                    value: {
                                                      description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              label: {
                                                description: '"^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)\nLabels to attach only to Fast Burn alerts.',
                                                items: {
                                                  properties: {
                                                    key: {
                                                      description: '(String)',
                                                      type: 'string',
                                                    },
                                                    value: {
                                                      description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        label: {
                                          description: '"^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)\nLabels will be attached to all alerts generated by any of these rules.',
                                          items: {
                                            properties: {
                                              key: {
                                                description: '(String)',
                                                type: 'string',
                                              },
                                              value: {
                                                description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        slowburn: {
                                          description: '(Block List, Max: 1) Alerting Rules generated for Slow Burn alerts (see below for nested schema)\nAlerting Rules generated for Slow Burn alerts',
                                          items: {
                                            properties: {
                                              annotation: {
                                                description: '(Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)\nAnnotations to attach only to Slow Burn alerts.',
                                                items: {
                                                  properties: {
                                                    key: {
                                                      description: '(String)',
                                                      type: 'string',
                                                    },
                                                    value: {
                                                      description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              label: {
                                                description: '"^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)\nLabels to attach only to Slow Burn alerts.',
                                                items: {
                                                  properties: {
                                                    key: {
                                                      description: '(String)',
                                                      type: 'string',
                                                    },
                                                    value: {
                                                      description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  description: {
                                    description: 'text field that can provide more context to an SLO.\nDescription is a free-text field that can provide more context to an SLO.',
                                    type: 'string',
                                  },
                                  destinationDatasource: {
                                    description: '(Block List, Max: 1) Destination Datasource sets the datasource defined for an SLO (see below for nested schema)\nDestination Datasource sets the datasource defined for an SLO',
                                    items: {
                                      properties: {
                                        ref: {
                                          description: 'Reference to a DataSource in oss to populate uid.',
                                          properties: {
                                            name: {
                                              description: 'Name of the referenced object.',
                                              type: 'string',
                                            },
                                            policy: {
                                              description: 'Policies for referencing.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          required: [
                                            'name',
                                          ],
                                          type: 'object',
                                        },
                                        selector: {
                                          description: 'Selector for a DataSource in oss to populate uid.',
                                          properties: {
                                            matchControllerRef: {
                                              description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                              type: 'boolean',
                                            },
                                            matchLabels: {
                                              additionalProperties: {
                                                type: 'string',
                                              },
                                              description: 'MatchLabels ensures an object with matching labels is selected.',
                                              type: 'object',
                                            },
                                            policy: {
                                              description: 'Policies for selection.',
                                              properties: {
                                                resolution: {
                                                  default: 'Required',
                                                  description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                                  enum: [
                                                    'Required',
                                                    'Optional',
                                                  ],
                                                  type: 'string',
                                                },
                                                resolve: {
                                                  description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                                  enum: [
                                                    'Always',
                                                    'IfNotPresent',
                                                  ],
                                                  type: 'string',
                                                },
                                              },
                                              type: 'object',
                                            },
                                          },
                                          type: 'object',
                                        },
                                        uid: {
                                          description: '(String) UID for the Mimir Datasource\nUID for the Mimir Datasource',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  folderUid: {
                                    description: '(String) UID for the SLO folder\nUID for the SLO folder',
                                    type: 'string',
                                  },
                                  label: {
                                    description: '"^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)\nAdditional labels that will be attached to all metrics generated from the query. These labels are useful for grouping SLOs in dashboard views that you create by hand. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"',
                                    items: {
                                      properties: {
                                        key: {
                                          description: '(String)',
                                          type: 'string',
                                        },
                                        value: {
                                          description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  name: {
                                    description: '(String) Name should be a short description of your indicator. Consider names like "API Availability"\nName should be a short description of your indicator. Consider names like "API Availability"',
                                    type: 'string',
                                  },
                                  objectives: {
                                    description: '(Block List, Min: 1) Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget. (see below for nested schema)\nOver each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget.',
                                    items: {
                                      properties: {
                                        value: {
                                          description: '(Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.\nValue between 0 and 1. If the value of the query is above the objective, the SLO is met.',
                                          type: 'number',
                                        },
                                        window: {
                                          description: 'parsable time duration string like 24h, 60m. This is the time window the objective is measured over.\nA Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  query: {
                                    description: '(Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)\nQuery describes the indicator that will be measured against the objective. Freeform Query types are currently supported.',
                                    items: {
                                      properties: {
                                        freeform: {
                                          description: '(Block List, Max: 1) (see below for nested schema)',
                                          items: {
                                            properties: {
                                              query: {
                                                description: '(Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)\nFreeform Query Field',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        ratio: {
                                          description: '(Block List, Max: 1) (see below for nested schema)',
                                          items: {
                                            properties: {
                                              groupByLabels: {
                                                description: 'label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"\nDefines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                              },
                                              successMetric: {
                                                description: '(String) Counter metric for success events (numerator)\nCounter metric for success events (numerator)',
                                                type: 'string',
                                              },
                                              totalMetric: {
                                                description: '(String) Metric for total events (denominator)\nMetric for total events (denominator)',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        type: {
                                          description: '(String) Query type must be one of: "freeform", "query", "ratio", or "threshold"\nQuery type must be one of: "freeform", "query", "ratio", or "threshold"',
                                          type: 'string',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.description is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.description) || (has(self.initProvider) && has(self.initProvider.description))",
                              },
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.objectives is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.objectives) || (has(self.initProvider) && has(self.initProvider.objectives))",
                              },
                              {
                                message: 'spec.forProvider.query is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.query) || (has(self.initProvider) && has(self.initProvider.query))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
    },
  },
  sm: {
    v1alpha1: {
      check: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xchecks.sm.grafana.crossplane.io.namespaced',
            },
            name: 'check-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'sm.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XCheck',
            },
            resources: [
              {
                base: {
                  apiVersion: 'sm.grafana.crossplane.io/v1alpha1',
                  kind: 'Check',
                },
                name: 'check',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.alertSensitivity',
                    toFieldPath: 'spec.forProvider.alertSensitivity',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.basicMetricsOnly',
                    toFieldPath: 'spec.forProvider.basicMetricsOnly',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.enabled',
                    toFieldPath: 'spec.forProvider.enabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.frequency',
                    toFieldPath: 'spec.forProvider.frequency',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.job',
                    toFieldPath: 'spec.forProvider.job',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.labels',
                    toFieldPath: 'spec.forProvider.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.probes',
                    toFieldPath: 'spec.forProvider.probes',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.settings',
                    toFieldPath: 'spec.forProvider.settings',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.target',
                    toFieldPath: 'spec.forProvider.target',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.timeout',
                    toFieldPath: 'spec.forProvider.timeout',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.alertSensitivity',
                    toFieldPath: 'spec.initProvider.alertSensitivity',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.basicMetricsOnly',
                    toFieldPath: 'spec.initProvider.basicMetricsOnly',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.enabled',
                    toFieldPath: 'spec.initProvider.enabled',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.frequency',
                    toFieldPath: 'spec.initProvider.frequency',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.job',
                    toFieldPath: 'spec.initProvider.job',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.labels',
                    toFieldPath: 'spec.initProvider.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.probes',
                    toFieldPath: 'spec.initProvider.probes',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.settings',
                    toFieldPath: 'spec.initProvider.settings',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.target',
                    toFieldPath: 'spec.initProvider.target',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.timeout',
                    toFieldPath: 'spec.initProvider.timeout',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xchecks.sm.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Check',
              plural: 'checks',
            },
            defaultCompositionRef: {
              name: 'check-namespaced',
            },
            group: 'sm.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XCheck',
              plural: 'xchecks',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'CheckSpec defines the desired state of Check',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  alertSensitivity: {
                                    description: '(String) Can be set to none, low, medium, or high to correspond to the check alert levels. Defaults to none.\nCan be set to `none`, `low`, `medium`, or `high` to correspond to the check [alert levels](https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/configure-alerts/synthetic-monitoring-alerting/). Defaults to `none`.',
                                    type: 'string',
                                  },
                                  basicMetricsOnly: {
                                    description: "(Boolean) Metrics are reduced by default. Set this to false if you'd like to publish all metrics. We maintain a full list of metrics collected for each. Defaults to true.\nMetrics are reduced by default. Set this to `false` if you'd like to publish all metrics. We maintain a [full list of metrics](https://github.com/grafana/synthetic-monitoring-agent/tree/main/internal/scraper/testdata) collected for each. Defaults to `true`.",
                                    type: 'boolean',
                                  },
                                  enabled: {
                                    description: '(Boolean) Whether to enable the check. Defaults to true.\nWhether to enable the check. Defaults to `true`.',
                                    type: 'boolean',
                                  },
                                  frequency: {
                                    description: '(Number) How often the check runs in milliseconds (the value is not truly a "frequency" but a "period"). The minimum acceptable value is 1 second (1000 ms), and the maximum is 1 hour (3600000 ms). Defaults to 60000.\nHow often the check runs in milliseconds (the value is not truly a "frequency" but a "period"). The minimum acceptable value is 1 second (1000 ms), and the maximum is 1 hour (3600000 ms). Defaults to `60000`.',
                                    type: 'number',
                                  },
                                  job: {
                                    description: '(String) Name used for job label.\nName used for job label.',
                                    type: 'string',
                                  },
                                  labels: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    description: 'specific labels, to the outgoing metrics. The names and values of the labels cannot be empty, and the maximum length is 32 bytes.\nCustom labels to be included with collected metrics and logs. The maximum number of labels that can be specified per check is 5. These are applied, along with the probe-specific labels, to the outgoing metrics. The names and values of the labels cannot be empty, and the maximum length is 32 bytes.',
                                    type: 'object',
                                    'x-kubernetes-map-type': 'granular',
                                  },
                                  probes: {
                                    description: '(Set of Number) List of probe location IDs where this target will be checked from.\nList of probe location IDs where this target will be checked from.',
                                    items: {
                                      type: 'number',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  settings: {
                                    description: '(Block Set, Min: 1, Max: 1) Check settings. Should contain exactly one nested block. (see below for nested schema)\nCheck settings. Should contain exactly one nested block.',
                                    items: {
                                      properties: {
                                        dns: {
                                          description: '(Block Set, Max: 1) Settings for DNS check. The target must be a valid hostname (or IP address for PTR records). (see below for nested schema)\nSettings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).',
                                          items: {
                                            properties: {
                                              ipVersion: {
                                                description: "(String) Options are V4, V6, Any. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The Any value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to V4.\nOptions are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.",
                                                type: 'string',
                                              },
                                              port: {
                                                description: '(Number) Port to target. Defaults to 53.\nPort to target. Defaults to `53`.',
                                                type: 'number',
                                              },
                                              protocol: {
                                                description: '(String) TCP or UDP. Defaults to UDP.\n`TCP` or `UDP`. Defaults to `UDP`.',
                                                type: 'string',
                                              },
                                              recordType: {
                                                description: '(String) One of ANY, A, AAAA, CNAME, MX, NS, PTR, SOA, SRV, TXT. Defaults to A.\nOne of `ANY`, `A`, `AAAA`, `CNAME`, `MX`, `NS`, `PTR`, `SOA`, `SRV`, `TXT`. Defaults to `A`.',
                                                type: 'string',
                                              },
                                              server: {
                                                description: '(String) DNS server address to target. Defaults to 8.8.8.8.\nDNS server address to target. Defaults to `8.8.8.8`.',
                                                type: 'string',
                                              },
                                              sourceIpAddress: {
                                                description: '(String) Source IP address.\nSource IP address.',
                                                type: 'string',
                                              },
                                              validRCodes: {
                                                description: '(Set of String) List of valid response codes. Options include NOERROR, BADALG, BADMODE, BADKEY, BADCOOKIE, BADNAME, BADSIG, BADTIME, BADTRUNC, BADVERS, FORMERR, NOTIMP, NOTAUTH, NOTZONE, NXDOMAIN, NXRRSET, REFUSED, SERVFAIL, YXDOMAIN, YXRRSET.\nList of valid response codes. Options include `NOERROR`, `BADALG`, `BADMODE`, `BADKEY`, `BADCOOKIE`, `BADNAME`, `BADSIG`, `BADTIME`, `BADTRUNC`, `BADVERS`, `FORMERR`, `NOTIMP`, `NOTAUTH`, `NOTZONE`, `NXDOMAIN`, `NXRRSET`, `REFUSED`, `SERVFAIL`, `YXDOMAIN`, `YXRRSET`.',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                                'x-kubernetes-list-type': 'set',
                                              },
                                              validateAdditionalRrs: {
                                                description: '(Block Set) Validate additional matches. (see below for nested schema)\nValidate additional matches.',
                                                items: {
                                                  properties: {
                                                    failIfMatchesRegexp: {
                                                      description: '(Set of String) Fail if value matches regex.\nFail if value matches regex.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                      'x-kubernetes-list-type': 'set',
                                                    },
                                                    failIfNotMatchesRegexp: {
                                                      description: '(Set of String) Fail if value does not match regex.\nFail if value does not match regex.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                      'x-kubernetes-list-type': 'set',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              validateAnswerRrs: {
                                                description: '(Block Set, Max: 1) Validate response answer. (see below for nested schema)\nValidate response answer.',
                                                items: {
                                                  properties: {
                                                    failIfMatchesRegexp: {
                                                      description: '(Set of String) Fail if value matches regex.\nFail if value matches regex.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                      'x-kubernetes-list-type': 'set',
                                                    },
                                                    failIfNotMatchesRegexp: {
                                                      description: '(Set of String) Fail if value does not match regex.\nFail if value does not match regex.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                      'x-kubernetes-list-type': 'set',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              validateAuthorityRrs: {
                                                description: '(Block Set, Max: 1) Validate response authority. (see below for nested schema)\nValidate response authority.',
                                                items: {
                                                  properties: {
                                                    failIfMatchesRegexp: {
                                                      description: '(Set of String) Fail if value matches regex.\nFail if value matches regex.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                      'x-kubernetes-list-type': 'set',
                                                    },
                                                    failIfNotMatchesRegexp: {
                                                      description: '(Set of String) Fail if value does not match regex.\nFail if value does not match regex.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                      'x-kubernetes-list-type': 'set',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        grpc: {
                                          description: '(Block Set, Max: 1) Settings for gRPC Health check. The target must be of the form <host>:<port>, where the host portion must be a valid hostname or IP address. (see below for nested schema)\nSettings for gRPC Health check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.',
                                          items: {
                                            properties: {
                                              ipVersion: {
                                                description: "(String) Options are V4, V6, Any. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The Any value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to V4.\nOptions are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.",
                                                type: 'string',
                                              },
                                              service: {
                                                description: '(String) gRPC service.\ngRPC service.',
                                                type: 'string',
                                              },
                                              tls: {
                                                description: '(Boolean) Whether or not TLS is used when the connection is initiated. Defaults to false.\nWhether or not TLS is used when the connection is initiated. Defaults to `false`.',
                                                type: 'boolean',
                                              },
                                              tlsConfig: {
                                                description: '(Block Set, Max: 1) TLS config. (see below for nested schema)\nTLS config.',
                                                items: {
                                                  properties: {
                                                    caCert: {
                                                      description: '(String) CA certificate in PEM format.\nCA certificate in PEM format.',
                                                      type: 'string',
                                                    },
                                                    clientCert: {
                                                      description: '(String) Client certificate in PEM format.\nClient certificate in PEM format.',
                                                      type: 'string',
                                                    },
                                                    clientKeySecretRef: {
                                                      description: '(String, Sensitive) Client key in PEM format.\nClient key in PEM format.',
                                                      properties: {
                                                        key: {
                                                          description: 'The key to select.',
                                                          type: 'string',
                                                        },
                                                        name: {
                                                          description: 'Name of the secret.',
                                                          type: 'string',
                                                        },
                                                        namespace: {
                                                          description: 'Namespace of the secret.',
                                                          type: 'string',
                                                        },
                                                      },
                                                      required: [
                                                        'key',
                                                        'name',
                                                        'namespace',
                                                      ],
                                                      type: 'object',
                                                    },
                                                    insecureSkipVerify: {
                                                      description: '(Boolean) Disable target certificate validation. Defaults to false.\nDisable target certificate validation. Defaults to `false`.',
                                                      type: 'boolean',
                                                    },
                                                    serverName: {
                                                      description: '(String) Used to verify the hostname for the targets.\nUsed to verify the hostname for the targets.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        http: {
                                          description: '(Block Set, Max: 1) Settings for HTTP check. The target must be a URL (http or https). (see below for nested schema)\nSettings for HTTP check. The target must be a URL (http or https).',
                                          items: {
                                            properties: {
                                              basicAuth: {
                                                description: '(Block Set, Max: 1) Basic auth settings. (see below for nested schema)\nBasic auth settings.',
                                                items: {
                                                  properties: {
                                                    password: {
                                                      description: '(String) Basic auth password.\nBasic auth password.',
                                                      type: 'string',
                                                    },
                                                    username: {
                                                      description: '(String) Basic auth username.\nBasic auth username.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              bearerToken: {
                                                description: '(String) Token for use with bearer authorization header.\nToken for use with bearer authorization header.',
                                                type: 'string',
                                              },
                                              body: {
                                                description: '(String) The body of the HTTP request used in probe.\nThe body of the HTTP request used in probe.',
                                                type: 'string',
                                              },
                                              cacheBustingQueryParamName: {
                                                description: '(String) The name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.\nThe name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.',
                                                type: 'string',
                                              },
                                              failIfBodyMatchesRegexp: {
                                                description: '(Set of String) List of regexes. If any match the response body, the check will fail.\nList of regexes. If any match the response body, the check will fail.',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                                'x-kubernetes-list-type': 'set',
                                              },
                                              failIfBodyNotMatchesRegexp: {
                                                description: '(Set of String) List of regexes. If any do not match the response body, the check will fail.\nList of regexes. If any do not match the response body, the check will fail.',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                                'x-kubernetes-list-type': 'set',
                                              },
                                              failIfHeaderMatchesRegexp: {
                                                description: '(Block Set) Check fails if headers match. (see below for nested schema)\nCheck fails if headers match.',
                                                items: {
                                                  properties: {
                                                    allowMissing: {
                                                      description: '(Boolean) Allow header to be missing from responses. Defaults to false.\nAllow header to be missing from responses. Defaults to `false`.',
                                                      type: 'boolean',
                                                    },
                                                    header: {
                                                      description: '(String) Header name.\nHeader name.',
                                                      type: 'string',
                                                    },
                                                    regexp: {
                                                      description: '(String) Regex that header value should match.\nRegex that header value should match.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              failIfHeaderNotMatchesRegexp: {
                                                description: '(Block Set) Check fails if headers do not match. (see below for nested schema)\nCheck fails if headers do not match.',
                                                items: {
                                                  properties: {
                                                    allowMissing: {
                                                      description: '(Boolean) Allow header to be missing from responses. Defaults to false.\nAllow header to be missing from responses. Defaults to `false`.',
                                                      type: 'boolean',
                                                    },
                                                    header: {
                                                      description: '(String) Header name.\nHeader name.',
                                                      type: 'string',
                                                    },
                                                    regexp: {
                                                      description: '(String) Regex that header value should match.\nRegex that header value should match.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              failIfNotSsl: {
                                                description: '(Boolean) Fail if SSL is not present. Defaults to false.\nFail if SSL is not present. Defaults to `false`.',
                                                type: 'boolean',
                                              },
                                              failIfSsl: {
                                                description: '(Boolean) Fail if SSL is present. Defaults to false.\nFail if SSL is present. Defaults to `false`.',
                                                type: 'boolean',
                                              },
                                              headers: {
                                                description: '(Set of String) The HTTP headers set for the probe.\nThe HTTP headers set for the probe.',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                                'x-kubernetes-list-type': 'set',
                                              },
                                              ipVersion: {
                                                description: "(String) Options are V4, V6, Any. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The Any value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to V4.\nOptions are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.",
                                                type: 'string',
                                              },
                                              method: {
                                                description: '(String) Request method. One of GET, CONNECT, DELETE, HEAD, OPTIONS, POST, PUT, TRACE Defaults to GET.\nRequest method. One of `GET`, `CONNECT`, `DELETE`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE` Defaults to `GET`.',
                                                type: 'string',
                                              },
                                              noFollowRedirects: {
                                                description: '(Boolean) Do not follow redirects. Defaults to false.\nDo not follow redirects. Defaults to `false`.',
                                                type: 'boolean',
                                              },
                                              proxyConnectHeaders: {
                                                description: '(Set of String) The HTTP headers sent to the proxy URL\nThe HTTP headers sent to the proxy URL',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                                'x-kubernetes-list-type': 'set',
                                              },
                                              proxyUrl: {
                                                description: '(String) Proxy URL.\nProxy URL.',
                                                type: 'string',
                                              },
                                              tlsConfig: {
                                                description: '(Block Set, Max: 1) TLS config. (see below for nested schema)\nTLS config.',
                                                items: {
                                                  properties: {
                                                    caCert: {
                                                      description: '(String) CA certificate in PEM format.\nCA certificate in PEM format.',
                                                      type: 'string',
                                                    },
                                                    clientCert: {
                                                      description: '(String) Client certificate in PEM format.\nClient certificate in PEM format.',
                                                      type: 'string',
                                                    },
                                                    clientKeySecretRef: {
                                                      description: '(String, Sensitive) Client key in PEM format.\nClient key in PEM format.',
                                                      properties: {
                                                        key: {
                                                          description: 'The key to select.',
                                                          type: 'string',
                                                        },
                                                        name: {
                                                          description: 'Name of the secret.',
                                                          type: 'string',
                                                        },
                                                        namespace: {
                                                          description: 'Namespace of the secret.',
                                                          type: 'string',
                                                        },
                                                      },
                                                      required: [
                                                        'key',
                                                        'name',
                                                        'namespace',
                                                      ],
                                                      type: 'object',
                                                    },
                                                    insecureSkipVerify: {
                                                      description: '(Boolean) Disable target certificate validation. Defaults to false.\nDisable target certificate validation. Defaults to `false`.',
                                                      type: 'boolean',
                                                    },
                                                    serverName: {
                                                      description: '(String) Used to verify the hostname for the targets.\nUsed to verify the hostname for the targets.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              validHttpVersions: {
                                                description: '(Set of String) List of valid HTTP versions. Options include HTTP/1.0, HTTP/1.1, HTTP/2.0\nList of valid HTTP versions. Options include `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                                'x-kubernetes-list-type': 'set',
                                              },
                                              validStatusCodes: {
                                                description: '(Set of Number) Accepted status codes. If unset, defaults to 2xx.\nAccepted status codes. If unset, defaults to 2xx.',
                                                items: {
                                                  type: 'number',
                                                },
                                                type: 'array',
                                                'x-kubernetes-list-type': 'set',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        multihttp: {
                                          description: '(Block Set, Max: 1) Settings for MultiHTTP check. The target must be a URL (http or https) (see below for nested schema)\nSettings for MultiHTTP check. The target must be a URL (http or https)',
                                          items: {
                                            properties: {
                                              entries: {
                                                description: '(Block List) (see below for nested schema)',
                                                items: {
                                                  properties: {
                                                    assertions: {
                                                      description: '(Block List) Assertions to make on the request response (see below for nested schema)\nAssertions to make on the request response',
                                                      items: {
                                                        properties: {
                                                          condition: {
                                                            description: '(String) The condition of the assertion: NOT_CONTAINS, EQUALS, STARTS_WITH, ENDS_WITH, TYPE_OF, CONTAINS\nThe condition of the assertion: NOT_CONTAINS, EQUALS, STARTS_WITH, ENDS_WITH, TYPE_OF, CONTAINS',
                                                            type: 'string',
                                                          },
                                                          expression: {
                                                            description: '(String) The expression of the assertion. Should start with $.\nThe expression of the assertion. Should start with $.',
                                                            type: 'string',
                                                          },
                                                          subject: {
                                                            description: '(String) The subject of the assertion: RESPONSE_HEADERS, HTTP_STATUS_CODE, RESPONSE_BODY\nThe subject of the assertion: RESPONSE_HEADERS, HTTP_STATUS_CODE, RESPONSE_BODY',
                                                            type: 'string',
                                                          },
                                                          type: {
                                                            description: '(String) The type of assertion to make: TEXT, JSON_PATH_VALUE, JSON_PATH_ASSERTION, REGEX_ASSERTION\nThe type of assertion to make: TEXT, JSON_PATH_VALUE, JSON_PATH_ASSERTION, REGEX_ASSERTION',
                                                            type: 'string',
                                                          },
                                                          value: {
                                                            description: '(String) The value of the assertion\nThe value of the assertion',
                                                            type: 'string',
                                                          },
                                                        },
                                                        type: 'object',
                                                      },
                                                      type: 'array',
                                                    },
                                                    request: {
                                                      description: '(Block Set, Max: 1) An individual MultiHTTP request (see below for nested schema)\nAn individual MultiHTTP request',
                                                      items: {
                                                        properties: {
                                                          body: {
                                                            description: '(String) The body of the HTTP request used in probe.\nThe body of the HTTP request used in probe.',
                                                            items: {
                                                              properties: {
                                                                contentEncoding: {
                                                                  description: '(String) The content encoding of the body\nThe content encoding of the body',
                                                                  type: 'string',
                                                                },
                                                                contentType: {
                                                                  description: '(String) The content type of the body\nThe content type of the body',
                                                                  type: 'string',
                                                                },
                                                                payload: {
                                                                  description: '(String) The body payload\nThe body payload',
                                                                  type: 'string',
                                                                },
                                                              },
                                                              type: 'object',
                                                            },
                                                            type: 'array',
                                                          },
                                                          headers: {
                                                            description: '(Set of String) The HTTP headers set for the probe.\nThe headers to send with the request',
                                                            items: {
                                                              properties: {
                                                                name: {
                                                                  description: '(String) Name of the header to send\nName of the header to send',
                                                                  type: 'string',
                                                                },
                                                                value: {
                                                                  description: '(String) The value of the assertion\nValue of the header to send',
                                                                  type: 'string',
                                                                },
                                                              },
                                                              type: 'object',
                                                            },
                                                            type: 'array',
                                                          },
                                                          method: {
                                                            description: '(String) Request method. One of GET, CONNECT, DELETE, HEAD, OPTIONS, POST, PUT, TRACE Defaults to GET.\nThe HTTP method to use',
                                                            type: 'string',
                                                          },
                                                          queryFields: {
                                                            description: '(Block Set) Query fields to send with the request (see below for nested schema)\nQuery fields to send with the request',
                                                            items: {
                                                              properties: {
                                                                name: {
                                                                  description: '(String) Name of the header to send\nName of the query field to send',
                                                                  type: 'string',
                                                                },
                                                                value: {
                                                                  description: '(String) The value of the assertion\nValue of the query field to send',
                                                                  type: 'string',
                                                                },
                                                              },
                                                              type: 'object',
                                                            },
                                                            type: 'array',
                                                          },
                                                          url: {
                                                            description: '(String) The URL for the request\nThe URL for the request',
                                                            type: 'string',
                                                          },
                                                        },
                                                        type: 'object',
                                                      },
                                                      type: 'array',
                                                    },
                                                    variables: {
                                                      description: '(Block List) Variables to extract from the request response (see below for nested schema)\nVariables to extract from the request response',
                                                      items: {
                                                        properties: {
                                                          attribute: {
                                                            description: '(String) The attribute to use when finding the variable value. Only used when type is CSS_SELECTOR\nThe attribute to use when finding the variable value. Only used when type is CSS_SELECTOR',
                                                            type: 'string',
                                                          },
                                                          expression: {
                                                            description: '(String) The expression of the assertion. Should start with $.\nThe expression to when finding the variable. Should start with $. Only use when type is JSON_PATH or REGEX',
                                                            type: 'string',
                                                          },
                                                          name: {
                                                            description: '(String) Name of the header to send\nThe name of the variable to extract',
                                                            type: 'string',
                                                          },
                                                          type: {
                                                            description: '(String) The type of assertion to make: TEXT, JSON_PATH_VALUE, JSON_PATH_ASSERTION, REGEX_ASSERTION\nThe method of finding the variable value to extract. JSON_PATH, REGEX, CSS_SELECTOR',
                                                            type: 'string',
                                                          },
                                                        },
                                                        type: 'object',
                                                      },
                                                      type: 'array',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        ping: {
                                          description: '(Block Set, Max: 1) Settings for ping (ICMP) check. The target must be a valid hostname or IP address. (see below for nested schema)\nSettings for ping (ICMP) check. The target must be a valid hostname or IP address.',
                                          items: {
                                            properties: {
                                              dontFragment: {
                                                description: 'bit in the IP-header. Only works with ipV4. Defaults to false.\nSet the DF-bit in the IP-header. Only works with ipV4. Defaults to `false`.',
                                                type: 'boolean',
                                              },
                                              ipVersion: {
                                                description: "(String) Options are V4, V6, Any. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The Any value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to V4.\nOptions are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.",
                                                type: 'string',
                                              },
                                              payloadSize: {
                                                description: '(Number) Payload size. Defaults to 0.\nPayload size. Defaults to `0`.',
                                                type: 'number',
                                              },
                                              sourceIpAddress: {
                                                description: '(String) Source IP address.\nSource IP address.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        scripted: {
                                          description: 'cloud/testing/synthetic-monitoring/create-checks/checks/k6/. (see below for nested schema)\nSettings for scripted check. See https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6/.',
                                          items: {
                                            properties: {
                                              script: {
                                                description: '(String)',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        tcp: {
                                          description: '(Block Set, Max: 1) Settings for TCP check. The target must be of the form <host>:<port>, where the host portion must be a valid hostname or IP address. (see below for nested schema)\nSettings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.',
                                          items: {
                                            properties: {
                                              ipVersion: {
                                                description: "(String) Options are V4, V6, Any. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The Any value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to V4.\nOptions are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.",
                                                type: 'string',
                                              },
                                              queryResponse: {
                                                description: '(Block Set) The query sent in the TCP probe and the expected associated response. (see below for nested schema)\nThe query sent in the TCP probe and the expected associated response.',
                                                items: {
                                                  properties: {
                                                    expect: {
                                                      description: '(String) Response to expect.\nResponse to expect.',
                                                      type: 'string',
                                                    },
                                                    send: {
                                                      description: '(String) Data to send.\nData to send.',
                                                      type: 'string',
                                                    },
                                                    startTls: {
                                                      description: '(Boolean) Upgrade TCP connection to TLS. Defaults to false.\nUpgrade TCP connection to TLS. Defaults to `false`.',
                                                      type: 'boolean',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              sourceIpAddress: {
                                                description: '(String) Source IP address.\nSource IP address.',
                                                type: 'string',
                                              },
                                              tls: {
                                                description: '(Boolean) Whether or not TLS is used when the connection is initiated. Defaults to false.\nWhether or not TLS is used when the connection is initiated. Defaults to `false`.',
                                                type: 'boolean',
                                              },
                                              tlsConfig: {
                                                description: '(Block Set, Max: 1) TLS config. (see below for nested schema)\nTLS config.',
                                                items: {
                                                  properties: {
                                                    caCert: {
                                                      description: '(String) CA certificate in PEM format.\nCA certificate in PEM format.',
                                                      type: 'string',
                                                    },
                                                    clientCert: {
                                                      description: '(String) Client certificate in PEM format.\nClient certificate in PEM format.',
                                                      type: 'string',
                                                    },
                                                    clientKeySecretRef: {
                                                      description: '(String, Sensitive) Client key in PEM format.\nClient key in PEM format.',
                                                      properties: {
                                                        key: {
                                                          description: 'The key to select.',
                                                          type: 'string',
                                                        },
                                                        name: {
                                                          description: 'Name of the secret.',
                                                          type: 'string',
                                                        },
                                                        namespace: {
                                                          description: 'Namespace of the secret.',
                                                          type: 'string',
                                                        },
                                                      },
                                                      required: [
                                                        'key',
                                                        'name',
                                                        'namespace',
                                                      ],
                                                      type: 'object',
                                                    },
                                                    insecureSkipVerify: {
                                                      description: '(Boolean) Disable target certificate validation. Defaults to false.\nDisable target certificate validation. Defaults to `false`.',
                                                      type: 'boolean',
                                                    },
                                                    serverName: {
                                                      description: '(String) Used to verify the hostname for the targets.\nUsed to verify the hostname for the targets.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        traceroute: {
                                          description: '(Block Set, Max: 1) Settings for traceroute check. The target must be a valid hostname or IP address (see below for nested schema)\nSettings for traceroute check. The target must be a valid hostname or IP address',
                                          items: {
                                            properties: {
                                              maxHops: {
                                                description: '(Number) Maximum TTL for the trace Defaults to 64.\nMaximum TTL for the trace Defaults to `64`.',
                                                type: 'number',
                                              },
                                              maxUnknownHops: {
                                                description: '(Number) Maximum number of hosts to travers that give no response Defaults to 15.\nMaximum number of hosts to travers that give no response Defaults to `15`.',
                                                type: 'number',
                                              },
                                              ptrLookup: {
                                                description: '(Boolean) Reverse lookup hostnames from IP addresses Defaults to true.\nReverse lookup hostnames from IP addresses Defaults to `true`.',
                                                type: 'boolean',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  target: {
                                    description: '(String) Hostname to ping.\nHostname to ping.',
                                    type: 'string',
                                  },
                                  timeout: {
                                    description: '(Number) Specifies the maximum running time for the check in milliseconds. The minimum acceptable value is 1 second (1000 ms), and the maximum 10 seconds (10000 ms). Defaults to 3000.\nSpecifies the maximum running time for the check in milliseconds. The minimum acceptable value is 1 second (1000 ms), and the maximum 10 seconds (10000 ms). Defaults to `3000`.',
                                    type: 'number',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  alertSensitivity: {
                                    description: '(String) Can be set to none, low, medium, or high to correspond to the check alert levels. Defaults to none.\nCan be set to `none`, `low`, `medium`, or `high` to correspond to the check [alert levels](https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/configure-alerts/synthetic-monitoring-alerting/). Defaults to `none`.',
                                    type: 'string',
                                  },
                                  basicMetricsOnly: {
                                    description: "(Boolean) Metrics are reduced by default. Set this to false if you'd like to publish all metrics. We maintain a full list of metrics collected for each. Defaults to true.\nMetrics are reduced by default. Set this to `false` if you'd like to publish all metrics. We maintain a [full list of metrics](https://github.com/grafana/synthetic-monitoring-agent/tree/main/internal/scraper/testdata) collected for each. Defaults to `true`.",
                                    type: 'boolean',
                                  },
                                  enabled: {
                                    description: '(Boolean) Whether to enable the check. Defaults to true.\nWhether to enable the check. Defaults to `true`.',
                                    type: 'boolean',
                                  },
                                  frequency: {
                                    description: '(Number) How often the check runs in milliseconds (the value is not truly a "frequency" but a "period"). The minimum acceptable value is 1 second (1000 ms), and the maximum is 1 hour (3600000 ms). Defaults to 60000.\nHow often the check runs in milliseconds (the value is not truly a "frequency" but a "period"). The minimum acceptable value is 1 second (1000 ms), and the maximum is 1 hour (3600000 ms). Defaults to `60000`.',
                                    type: 'number',
                                  },
                                  job: {
                                    description: '(String) Name used for job label.\nName used for job label.',
                                    type: 'string',
                                  },
                                  labels: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    description: 'specific labels, to the outgoing metrics. The names and values of the labels cannot be empty, and the maximum length is 32 bytes.\nCustom labels to be included with collected metrics and logs. The maximum number of labels that can be specified per check is 5. These are applied, along with the probe-specific labels, to the outgoing metrics. The names and values of the labels cannot be empty, and the maximum length is 32 bytes.',
                                    type: 'object',
                                    'x-kubernetes-map-type': 'granular',
                                  },
                                  probes: {
                                    description: '(Set of Number) List of probe location IDs where this target will be checked from.\nList of probe location IDs where this target will be checked from.',
                                    items: {
                                      type: 'number',
                                    },
                                    type: 'array',
                                    'x-kubernetes-list-type': 'set',
                                  },
                                  settings: {
                                    description: '(Block Set, Min: 1, Max: 1) Check settings. Should contain exactly one nested block. (see below for nested schema)\nCheck settings. Should contain exactly one nested block.',
                                    items: {
                                      properties: {
                                        dns: {
                                          description: '(Block Set, Max: 1) Settings for DNS check. The target must be a valid hostname (or IP address for PTR records). (see below for nested schema)\nSettings for DNS check. The target must be a valid hostname (or IP address for `PTR` records).',
                                          items: {
                                            properties: {
                                              ipVersion: {
                                                description: "(String) Options are V4, V6, Any. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The Any value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to V4.\nOptions are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.",
                                                type: 'string',
                                              },
                                              port: {
                                                description: '(Number) Port to target. Defaults to 53.\nPort to target. Defaults to `53`.',
                                                type: 'number',
                                              },
                                              protocol: {
                                                description: '(String) TCP or UDP. Defaults to UDP.\n`TCP` or `UDP`. Defaults to `UDP`.',
                                                type: 'string',
                                              },
                                              recordType: {
                                                description: '(String) One of ANY, A, AAAA, CNAME, MX, NS, PTR, SOA, SRV, TXT. Defaults to A.\nOne of `ANY`, `A`, `AAAA`, `CNAME`, `MX`, `NS`, `PTR`, `SOA`, `SRV`, `TXT`. Defaults to `A`.',
                                                type: 'string',
                                              },
                                              server: {
                                                description: '(String) DNS server address to target. Defaults to 8.8.8.8.\nDNS server address to target. Defaults to `8.8.8.8`.',
                                                type: 'string',
                                              },
                                              sourceIpAddress: {
                                                description: '(String) Source IP address.\nSource IP address.',
                                                type: 'string',
                                              },
                                              validRCodes: {
                                                description: '(Set of String) List of valid response codes. Options include NOERROR, BADALG, BADMODE, BADKEY, BADCOOKIE, BADNAME, BADSIG, BADTIME, BADTRUNC, BADVERS, FORMERR, NOTIMP, NOTAUTH, NOTZONE, NXDOMAIN, NXRRSET, REFUSED, SERVFAIL, YXDOMAIN, YXRRSET.\nList of valid response codes. Options include `NOERROR`, `BADALG`, `BADMODE`, `BADKEY`, `BADCOOKIE`, `BADNAME`, `BADSIG`, `BADTIME`, `BADTRUNC`, `BADVERS`, `FORMERR`, `NOTIMP`, `NOTAUTH`, `NOTZONE`, `NXDOMAIN`, `NXRRSET`, `REFUSED`, `SERVFAIL`, `YXDOMAIN`, `YXRRSET`.',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                                'x-kubernetes-list-type': 'set',
                                              },
                                              validateAdditionalRrs: {
                                                description: '(Block Set) Validate additional matches. (see below for nested schema)\nValidate additional matches.',
                                                items: {
                                                  properties: {
                                                    failIfMatchesRegexp: {
                                                      description: '(Set of String) Fail if value matches regex.\nFail if value matches regex.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                      'x-kubernetes-list-type': 'set',
                                                    },
                                                    failIfNotMatchesRegexp: {
                                                      description: '(Set of String) Fail if value does not match regex.\nFail if value does not match regex.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                      'x-kubernetes-list-type': 'set',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              validateAnswerRrs: {
                                                description: '(Block Set, Max: 1) Validate response answer. (see below for nested schema)\nValidate response answer.',
                                                items: {
                                                  properties: {
                                                    failIfMatchesRegexp: {
                                                      description: '(Set of String) Fail if value matches regex.\nFail if value matches regex.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                      'x-kubernetes-list-type': 'set',
                                                    },
                                                    failIfNotMatchesRegexp: {
                                                      description: '(Set of String) Fail if value does not match regex.\nFail if value does not match regex.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                      'x-kubernetes-list-type': 'set',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              validateAuthorityRrs: {
                                                description: '(Block Set, Max: 1) Validate response authority. (see below for nested schema)\nValidate response authority.',
                                                items: {
                                                  properties: {
                                                    failIfMatchesRegexp: {
                                                      description: '(Set of String) Fail if value matches regex.\nFail if value matches regex.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                      'x-kubernetes-list-type': 'set',
                                                    },
                                                    failIfNotMatchesRegexp: {
                                                      description: '(Set of String) Fail if value does not match regex.\nFail if value does not match regex.',
                                                      items: {
                                                        type: 'string',
                                                      },
                                                      type: 'array',
                                                      'x-kubernetes-list-type': 'set',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        grpc: {
                                          description: '(Block Set, Max: 1) Settings for gRPC Health check. The target must be of the form <host>:<port>, where the host portion must be a valid hostname or IP address. (see below for nested schema)\nSettings for gRPC Health check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.',
                                          items: {
                                            properties: {
                                              ipVersion: {
                                                description: "(String) Options are V4, V6, Any. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The Any value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to V4.\nOptions are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.",
                                                type: 'string',
                                              },
                                              service: {
                                                description: '(String) gRPC service.\ngRPC service.',
                                                type: 'string',
                                              },
                                              tls: {
                                                description: '(Boolean) Whether or not TLS is used when the connection is initiated. Defaults to false.\nWhether or not TLS is used when the connection is initiated. Defaults to `false`.',
                                                type: 'boolean',
                                              },
                                              tlsConfig: {
                                                description: '(Block Set, Max: 1) TLS config. (see below for nested schema)\nTLS config.',
                                                items: {
                                                  properties: {
                                                    caCert: {
                                                      description: '(String) CA certificate in PEM format.\nCA certificate in PEM format.',
                                                      type: 'string',
                                                    },
                                                    clientCert: {
                                                      description: '(String) Client certificate in PEM format.\nClient certificate in PEM format.',
                                                      type: 'string',
                                                    },
                                                    clientKeySecretRef: {
                                                      description: '(String, Sensitive) Client key in PEM format.\nClient key in PEM format.',
                                                      properties: {
                                                        key: {
                                                          description: 'The key to select.',
                                                          type: 'string',
                                                        },
                                                        name: {
                                                          description: 'Name of the secret.',
                                                          type: 'string',
                                                        },
                                                        namespace: {
                                                          description: 'Namespace of the secret.',
                                                          type: 'string',
                                                        },
                                                      },
                                                      required: [
                                                        'key',
                                                        'name',
                                                        'namespace',
                                                      ],
                                                      type: 'object',
                                                    },
                                                    insecureSkipVerify: {
                                                      description: '(Boolean) Disable target certificate validation. Defaults to false.\nDisable target certificate validation. Defaults to `false`.',
                                                      type: 'boolean',
                                                    },
                                                    serverName: {
                                                      description: '(String) Used to verify the hostname for the targets.\nUsed to verify the hostname for the targets.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        http: {
                                          description: '(Block Set, Max: 1) Settings for HTTP check. The target must be a URL (http or https). (see below for nested schema)\nSettings for HTTP check. The target must be a URL (http or https).',
                                          items: {
                                            properties: {
                                              basicAuth: {
                                                description: '(Block Set, Max: 1) Basic auth settings. (see below for nested schema)\nBasic auth settings.',
                                                items: {
                                                  properties: {
                                                    password: {
                                                      description: '(String) Basic auth password.\nBasic auth password.',
                                                      type: 'string',
                                                    },
                                                    username: {
                                                      description: '(String) Basic auth username.\nBasic auth username.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              bearerToken: {
                                                description: '(String) Token for use with bearer authorization header.\nToken for use with bearer authorization header.',
                                                type: 'string',
                                              },
                                              body: {
                                                description: '(String) The body of the HTTP request used in probe.\nThe body of the HTTP request used in probe.',
                                                type: 'string',
                                              },
                                              cacheBustingQueryParamName: {
                                                description: '(String) The name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.\nThe name of the query parameter used to prevent the server from using a cached response. Each probe will assign a random value to this parameter each time a request is made.',
                                                type: 'string',
                                              },
                                              failIfBodyMatchesRegexp: {
                                                description: '(Set of String) List of regexes. If any match the response body, the check will fail.\nList of regexes. If any match the response body, the check will fail.',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                                'x-kubernetes-list-type': 'set',
                                              },
                                              failIfBodyNotMatchesRegexp: {
                                                description: '(Set of String) List of regexes. If any do not match the response body, the check will fail.\nList of regexes. If any do not match the response body, the check will fail.',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                                'x-kubernetes-list-type': 'set',
                                              },
                                              failIfHeaderMatchesRegexp: {
                                                description: '(Block Set) Check fails if headers match. (see below for nested schema)\nCheck fails if headers match.',
                                                items: {
                                                  properties: {
                                                    allowMissing: {
                                                      description: '(Boolean) Allow header to be missing from responses. Defaults to false.\nAllow header to be missing from responses. Defaults to `false`.',
                                                      type: 'boolean',
                                                    },
                                                    header: {
                                                      description: '(String) Header name.\nHeader name.',
                                                      type: 'string',
                                                    },
                                                    regexp: {
                                                      description: '(String) Regex that header value should match.\nRegex that header value should match.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              failIfHeaderNotMatchesRegexp: {
                                                description: '(Block Set) Check fails if headers do not match. (see below for nested schema)\nCheck fails if headers do not match.',
                                                items: {
                                                  properties: {
                                                    allowMissing: {
                                                      description: '(Boolean) Allow header to be missing from responses. Defaults to false.\nAllow header to be missing from responses. Defaults to `false`.',
                                                      type: 'boolean',
                                                    },
                                                    header: {
                                                      description: '(String) Header name.\nHeader name.',
                                                      type: 'string',
                                                    },
                                                    regexp: {
                                                      description: '(String) Regex that header value should match.\nRegex that header value should match.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              failIfNotSsl: {
                                                description: '(Boolean) Fail if SSL is not present. Defaults to false.\nFail if SSL is not present. Defaults to `false`.',
                                                type: 'boolean',
                                              },
                                              failIfSsl: {
                                                description: '(Boolean) Fail if SSL is present. Defaults to false.\nFail if SSL is present. Defaults to `false`.',
                                                type: 'boolean',
                                              },
                                              headers: {
                                                description: '(Set of String) The HTTP headers set for the probe.\nThe HTTP headers set for the probe.',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                                'x-kubernetes-list-type': 'set',
                                              },
                                              ipVersion: {
                                                description: "(String) Options are V4, V6, Any. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The Any value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to V4.\nOptions are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.",
                                                type: 'string',
                                              },
                                              method: {
                                                description: '(String) Request method. One of GET, CONNECT, DELETE, HEAD, OPTIONS, POST, PUT, TRACE Defaults to GET.\nRequest method. One of `GET`, `CONNECT`, `DELETE`, `HEAD`, `OPTIONS`, `POST`, `PUT`, `TRACE` Defaults to `GET`.',
                                                type: 'string',
                                              },
                                              noFollowRedirects: {
                                                description: '(Boolean) Do not follow redirects. Defaults to false.\nDo not follow redirects. Defaults to `false`.',
                                                type: 'boolean',
                                              },
                                              proxyConnectHeaders: {
                                                description: '(Set of String) The HTTP headers sent to the proxy URL\nThe HTTP headers sent to the proxy URL',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                                'x-kubernetes-list-type': 'set',
                                              },
                                              proxyUrl: {
                                                description: '(String) Proxy URL.\nProxy URL.',
                                                type: 'string',
                                              },
                                              tlsConfig: {
                                                description: '(Block Set, Max: 1) TLS config. (see below for nested schema)\nTLS config.',
                                                items: {
                                                  properties: {
                                                    caCert: {
                                                      description: '(String) CA certificate in PEM format.\nCA certificate in PEM format.',
                                                      type: 'string',
                                                    },
                                                    clientCert: {
                                                      description: '(String) Client certificate in PEM format.\nClient certificate in PEM format.',
                                                      type: 'string',
                                                    },
                                                    clientKeySecretRef: {
                                                      description: '(String, Sensitive) Client key in PEM format.\nClient key in PEM format.',
                                                      properties: {
                                                        key: {
                                                          description: 'The key to select.',
                                                          type: 'string',
                                                        },
                                                        name: {
                                                          description: 'Name of the secret.',
                                                          type: 'string',
                                                        },
                                                        namespace: {
                                                          description: 'Namespace of the secret.',
                                                          type: 'string',
                                                        },
                                                      },
                                                      required: [
                                                        'key',
                                                        'name',
                                                        'namespace',
                                                      ],
                                                      type: 'object',
                                                    },
                                                    insecureSkipVerify: {
                                                      description: '(Boolean) Disable target certificate validation. Defaults to false.\nDisable target certificate validation. Defaults to `false`.',
                                                      type: 'boolean',
                                                    },
                                                    serverName: {
                                                      description: '(String) Used to verify the hostname for the targets.\nUsed to verify the hostname for the targets.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              validHttpVersions: {
                                                description: '(Set of String) List of valid HTTP versions. Options include HTTP/1.0, HTTP/1.1, HTTP/2.0\nList of valid HTTP versions. Options include `HTTP/1.0`, `HTTP/1.1`, `HTTP/2.0`',
                                                items: {
                                                  type: 'string',
                                                },
                                                type: 'array',
                                                'x-kubernetes-list-type': 'set',
                                              },
                                              validStatusCodes: {
                                                description: '(Set of Number) Accepted status codes. If unset, defaults to 2xx.\nAccepted status codes. If unset, defaults to 2xx.',
                                                items: {
                                                  type: 'number',
                                                },
                                                type: 'array',
                                                'x-kubernetes-list-type': 'set',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        multihttp: {
                                          description: '(Block Set, Max: 1) Settings for MultiHTTP check. The target must be a URL (http or https) (see below for nested schema)\nSettings for MultiHTTP check. The target must be a URL (http or https)',
                                          items: {
                                            properties: {
                                              entries: {
                                                description: '(Block List) (see below for nested schema)',
                                                items: {
                                                  properties: {
                                                    assertions: {
                                                      description: '(Block List) Assertions to make on the request response (see below for nested schema)\nAssertions to make on the request response',
                                                      items: {
                                                        properties: {
                                                          condition: {
                                                            description: '(String) The condition of the assertion: NOT_CONTAINS, EQUALS, STARTS_WITH, ENDS_WITH, TYPE_OF, CONTAINS\nThe condition of the assertion: NOT_CONTAINS, EQUALS, STARTS_WITH, ENDS_WITH, TYPE_OF, CONTAINS',
                                                            type: 'string',
                                                          },
                                                          expression: {
                                                            description: '(String) The expression of the assertion. Should start with $.\nThe expression of the assertion. Should start with $.',
                                                            type: 'string',
                                                          },
                                                          subject: {
                                                            description: '(String) The subject of the assertion: RESPONSE_HEADERS, HTTP_STATUS_CODE, RESPONSE_BODY\nThe subject of the assertion: RESPONSE_HEADERS, HTTP_STATUS_CODE, RESPONSE_BODY',
                                                            type: 'string',
                                                          },
                                                          type: {
                                                            description: '(String) The type of assertion to make: TEXT, JSON_PATH_VALUE, JSON_PATH_ASSERTION, REGEX_ASSERTION\nThe type of assertion to make: TEXT, JSON_PATH_VALUE, JSON_PATH_ASSERTION, REGEX_ASSERTION',
                                                            type: 'string',
                                                          },
                                                          value: {
                                                            description: '(String) The value of the assertion\nThe value of the assertion',
                                                            type: 'string',
                                                          },
                                                        },
                                                        type: 'object',
                                                      },
                                                      type: 'array',
                                                    },
                                                    request: {
                                                      description: '(Block Set, Max: 1) An individual MultiHTTP request (see below for nested schema)\nAn individual MultiHTTP request',
                                                      items: {
                                                        properties: {
                                                          body: {
                                                            description: '(String) The body of the HTTP request used in probe.\nThe body of the HTTP request used in probe.',
                                                            items: {
                                                              properties: {
                                                                contentEncoding: {
                                                                  description: '(String) The content encoding of the body\nThe content encoding of the body',
                                                                  type: 'string',
                                                                },
                                                                contentType: {
                                                                  description: '(String) The content type of the body\nThe content type of the body',
                                                                  type: 'string',
                                                                },
                                                                payload: {
                                                                  description: '(String) The body payload\nThe body payload',
                                                                  type: 'string',
                                                                },
                                                              },
                                                              type: 'object',
                                                            },
                                                            type: 'array',
                                                          },
                                                          headers: {
                                                            description: '(Set of String) The HTTP headers set for the probe.\nThe headers to send with the request',
                                                            items: {
                                                              properties: {
                                                                name: {
                                                                  description: '(String) Name of the header to send\nName of the header to send',
                                                                  type: 'string',
                                                                },
                                                                value: {
                                                                  description: '(String) The value of the assertion\nValue of the header to send',
                                                                  type: 'string',
                                                                },
                                                              },
                                                              type: 'object',
                                                            },
                                                            type: 'array',
                                                          },
                                                          method: {
                                                            description: '(String) Request method. One of GET, CONNECT, DELETE, HEAD, OPTIONS, POST, PUT, TRACE Defaults to GET.\nThe HTTP method to use',
                                                            type: 'string',
                                                          },
                                                          queryFields: {
                                                            description: '(Block Set) Query fields to send with the request (see below for nested schema)\nQuery fields to send with the request',
                                                            items: {
                                                              properties: {
                                                                name: {
                                                                  description: '(String) Name of the header to send\nName of the query field to send',
                                                                  type: 'string',
                                                                },
                                                                value: {
                                                                  description: '(String) The value of the assertion\nValue of the query field to send',
                                                                  type: 'string',
                                                                },
                                                              },
                                                              type: 'object',
                                                            },
                                                            type: 'array',
                                                          },
                                                          url: {
                                                            description: '(String) The URL for the request\nThe URL for the request',
                                                            type: 'string',
                                                          },
                                                        },
                                                        type: 'object',
                                                      },
                                                      type: 'array',
                                                    },
                                                    variables: {
                                                      description: '(Block List) Variables to extract from the request response (see below for nested schema)\nVariables to extract from the request response',
                                                      items: {
                                                        properties: {
                                                          attribute: {
                                                            description: '(String) The attribute to use when finding the variable value. Only used when type is CSS_SELECTOR\nThe attribute to use when finding the variable value. Only used when type is CSS_SELECTOR',
                                                            type: 'string',
                                                          },
                                                          expression: {
                                                            description: '(String) The expression of the assertion. Should start with $.\nThe expression to when finding the variable. Should start with $. Only use when type is JSON_PATH or REGEX',
                                                            type: 'string',
                                                          },
                                                          name: {
                                                            description: '(String) Name of the header to send\nThe name of the variable to extract',
                                                            type: 'string',
                                                          },
                                                          type: {
                                                            description: '(String) The type of assertion to make: TEXT, JSON_PATH_VALUE, JSON_PATH_ASSERTION, REGEX_ASSERTION\nThe method of finding the variable value to extract. JSON_PATH, REGEX, CSS_SELECTOR',
                                                            type: 'string',
                                                          },
                                                        },
                                                        type: 'object',
                                                      },
                                                      type: 'array',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        ping: {
                                          description: '(Block Set, Max: 1) Settings for ping (ICMP) check. The target must be a valid hostname or IP address. (see below for nested schema)\nSettings for ping (ICMP) check. The target must be a valid hostname or IP address.',
                                          items: {
                                            properties: {
                                              dontFragment: {
                                                description: 'bit in the IP-header. Only works with ipV4. Defaults to false.\nSet the DF-bit in the IP-header. Only works with ipV4. Defaults to `false`.',
                                                type: 'boolean',
                                              },
                                              ipVersion: {
                                                description: "(String) Options are V4, V6, Any. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The Any value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to V4.\nOptions are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.",
                                                type: 'string',
                                              },
                                              payloadSize: {
                                                description: '(Number) Payload size. Defaults to 0.\nPayload size. Defaults to `0`.',
                                                type: 'number',
                                              },
                                              sourceIpAddress: {
                                                description: '(String) Source IP address.\nSource IP address.',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        scripted: {
                                          description: 'cloud/testing/synthetic-monitoring/create-checks/checks/k6/. (see below for nested schema)\nSettings for scripted check. See https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/create-checks/checks/k6/.',
                                          items: {
                                            properties: {
                                              script: {
                                                description: '(String)',
                                                type: 'string',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        tcp: {
                                          description: '(Block Set, Max: 1) Settings for TCP check. The target must be of the form <host>:<port>, where the host portion must be a valid hostname or IP address. (see below for nested schema)\nSettings for TCP check. The target must be of the form `<host>:<port>`, where the host portion must be a valid hostname or IP address.',
                                          items: {
                                            properties: {
                                              ipVersion: {
                                                description: "(String) Options are V4, V6, Any. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The Any value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to V4.\nOptions are `V4`, `V6`, `Any`. Specifies whether the corresponding check will be performed using IPv4 or IPv6. The `Any` value indicates that IPv6 should be used, falling back to IPv4 if that's not available. Defaults to `V4`.",
                                                type: 'string',
                                              },
                                              queryResponse: {
                                                description: '(Block Set) The query sent in the TCP probe and the expected associated response. (see below for nested schema)\nThe query sent in the TCP probe and the expected associated response.',
                                                items: {
                                                  properties: {
                                                    expect: {
                                                      description: '(String) Response to expect.\nResponse to expect.',
                                                      type: 'string',
                                                    },
                                                    send: {
                                                      description: '(String) Data to send.\nData to send.',
                                                      type: 'string',
                                                    },
                                                    startTls: {
                                                      description: '(Boolean) Upgrade TCP connection to TLS. Defaults to false.\nUpgrade TCP connection to TLS. Defaults to `false`.',
                                                      type: 'boolean',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                              sourceIpAddress: {
                                                description: '(String) Source IP address.\nSource IP address.',
                                                type: 'string',
                                              },
                                              tls: {
                                                description: '(Boolean) Whether or not TLS is used when the connection is initiated. Defaults to false.\nWhether or not TLS is used when the connection is initiated. Defaults to `false`.',
                                                type: 'boolean',
                                              },
                                              tlsConfig: {
                                                description: '(Block Set, Max: 1) TLS config. (see below for nested schema)\nTLS config.',
                                                items: {
                                                  properties: {
                                                    caCert: {
                                                      description: '(String) CA certificate in PEM format.\nCA certificate in PEM format.',
                                                      type: 'string',
                                                    },
                                                    clientCert: {
                                                      description: '(String) Client certificate in PEM format.\nClient certificate in PEM format.',
                                                      type: 'string',
                                                    },
                                                    clientKeySecretRef: {
                                                      description: '(String, Sensitive) Client key in PEM format.\nClient key in PEM format.',
                                                      properties: {
                                                        key: {
                                                          description: 'The key to select.',
                                                          type: 'string',
                                                        },
                                                        name: {
                                                          description: 'Name of the secret.',
                                                          type: 'string',
                                                        },
                                                        namespace: {
                                                          description: 'Namespace of the secret.',
                                                          type: 'string',
                                                        },
                                                      },
                                                      required: [
                                                        'key',
                                                        'name',
                                                        'namespace',
                                                      ],
                                                      type: 'object',
                                                    },
                                                    insecureSkipVerify: {
                                                      description: '(Boolean) Disable target certificate validation. Defaults to false.\nDisable target certificate validation. Defaults to `false`.',
                                                      type: 'boolean',
                                                    },
                                                    serverName: {
                                                      description: '(String) Used to verify the hostname for the targets.\nUsed to verify the hostname for the targets.',
                                                      type: 'string',
                                                    },
                                                  },
                                                  type: 'object',
                                                },
                                                type: 'array',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                        traceroute: {
                                          description: '(Block Set, Max: 1) Settings for traceroute check. The target must be a valid hostname or IP address (see below for nested schema)\nSettings for traceroute check. The target must be a valid hostname or IP address',
                                          items: {
                                            properties: {
                                              maxHops: {
                                                description: '(Number) Maximum TTL for the trace Defaults to 64.\nMaximum TTL for the trace Defaults to `64`.',
                                                type: 'number',
                                              },
                                              maxUnknownHops: {
                                                description: '(Number) Maximum number of hosts to travers that give no response Defaults to 15.\nMaximum number of hosts to travers that give no response Defaults to `15`.',
                                                type: 'number',
                                              },
                                              ptrLookup: {
                                                description: '(Boolean) Reverse lookup hostnames from IP addresses Defaults to true.\nReverse lookup hostnames from IP addresses Defaults to `true`.',
                                                type: 'boolean',
                                              },
                                            },
                                            type: 'object',
                                          },
                                          type: 'array',
                                        },
                                      },
                                      type: 'object',
                                    },
                                    type: 'array',
                                  },
                                  target: {
                                    description: '(String) Hostname to ping.\nHostname to ping.',
                                    type: 'string',
                                  },
                                  timeout: {
                                    description: '(Number) Specifies the maximum running time for the check in milliseconds. The minimum acceptable value is 1 second (1000 ms), and the maximum 10 seconds (10000 ms). Defaults to 3000.\nSpecifies the maximum running time for the check in milliseconds. The minimum acceptable value is 1 second (1000 ms), and the maximum 10 seconds (10000 ms). Defaults to `3000`.',
                                    type: 'number',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.job is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.job) || (has(self.initProvider) && has(self.initProvider.job))",
                              },
                              {
                                message: 'spec.forProvider.probes is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.probes) || (has(self.initProvider) && has(self.initProvider.probes))",
                              },
                              {
                                message: 'spec.forProvider.settings is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.settings) || (has(self.initProvider) && has(self.initProvider.settings))",
                              },
                              {
                                message: 'spec.forProvider.target is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.target) || (has(self.initProvider) && has(self.initProvider.target))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      installation: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xinstallations.sm.grafana.crossplane.io.namespaced',
            },
            name: 'installation-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'sm.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XInstallation',
            },
            resources: [
              {
                base: {
                  apiVersion: 'sm.grafana.crossplane.io/v1alpha1',
                  kind: 'Installation',
                },
                name: 'installation',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackRef.name',
                    toFieldPath: 'spec.forProvider.cloudStackRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackRef.policy.resolution',
                    toFieldPath: 'spec.forProvider.cloudStackRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackRef.policy.resolve',
                    toFieldPath: 'spec.forProvider.cloudStackRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.matchControllerRef',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.matchLabels',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.policy.resolution',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.cloudStackSelector.policy.resolve',
                    toFieldPath: 'spec.forProvider.cloudStackSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.metricsPublisherKeySecretRef.key',
                    toFieldPath: 'spec.forProvider.metricsPublisherKeySecretRef.key',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.metricsPublisherKeySecretRef.name',
                    toFieldPath: 'spec.forProvider.metricsPublisherKeySecretRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.metricsPublisherKeySecretRef.namespace',
                    toFieldPath: 'spec.forProvider.metricsPublisherKeySecretRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.stackId',
                    toFieldPath: 'spec.forProvider.stackId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.stackSmApiUrl',
                    toFieldPath: 'spec.forProvider.stackSmApiUrl',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackRef.name',
                    toFieldPath: 'spec.initProvider.cloudStackRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackRef.policy.resolution',
                    toFieldPath: 'spec.initProvider.cloudStackRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackRef.policy.resolve',
                    toFieldPath: 'spec.initProvider.cloudStackRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.matchControllerRef',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.matchControllerRef',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.matchLabels',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.matchLabels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.policy.resolution',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.cloudStackSelector.policy.resolve',
                    toFieldPath: 'spec.initProvider.cloudStackSelector.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.metricsPublisherKeySecretRef.key',
                    toFieldPath: 'spec.initProvider.metricsPublisherKeySecretRef.key',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.metricsPublisherKeySecretRef.name',
                    toFieldPath: 'spec.initProvider.metricsPublisherKeySecretRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.metricsPublisherKeySecretRef.namespace',
                    toFieldPath: 'spec.initProvider.metricsPublisherKeySecretRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.stackId',
                    toFieldPath: 'spec.initProvider.stackId',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.stackSmApiUrl',
                    toFieldPath: 'spec.initProvider.stackSmApiUrl',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xinstallations.sm.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Installation',
              plural: 'installations',
            },
            defaultCompositionRef: {
              name: 'installation-namespaced',
            },
            group: 'sm.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XInstallation',
              plural: 'xinstallations',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'InstallationSpec defines the desired state of Installation',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  cloudStackRef: {
                                    description: 'Reference to a Stack in cloud to populate stackId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  cloudStackSelector: {
                                    description: 'Selector for a Stack in cloud to populate stackId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  metricsPublisherKeySecretRef: {
                                    description: '(String, Sensitive) The Grafana Cloud access policy with the following scopes: stacks:read, metrics:write, logs:write, traces:write. This is used to publish metrics and logs to Grafana Cloud stack.\nThe [Grafana Cloud access policy](https://grafana.com/docs/grafana-cloud/account-management/authentication-and-permissions/access-policies/) with the following scopes: `stacks:read`, `metrics:write`, `logs:write`, `traces:write`. This is used to publish metrics and logs to Grafana Cloud stack.',
                                    properties: {
                                      key: {
                                        description: 'The key to select.',
                                        type: 'string',
                                      },
                                      name: {
                                        description: 'Name of the secret.',
                                        type: 'string',
                                      },
                                      namespace: {
                                        description: 'Namespace of the secret.',
                                        type: 'string',
                                      },
                                    },
                                    required: [
                                      'key',
                                      'name',
                                      'namespace',
                                    ],
                                    type: 'object',
                                  },
                                  stackId: {
                                    description: '(String) The ID or slug of the stack to install SM on.\nThe ID or slug of the stack to install SM on.',
                                    type: 'string',
                                  },
                                  stackSmApiUrl: {
                                    description: "cloud/testing/synthetic-monitoring/set-up/set-up-private-probes/#probe-api-server-url. A static mapping exists in the provider but it may not contain all the regions. If it does contain the stack's region, this field is computed automatically and readable.\nThe URL of the SM API to install SM on. This depends on the stack region, find the list of API URLs here: https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/set-up/set-up-private-probes/#probe-api-server-url. A static mapping exists in the provider but it may not contain all the regions. If it does contain the stack's region, this field is computed automatically and readable.",
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  cloudStackRef: {
                                    description: 'Reference to a Stack in cloud to populate stackId.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  cloudStackSelector: {
                                    description: 'Selector for a Stack in cloud to populate stackId.',
                                    properties: {
                                      matchControllerRef: {
                                        description: 'MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.',
                                        type: 'boolean',
                                      },
                                      matchLabels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'MatchLabels ensures an object with matching labels is selected.',
                                        type: 'object',
                                      },
                                      policy: {
                                        description: 'Policies for selection.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  metricsPublisherKeySecretRef: {
                                    description: '(String, Sensitive) The Grafana Cloud access policy with the following scopes: stacks:read, metrics:write, logs:write, traces:write. This is used to publish metrics and logs to Grafana Cloud stack.\nThe [Grafana Cloud access policy](https://grafana.com/docs/grafana-cloud/account-management/authentication-and-permissions/access-policies/) with the following scopes: `stacks:read`, `metrics:write`, `logs:write`, `traces:write`. This is used to publish metrics and logs to Grafana Cloud stack.',
                                    properties: {
                                      key: {
                                        description: 'The key to select.',
                                        type: 'string',
                                      },
                                      name: {
                                        description: 'Name of the secret.',
                                        type: 'string',
                                      },
                                      namespace: {
                                        description: 'Namespace of the secret.',
                                        type: 'string',
                                      },
                                    },
                                    required: [
                                      'key',
                                      'name',
                                      'namespace',
                                    ],
                                    type: 'object',
                                  },
                                  stackId: {
                                    description: '(String) The ID or slug of the stack to install SM on.\nThe ID or slug of the stack to install SM on.',
                                    type: 'string',
                                  },
                                  stackSmApiUrl: {
                                    description: "cloud/testing/synthetic-monitoring/set-up/set-up-private-probes/#probe-api-server-url. A static mapping exists in the provider but it may not contain all the regions. If it does contain the stack's region, this field is computed automatically and readable.\nThe URL of the SM API to install SM on. This depends on the stack region, find the list of API URLs here: https://grafana.com/docs/grafana-cloud/testing/synthetic-monitoring/set-up/set-up-private-probes/#probe-api-server-url. A static mapping exists in the provider but it may not contain all the regions. If it does contain the stack's region, this field is computed automatically and readable.",
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'metricsPublisherKeySecretRef',
                                ],
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.metricsPublisherKeySecretRef is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.metricsPublisherKeySecretRef)",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
      probe: {
        composition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'Composition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            labels: {
              'crossplane.io/xrd': 'xprobes.sm.grafana.crossplane.io.namespaced',
            },
            name: 'probe-namespaced',
          },
          spec: {
            compositeTypeRef: {
              apiVersion: 'sm.grafana.crossplane.io.namespaced/v1alpha1',
              kind: 'XProbe',
            },
            resources: [
              {
                base: {
                  apiVersion: 'sm.grafana.crossplane.io/v1alpha1',
                  kind: 'Probe',
                },
                name: 'probe',
                patches: [
                  {
                    fromFieldPath: 'spec.parameters.externalName',
                    toFieldPath: 'metadata.annotations["crossplane.io/external-name"]',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.deletionPolicy',
                    toFieldPath: 'spec.deletionPolicy',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.disableScriptedChecks',
                    toFieldPath: 'spec.forProvider.disableScriptedChecks',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.labels',
                    toFieldPath: 'spec.forProvider.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.latitude',
                    toFieldPath: 'spec.forProvider.latitude',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.longitude',
                    toFieldPath: 'spec.forProvider.longitude',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.name',
                    toFieldPath: 'spec.forProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.public',
                    toFieldPath: 'spec.forProvider.public',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.forProvider.region',
                    toFieldPath: 'spec.forProvider.region',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.disableScriptedChecks',
                    toFieldPath: 'spec.initProvider.disableScriptedChecks',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.labels',
                    toFieldPath: 'spec.initProvider.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.latitude',
                    toFieldPath: 'spec.initProvider.latitude',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.longitude',
                    toFieldPath: 'spec.initProvider.longitude',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.name',
                    toFieldPath: 'spec.initProvider.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.public',
                    toFieldPath: 'spec.initProvider.public',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.initProvider.region',
                    toFieldPath: 'spec.initProvider.region',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.managementPolicies',
                    toFieldPath: 'spec.managementPolicies',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.name',
                    toFieldPath: 'spec.providerConfigRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolution',
                    toFieldPath: 'spec.providerConfigRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.providerConfigRef.policy.resolve',
                    toFieldPath: 'spec.providerConfigRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolution',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolution',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.configRef.policy.resolve',
                    toFieldPath: 'spec.publishConnectionDetailsTo.configRef.policy.resolve',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.annotations',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.annotations',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.labels',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.labels',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.metadata.type',
                    toFieldPath: 'spec.publishConnectionDetailsTo.metadata.type',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.publishConnectionDetailsTo.name',
                    toFieldPath: 'spec.publishConnectionDetailsTo.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.name',
                    toFieldPath: 'spec.writeConnectionSecretToRef.name',
                    type: 'FromCompositeFieldPath',
                  },
                  {
                    fromFieldPath: 'spec.parameters.writeConnectionSecretToRef.namespace',
                    toFieldPath: 'spec.writeConnectionSecretToRef.namespace',
                    type: 'FromCompositeFieldPath',
                  },
                ],
              },
            ],
          },
        },
        definition: {
          apiVersion: 'apiextensions.crossplane.io/v1',
          kind: 'CompositeResourceDefinition',
          metadata: {
            annotations: {
              'tanka.dev/namespaced': 'false',
            },
            name: 'xprobes.sm.grafana.crossplane.io.namespaced',
          },
          spec: {
            claimNames: {
              kind: 'Probe',
              plural: 'probes',
            },
            defaultCompositionRef: {
              name: 'probe-namespaced',
            },
            group: 'sm.grafana.crossplane.io.namespaced',
            names: {
              kind: 'XProbe',
              plural: 'xprobes',
            },
            versions: [
              {
                name: 'v1alpha1',
                referenceable: true,
                schema: {
                  openAPIV3Schema: {
                    properties: {
                      apiVersion: {
                        type: 'string',
                      },
                      kind: {
                        type: 'string',
                      },
                      metadata: {
                        type: 'object',
                      },
                      spec: {
                        properties: {
                          parameters: {
                            description: 'ProbeSpec defines the desired state of Probe',
                            properties: {
                              deletionPolicy: {
                                default: 'Delete',
                                description: 'DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either "Delete" or "Orphan" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223',
                                enum: [
                                  'Orphan',
                                  'Delete',
                                ],
                                type: 'string',
                              },
                              externalName: {
                                description: 'The name of the managed resource inside the Provider.\nBy default Providers give external resources the same name as the Kubernetes object. A provider uses the external name to lookup a managed resource in an external system. The provider looks up the resource in the external system to determine if it exists, and if it matches the managed resource’s desired state. If the provider can’t find the resource, it creates it.\n\nDocs: https://docs.crossplane.io/latest/concepts/managed-resources/#naming-external-resources\n',
                                type: 'string',
                              },
                              forProvider: {
                                properties: {
                                  disableScriptedChecks: {
                                    description: '(Boolean) Disables scripted checks for this probe. Defaults to false.\nDisables scripted checks for this probe. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  labels: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    description: '(Map of String) Custom labels to be included with collected metrics and logs.\nCustom labels to be included with collected metrics and logs.',
                                    type: 'object',
                                    'x-kubernetes-map-type': 'granular',
                                  },
                                  latitude: {
                                    description: '(Number) Latitude coordinates.\nLatitude coordinates.',
                                    type: 'number',
                                  },
                                  longitude: {
                                    description: '(Number) Longitude coordinates.\nLongitude coordinates.',
                                    type: 'number',
                                  },
                                  name: {
                                    description: '(String) Name of the probe.\nName of the probe.',
                                    type: 'string',
                                  },
                                  public: {
                                    description: '(Boolean) Public probes are run by Grafana Labs and can be used by all users. Only Grafana Labs managed public probes will be set to true. Defaults to false.\nPublic probes are run by Grafana Labs and can be used by all users. Only Grafana Labs managed public probes will be set to `true`. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  region: {
                                    description: '(String) Region of the probe.\nRegion of the probe.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              initProvider: {
                                description: 'THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.',
                                properties: {
                                  disableScriptedChecks: {
                                    description: '(Boolean) Disables scripted checks for this probe. Defaults to false.\nDisables scripted checks for this probe. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  labels: {
                                    additionalProperties: {
                                      type: 'string',
                                    },
                                    description: '(Map of String) Custom labels to be included with collected metrics and logs.\nCustom labels to be included with collected metrics and logs.',
                                    type: 'object',
                                    'x-kubernetes-map-type': 'granular',
                                  },
                                  latitude: {
                                    description: '(Number) Latitude coordinates.\nLatitude coordinates.',
                                    type: 'number',
                                  },
                                  longitude: {
                                    description: '(Number) Longitude coordinates.\nLongitude coordinates.',
                                    type: 'number',
                                  },
                                  name: {
                                    description: '(String) Name of the probe.\nName of the probe.',
                                    type: 'string',
                                  },
                                  public: {
                                    description: '(Boolean) Public probes are run by Grafana Labs and can be used by all users. Only Grafana Labs managed public probes will be set to true. Defaults to false.\nPublic probes are run by Grafana Labs and can be used by all users. Only Grafana Labs managed public probes will be set to `true`. Defaults to `false`.',
                                    type: 'boolean',
                                  },
                                  region: {
                                    description: '(String) Region of the probe.\nRegion of the probe.',
                                    type: 'string',
                                  },
                                },
                                type: 'object',
                              },
                              managementPolicies: {
                                default: [
                                  '*',
                                ],
                                description: 'THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md',
                                items: {
                                  description: 'A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.',
                                  enum: [
                                    'Observe',
                                    'Create',
                                    'Update',
                                    'Delete',
                                    'LateInitialize',
                                    '*',
                                  ],
                                  type: 'string',
                                },
                                type: 'array',
                              },
                              providerConfigRef: {
                                default: {
                                  name: 'default',
                                },
                                description: 'ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.',
                                properties: {
                                  name: {
                                    description: 'Name of the referenced object.',
                                    type: 'string',
                                  },
                                  policy: {
                                    description: 'Policies for referencing.',
                                    properties: {
                                      resolution: {
                                        default: 'Required',
                                        description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                        enum: [
                                          'Required',
                                          'Optional',
                                        ],
                                        type: 'string',
                                      },
                                      resolve: {
                                        description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                        enum: [
                                          'Always',
                                          'IfNotPresent',
                                        ],
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              publishConnectionDetailsTo: {
                                description: 'PublishConnectionDetailsTo specifies the connection secret config which\ncontains a name, metadata and a reference to secret store config to\nwhich any connection details for this managed resource should be written.\nConnection details frequently include the endpoint, username,\nand password required to connect to the managed resource.',
                                properties: {
                                  configRef: {
                                    default: {
                                      name: 'default',
                                    },
                                    description: 'SecretStoreConfigRef specifies which secret store config should be used\nfor this ConnectionSecret.',
                                    properties: {
                                      name: {
                                        description: 'Name of the referenced object.',
                                        type: 'string',
                                      },
                                      policy: {
                                        description: 'Policies for referencing.',
                                        properties: {
                                          resolution: {
                                            default: 'Required',
                                            description: "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                                            enum: [
                                              'Required',
                                              'Optional',
                                            ],
                                            type: 'string',
                                          },
                                          resolve: {
                                            description: "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                                            enum: [
                                              'Always',
                                              'IfNotPresent',
                                            ],
                                            type: 'string',
                                          },
                                        },
                                        type: 'object',
                                      },
                                    },
                                    required: [
                                      'name',
                                    ],
                                    type: 'object',
                                  },
                                  metadata: {
                                    description: 'Metadata is the metadata for connection secret.',
                                    properties: {
                                      annotations: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Annotations are the annotations to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.annotations".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      labels: {
                                        additionalProperties: {
                                          type: 'string',
                                        },
                                        description: 'Labels are the labels/tags to be added to connection secret.\n- For Kubernetes secrets, this will be used as "metadata.labels".\n- It is up to Secret Store implementation for others store types.',
                                        type: 'object',
                                      },
                                      type: {
                                        description: 'Type is the SecretType for the connection secret.\n- Only valid for Kubernetes Secret Stores.',
                                        type: 'string',
                                      },
                                    },
                                    type: 'object',
                                  },
                                  name: {
                                    description: 'Name is the name of the connection secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                ],
                                type: 'object',
                              },
                              writeConnectionSecretToRef: {
                                description: 'WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.\nThis field is planned to be replaced in a future release in favor of\nPublishConnectionDetailsTo. Currently, both could be set independently\nand connection details would be published to both without affecting\neach other.',
                                properties: {
                                  name: {
                                    description: 'Name of the secret.',
                                    type: 'string',
                                  },
                                  namespace: {
                                    description: 'Namespace of the secret.',
                                    type: 'string',
                                  },
                                },
                                required: [
                                  'name',
                                  'namespace',
                                ],
                                type: 'object',
                              },
                            },
                            required: [
                              'forProvider',
                            ],
                            type: 'object',
                            'x-kubernetes-validations': [
                              {
                                message: 'spec.forProvider.latitude is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.latitude) || (has(self.initProvider) && has(self.initProvider.latitude))",
                              },
                              {
                                message: 'spec.forProvider.longitude is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.longitude) || (has(self.initProvider) && has(self.initProvider.longitude))",
                              },
                              {
                                message: 'spec.forProvider.name is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",
                              },
                              {
                                message: 'spec.forProvider.region is a required parameter',
                                rule: "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.region) || (has(self.initProvider) && has(self.initProvider.region))",
                              },
                            ],
                          },
                        },
                        type: 'object',
                      },
                    },
                    type: 'object',
                  },
                },
                served: true,
              },
            ],
          },
        },
      },
    },
  },
}
